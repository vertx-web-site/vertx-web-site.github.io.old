{"pageProps":{"slug":"3.9.3/vertx-mysql-postgresql-client/groovy","title":"Vert.x MySQL / PostgreSQL client","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_the_mysql_and_postgresql_client\">Using the MySQL and PostgreSQL client</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_in_a_regular_application\">In a regular application</a></li>\n<li><a href=\"#_in_an_application_packaged_in_a_fat_jar\">In an application packaged in a fat jar</a></li>\n<li><a href=\"#_in_an_application_using_a_vert_x_distributions\">In an application using a vert.x distributions</a></li>\n</ul>\n</li>\n<li><a href=\"#_creating_a_client\">Creating a client</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_default_shared_pool\">Using default shared pool</a></li>\n<li><a href=\"#_specifying_a_pool_name\">Specifying a pool name</a></li>\n<li><a href=\"#_creating_a_client_with_a_non_shared_data_source\">Creating a client with a non shared data source</a></li>\n</ul>\n</li>\n<li><a href=\"#_closing_the_client\">Closing the client</a></li>\n<li><a href=\"#_getting_a_connection\">Getting a connection</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_configuring_reconnections\">Configuring reconnections</a></li>\n<li><a href=\"#_note_about_date_and_timestamps\">Note about date and timestamps</a></li>\n<li><a href=\"#_note_about_last_inserted_ids\">Note about last inserted ids</a></li>\n<li><a href=\"#_note_about_stored_procedures\">Note about stored procedures</a></li>\n</ul>\n</li>\n<li><a href=\"#_configuration\">Configuration</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x MySQL / PostgreSQL client</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Async MySQL / PostgreSQL Client is responsible for providing an\ninterface for Vert.x applications that need to interact with a MySQL or PostgreSQL database.</p>\n</div>\n<div class=\"paragraph\">\n<p>It uses Mauricio Linhares <a href=\"https://github.com/mauricio/postgresql-async\">async driver</a> to interact with the MySQL\nor PostgreSQL databases in a non blocking way.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_mysql_and_postgresql_client\"><a class=\"anchor\" href=\"#_using_the_mysql_and_postgresql_client\"></a>Using the MySQL and PostgreSQL client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This section describes how to configure your project to be able to use the MySQL / PostgreSQL client in your\napplication.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_in_a_regular_application\"><a class=\"anchor\" href=\"#_in_a_regular_application\"></a>In a regular application</h3>\n<div class=\"paragraph\">\n<p>To use this client, you need to add the following jar to your <code>CLASSPATH</code>:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>vertx-lang-groovy 3.9.3 (the client)</p>\n</li>\n<li>\n<p>scala-library 2.11.4</p>\n</li>\n<li>\n<p>the postgress-async-2.11 and mysdql-async-2.11 from <a href=\"https://github.com/mauricio/postgresql-async\" class=\"bare\">https://github.com/mauricio/postgresql-async</a></p>\n</li>\n<li>\n<p>joda time</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>All these jars are downloadable from Maven Central.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_in_an_application_packaged_in_a_fat_jar\"><a class=\"anchor\" href=\"#_in_an_application_packaged_in_a_fat_jar\"></a>In an application packaged in a fat jar</h3>\n<div class=\"paragraph\">\n<p>If you are building a <em>Fat-jar</em> using Maven or Gradle, just add the following dependencies:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-mysql-postgresql-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-mysql-postgresql-client:3.9.3&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_in_an_application_using_a_vert_x_distributions\"><a class=\"anchor\" href=\"#_in_an_application_using_a_vert_x_distributions\"></a>In an application using a vert.x distributions</h3>\n<div class=\"paragraph\">\n<p>If you are using a vert.x distribution, add the jar files listed above to the <code>$VERTX_HOME/lib</code> directory.</p>\n</div>\n<div class=\"paragraph\">\n<p>Alternatively, you can edit the <code>vertx-stack.json</code> file located in <code>$VERTX_HOME</code>, and set <code>\"included\": true</code>\nfor the <code>vertx-mysql-postgresql-client</code> dependency. Once done, launch: <code>vertx resolve --dir=lib --stack=\n./vertx-stack.json</code>. It downloads the client and its dependencies.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_client\"><a class=\"anchor\" href=\"#_creating_a_client\"></a>Creating a client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>There are several ways to create a client. Let&#8217;s go through them all.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_default_shared_pool\"><a class=\"anchor\" href=\"#_using_default_shared_pool\"></a>Using default shared pool</h3>\n<div class=\"paragraph\">\n<p>In most cases you will want to share a pool between different client instances.</p>\n</div>\n<div class=\"paragraph\">\n<p>E.g. you scale your application by deploying multiple instances of your verticle and you want each verticle instance\nto share the same pool so you don&#8217;t end up with multiple pools</p>\n</div>\n<div class=\"paragraph\">\n<p>You do this as follows:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// To create a MySQL client:</span>\n\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">mySQLClientConfig</span> <span class=\"hljs-operator\">=</span> [\n  host:<span class=\"hljs-string\">&quot;mymysqldb.mycompany&quot;</span>\n]\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">mySQLClient</span> <span class=\"hljs-operator\">=</span> MySQLClient.createShared(vertx, mySQLClientConfig)\n\n<span class=\"hljs-comment\">// To create a PostgreSQL client:</span>\n\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">postgreSQLClientConfig</span> <span class=\"hljs-operator\">=</span> [\n  host:<span class=\"hljs-string\">&quot;mypostgresqldb.mycompany&quot;</span>\n]\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">postgreSQLClient</span> <span class=\"hljs-operator\">=</span> PostgreSQLClient.createShared(vertx, postgreSQLClientConfig)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The first call to <code><a href=\"../../apidocs/io/vertx/ext/asyncsql/MySQLClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">MySQLClient.createShared</a></code>\nor <code><a href=\"../../apidocs/io/vertx/ext/asyncsql/PostgreSQLClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">PostgreSQLClient.createShared</a></code>\nwill actually create the data source, and the specified config will be used.</p>\n</div>\n<div class=\"paragraph\">\n<p>Subsequent calls will return a new client instance that uses the same data source, so the configuration won&#8217;t be used.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_specifying_a_pool_name\"><a class=\"anchor\" href=\"#_specifying_a_pool_name\"></a>Specifying a pool name</h3>\n<div class=\"paragraph\">\n<p>You can create a client specifying a pool name as follows</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// To create a MySQL client:</span>\n\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">mySQLClientConfig</span> <span class=\"hljs-operator\">=</span> [\n  host:<span class=\"hljs-string\">&quot;mymysqldb.mycompany&quot;</span>\n]\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">mySQLClient</span> <span class=\"hljs-operator\">=</span> MySQLClient.createShared(vertx, mySQLClientConfig, <span class=\"hljs-string\">&quot;MySQLPool1&quot;</span>)\n\n<span class=\"hljs-comment\">// To create a PostgreSQL client:</span>\n\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">postgreSQLClientConfig</span> <span class=\"hljs-operator\">=</span> [\n  host:<span class=\"hljs-string\">&quot;mypostgresqldb.mycompany&quot;</span>\n]\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">postgreSQLClient</span> <span class=\"hljs-operator\">=</span> PostgreSQLClient.createShared(vertx, postgreSQLClientConfig, <span class=\"hljs-string\">&quot;PostgreSQLPool1&quot;</span>)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If different clients are created using the same Vert.x instance and specifying the same pool name, they will\nshare the same data source.</p>\n</div>\n<div class=\"paragraph\">\n<p>The first call to <code><a href=\"../../apidocs/io/vertx/ext/asyncsql/MySQLClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-java.lang.String-\">MySQLClient.createShared</a></code>\nor <code><a href=\"../../apidocs/io/vertx/ext/asyncsql/PostgreSQLClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-java.lang.String-\">PostgreSQLClient.createShared</a></code>\nwill actually create the data source, and the specified config will be used.</p>\n</div>\n<div class=\"paragraph\">\n<p>Subsequent calls will return a new client instance that uses the same pool, so the configuration won&#8217;t be used.</p>\n</div>\n<div class=\"paragraph\">\n<p>Use this way of creating if you wish different groups of clients to have different pools, e.g. they&#8217;re\ninteracting with different databases.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_a_client_with_a_non_shared_data_source\"><a class=\"anchor\" href=\"#_creating_a_client_with_a_non_shared_data_source\"></a>Creating a client with a non shared data source</h3>\n<div class=\"paragraph\">\n<p>In most cases you will want to share a pool between different client instances.\nHowever, it&#8217;s possible you want to create a client instance that doesn&#8217;t share its pool with any other client.</p>\n</div>\n<div class=\"paragraph\">\n<p>In that case you can use <code><a href=\"../../apidocs/io/vertx/ext/asyncsql/MySQLClient.html#createNonShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">MySQLClient.createNonShared</a></code>\nor <code><a href=\"../../apidocs/io/vertx/ext/asyncsql/PostgreSQLClient.html#createNonShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-\">PostgreSQLClient.createNonShared</a></code></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// To create a MySQL client:</span>\n\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">mySQLClientConfig</span> <span class=\"hljs-operator\">=</span> [\n  host:<span class=\"hljs-string\">&quot;mymysqldb.mycompany&quot;</span>\n]\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">mySQLClient</span> <span class=\"hljs-operator\">=</span> MySQLClient.createNonShared(vertx, mySQLClientConfig)\n\n<span class=\"hljs-comment\">// To create a PostgreSQL client:</span>\n\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">postgreSQLClientConfig</span> <span class=\"hljs-operator\">=</span> [\n  host:<span class=\"hljs-string\">&quot;mypostgresqldb.mycompany&quot;</span>\n]\n<span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">postgreSQLClient</span> <span class=\"hljs-operator\">=</span> PostgreSQLClient.createNonShared(vertx, postgreSQLClientConfig)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This is equivalent to calling <code><a href=\"../../apidocs/io/vertx/ext/asyncsql/MySQLClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-java.lang.String-\">MySQLClient.createShared</a></code>\nor <code><a href=\"../../apidocs/io/vertx/ext/asyncsql/PostgreSQLClient.html#createShared-io.vertx.core.Vertx-io.vertx.core.json.JsonObject-java.lang.String-\">PostgreSQLClient.createShared</a></code>\nwith a unique pool name each time.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_closing_the_client\"><a class=\"anchor\" href=\"#_closing_the_client\"></a>Closing the client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can hold on to the client for a long time (e.g. the life-time of your verticle), but once you have finished with\nit, you should close it using <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#close-io.vertx.core.Handler-\">close</a></code> or\n<code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#close--\">close</a></code></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_a_connection\"><a class=\"anchor\" href=\"#_getting_a_connection\"></a>Getting a connection</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Use <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#getConnection-io.vertx.core.Handler-\">getConnection</a></code> to get a connection.</p>\n</div>\n<div class=\"paragraph\">\n<p>This will return the connection in the handler when one is ready from the pool.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// Now do stuff with it:</span>\n\nclient.getConnection({ res -&gt;\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n\n    <span class=\"hljs-type\">def</span> <span class=\"hljs-variable\">connection</span> <span class=\"hljs-operator\">=</span> res.result()\n\n    <span class=\"hljs-comment\">// Got a connection</span>\n\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Failed to get connection - deal with it</span>\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Once you&#8217;ve finished with the connection make sure you close it afterwards.</p>\n</div>\n<div class=\"paragraph\">\n<p>The connection is an instance of <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLConnection.html\">SQLConnection</a></code> which is a common interface used by\nother SQL clients.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can learn how to use it in the <a href=\"http://vertx.io/docs/vertx-sql-common/groovy/\">common sql interface</a> documentation.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_reconnections\"><a class=\"anchor\" href=\"#_configuring_reconnections\"></a>Configuring reconnections</h3>\n<div class=\"paragraph\">\n<p>This service is able to recover from temporary database outages, such as those which occur during a database restart or\nbrief loss of network connectivity. You can configure the expected behaviour when acquiring connections via the\nfollowing properties:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>maxConnectionRetries</code></p>\n</li>\n<li>\n<p><code>connectionRetryDelay</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>When the internal connection pool attempts to acquire an open connection and fails, it will retry up to\n<code>maxConnectionRetries</code> times, with a delay of <code>connectionRetryDelay</code> milliseconds between each attempt.\nIf all attempts fail, any clients waiting for connections from the pool will be notified with an Error, indicating that\na Connection could not be acquired. Note that clients will not be notified with an Error until a full round of attempts\nfail, which may be some time after the initial connection attempt.</p>\n</div>\n<div class=\"paragraph\">\n<p>If <code>maxConnectionRetries</code> is set to <code>0</code>, the internal connection pool will not perform any reconnection (default). If\n<code>maxConnectionRetries</code> is set to <code>-1</code>, the internal connection pool will attempt to acquire new connections indefinitely,\nso any call to <code><a href=\"../../apidocs/io/vertx/ext/sql/SQLClient.html#getConnection-io.vertx.core.Handler-\">getConnection</a></code>\nmay be indefinitely waiting for a successful acquisition.</p>\n</div>\n<div class=\"paragraph\">\n<p>Once a full round of acquisition attempts fails, the internal connection pool will remain active, and will try\nagain to acquire connections in response to future requests for connections.</p>\n</div>\n<div class=\"paragraph\">\n<p>Note that if a database restart occurs, a pool may contain previously acquired but now stale Connections that will only be\ndetected and purged lazily, when the pool attempts to reuse them.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_note_about_date_and_timestamps\"><a class=\"anchor\" href=\"#_note_about_date_and_timestamps\"></a>Note about date and timestamps</h3>\n<div class=\"paragraph\">\n<p>Whenever you get dates back from the database, this service will implicitly convert them into ISO 8601\n(<code>yyyy-MM-ddTHH:mm:ss.SSS</code>) formatted strings. MySQL usually discards milliseconds, so you will regularly see <code>.000</code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_note_about_last_inserted_ids\"><a class=\"anchor\" href=\"#_note_about_last_inserted_ids\"></a>Note about last inserted ids</h3>\n<div class=\"paragraph\">\n<p>When inserting new rows into a table, you might want to retrieve auto-incremented ids from the database. The JDBC API\nusually lets you retrieve the last inserted id from a connection. If you use MySQL, it will work the way it does like\nthe JDBC API. In PostgreSQL you can add the\n<a href=\"http://www.postgresql.org/docs/current/static/sql-insert.html\">\"RETURNING\" clause</a> to get the latest inserted ids. Use\none of the <code>query</code> methods to get access to the returned columns.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_note_about_stored_procedures\"><a class=\"anchor\" href=\"#_note_about_stored_procedures\"></a>Note about stored procedures</h3>\n<div class=\"paragraph\">\n<p>The <code>call</code> and <code>callWithParams</code> methods are not implemented currently.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuration\"><a class=\"anchor\" href=\"#_configuration\"></a>Configuration</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Both the PostgreSql and MySql clients take the same configuration:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>{\n \"host\" : &lt;your-host&gt;,\n \"port\" : &lt;your-port&gt;,\n \"maxPoolSize\" : &lt;maximum-number-of-open-connections&gt;,\n \"username\" : &lt;your-username&gt;,\n \"password\" : &lt;your-password&gt;,\n \"database\" : &lt;name-of-your-database&gt;,\n \"charset\" : &lt;name-of-the-character-set&gt;,\n \"connectTimeout\" : &lt;timeout-in-milliseconds&gt;,\n \"testTimeout\" : &lt;timeout-in-milliseconds&gt;,\n \"queryTimeout\" : &lt;timeout-in-milliseconds&gt;,\n \"maxConnectionRetries\" : &lt;maximum-number-of-connection-retries&gt;,\n \"connectionRetryDelay\" : &lt;delay-in-milliseconds&gt;,\n \"sslMode\" : &lt;\"disable\"|\"prefer\"|\"require\"|\"verify-ca\"|\"verify-full\"&gt;,\n \"sslRootCert\" : &lt;path to file with certificate&gt;\n}</pre>\n</div>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\"><code>host</code></dt>\n<dd>\n<p>The host of the database. Defaults to <code>localhost</code>.</p>\n</dd>\n<dt class=\"hdlist1\"><code>port</code></dt>\n<dd>\n<p>The port of the database. Defaults to <code>5432</code> for PostgreSQL and <code>3306</code> for MySQL.</p>\n</dd>\n<dt class=\"hdlist1\"><code>maxPoolSize</code></dt>\n<dd>\n<p>The number of connections that may be kept open. Defaults to <code>10</code>.</p>\n</dd>\n<dt class=\"hdlist1\"><code>username</code></dt>\n<dd>\n<p>The username to connect to the database. Defaults to <code>vertx</code>.</p>\n</dd>\n<dt class=\"hdlist1\"><code>password</code></dt>\n<dd>\n<p>The password to connect to the database. Defaults to <code>password</code>.</p>\n</dd>\n<dt class=\"hdlist1\"><code>database</code></dt>\n<dd>\n<p>The name of the database you want to connect to. Defaults to <code>testdb</code>.</p>\n</dd>\n<dt class=\"hdlist1\"><code>charset</code></dt>\n<dd>\n<p>The name of the character set you want to use for the connection. Defaults to <code>UTF-8</code>.</p>\n</dd>\n<dt class=\"hdlist1\"><code>connectTimeout</code></dt>\n<dd>\n<p>The timeout to wait for connecting to the database. Defaults to <code>10000</code> (= 10 seconds).</p>\n</dd>\n<dt class=\"hdlist1\"><code>testTimeout</code></dt>\n<dd>\n<p>The timeout for connection tests performed by pools. Defaults to <code>10000</code> (= 10 seconds).</p>\n</dd>\n<dt class=\"hdlist1\"><code>queryTimeout</code></dt>\n<dd>\n<p>The timeout to wait for a query in milliseconds. Default is not set.</p>\n</dd>\n<dt class=\"hdlist1\"><code>maxConnectionRetries</code></dt>\n<dd>\n<p>Maximum number of connection retries. Defaults to <code>0</code> (no retries).<br>\nSpecial values:</p>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">-1 </dt>\n<dd>\n<p>Unlimited number of connection retries</p>\n</dd>\n<dt class=\"hdlist1\">0  </dt>\n<dd>\n<p>No connection retries will be done</p>\n</dd>\n</dl>\n</div>\n</dd>\n<dt class=\"hdlist1\"><code>connectionRetryDelay</code></dt>\n<dd>\n<p>Delay in milliseconds between each retry attempt. Defaults to <code>5000</code> (= 5 seconds).</p>\n</dd>\n<dt class=\"hdlist1\"><code>sslMode</code> </dt>\n<dd>\n<p>If you want to enable SSL support you should enable this parameter.\nFor example to connect Heroku you will need to use <strong>prefer</strong>.</p>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">\"disable\" </dt>\n<dd>\n<p>only try a non-SSL connection</p>\n</dd>\n<dt class=\"hdlist1\">\"prefer\"  </dt>\n<dd>\n<p>first try an SSL connection; if that fails, try a non-SSL connection</p>\n</dd>\n<dt class=\"hdlist1\">\"require\"  </dt>\n<dd>\n<p>only try an SSL connection, but don&#8217;t verify Certificate Authority</p>\n</dd>\n<dt class=\"hdlist1\">\"verify-ca\"  </dt>\n<dd>\n<p>only try an SSL connection, and verify that the server certificate is issued by a trusted\ncertificate authority (CA)</p>\n</dd>\n<dt class=\"hdlist1\">\"verify-full\"  </dt>\n<dd>\n<p>only try an SSL connection, verify that the server certificate is issued by a trusted CA and\nthat the server host name matches that in the certificate</p>\n</dd>\n</dl>\n</div>\n</dd>\n<dt class=\"hdlist1\"><code>sslRootCert</code> </dt>\n<dd>\n<p>Path to SSL root certificate file. Is used if you want to verify privately issued certificate.\nRefer to <a href=\"https://github.com/mauricio/postgresql-async\">postgresql-async</a> documentation for more details.</p>\n</dd>\n</dl>\n</div>\n</div>\n</div>","version":"3.9.3"},"__N_SSG":true}