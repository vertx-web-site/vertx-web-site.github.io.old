{"pageProps":{"slug":"4.3.0/vertx-grpc/java","title":"Vert.x gRPC","fallbackGitHubStars":2,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_vert_x_grpc_server\">Vert.x gRPC Server</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_vert_x_grpc_server\">Using Vert.x gRPC Server</a></li>\n<li><a href=\"#_grpc_requestresponse_server_api\">gRPC request/response server API</a></li>\n<li><a href=\"#_flow_control\">Flow control</a></li>\n<li><a href=\"#_compression\">Compression</a></li>\n<li><a href=\"#_decompression\">Decompression</a></li>\n<li><a href=\"#_stub_api\">Stub API</a></li>\n<li><a href=\"#_message_level_api\">Message level API</a></li>\n</ul>\n</li>\n<li><a href=\"#_vert_x_grpc_client\">Vert.x gRPC Client</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_vert_x_grpc_client\">Using Vert.x gRPC Client</a></li>\n<li><a href=\"#_grpc_requestresponse_client_api\">gRPC request/response client API</a></li>\n<li><a href=\"#_flow_control_2\">Flow control</a></li>\n<li><a href=\"#_cancellation\">Cancellation</a></li>\n<li><a href=\"#_compression_2\">Compression</a></li>\n<li><a href=\"#_decompression_2\">Decompression</a></li>\n<li><a href=\"#_stub_api_2\">Stub API</a></li>\n<li><a href=\"#_message_level_api_2\">Message level API</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x gRPC</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The best description of gRPC can be seen at wikipedia.</p>\n</div>\n<div class=\"quoteblock\">\n<blockquote>\n<div class=\"paragraph\">\n<p>gRPC is an open source remote procedure call (RPC) system initially developed at Google. It uses HTTP/2 for\ntransport, Protocol Buffers as the interface description language, and provides features such as authentication,\nbidirectional streaming and flow control, blocking or nonblocking bindings, and cancellation and timeouts. It\ngenerates cross-platform client and server bindings for many languages.</p>\n</div>\n</blockquote>\n<div class=\"attribution\">\n&#8212; wikipedia<br>\n<cite>wikipedia</cite>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x gRPC is a module that will align the programming style of Google gRPC with Vert.x style. As a user of this\nmodule you will be more familiar with the code style using Vert.x Streams and Futures while benefiting from all the\nbenefits of gRPC.</p>\n</div>\n<div class=\"paragraph\">\n<p>For more information related to gRPC please consult the official documentation site <a href=\"http://www.grpc.io/\" class=\"bare\">http://www.grpc.io/</a>.</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nSince Vert.x 4.3, this module is the new support for gRPC in the Vert.x stack, the previous implementation based\non gRPC Netty is still available and has been renamed Vert.x gRPC Netty, it can be found at <a href=\"https://vertx.io/docs/vertx-grpc-netty/java/\" class=\"bare\">https://vertx.io/docs/vertx-grpc-netty/java/</a> .\nThis module has <em>Tech Preview</em> status, this means the API can change between versions.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x gRPC is split in two parts</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Vert.x gRPC Server</p>\n</li>\n<li>\n<p>Vert.x gRPC Client</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_vert_x_grpc_server\"><a class=\"anchor\" href=\"#_vert_x_grpc_server\"></a>Vert.x gRPC Server</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x gRPC Server is a new gRPC server powered by Vert.x HTTP server superseding the integrated Netty based gRPC client.</p>\n</div>\n<div class=\"paragraph\">\n<p>This server provides a gRPC request/response client API as well as a the generated stub approach with a service bridge.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_vert_x_grpc_server\"><a class=\"anchor\" href=\"#_using_vert_x_grpc_server\"></a>Using Vert.x gRPC Server</h3>\n<div class=\"paragraph\">\n<p>To use Vert.x gRPC Server, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-grpc-server<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.3.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-grpc-server:4.3.0&#x27;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_grpc_requestresponse_server_api\"><a class=\"anchor\" href=\"#_grpc_requestresponse_server_api\"></a>gRPC request/response server API</h3>\n<div class=\"paragraph\">\n<p>The gRPC request/response server API provides an alternative way to interact with a client without the need of a generated stub.</p>\n</div>\n<div class=\"paragraph\">\n<p>A <code><a href=\"../../apidocs/io/vertx/grpc/server/GrpcServer.html\">GrpcServer</a></code> is a <code>Handler&lt;HttpServerRequest&gt;</code> and can be used as an HTTP server request handler.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GrpcServer</span> <span class=\"hljs-variable\">grpcServer</span> <span class=\"hljs-operator\">=</span> GrpcServer.server(vertx);\n\n<span class=\"hljs-type\">HttpServer</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> vertx.createHttpServer(options);\n\nserver\n  .requestHandler(grpcServer)\n  .listen();</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\na <code>GrpcServer</code> can be mounted in a Vert.x Web router\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_requestresponse\"><a class=\"anchor\" href=\"#_requestresponse\"></a>Request/response</h4>\n<div class=\"paragraph\">\n<p>Each service method is processed by a handler</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.callHandler(GreeterGrpc.getSayHelloMethod(), request -&gt; {\n\n  request.handler(hello -&gt; {\n\n    GrpcServerResponse&lt;HelloRequest, HelloReply&gt; response = request.response();\n\n    <span class=\"hljs-type\">HelloReply</span> <span class=\"hljs-variable\">reply</span> <span class=\"hljs-operator\">=</span> HelloReply.newBuilder().setMessage(<span class=\"hljs-string\">&quot;Hello &quot;</span> + hello.getName()).build();\n\n    response.end(reply);\n  });\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming_request\"><a class=\"anchor\" href=\"#_streaming_request\"></a>Streaming request</h4>\n<div class=\"paragraph\">\n<p>You can set handlers to process request events</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.callHandler(StreamingGrpc.getSinkMethod(), request -&gt; {\n  request.handler(item -&gt; {\n    <span class=\"hljs-comment\">// Process item</span>\n  });\n  request.endHandler(v -&gt;{\n    <span class=\"hljs-comment\">// No more items</span>\n    <span class=\"hljs-comment\">// Send the response</span>\n    request.response().end(Empty.getDefaultInstance());\n  });\n  request.exceptionHandler(err -&gt; {\n    <span class=\"hljs-comment\">// Something wrong happened</span>\n  });\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming_response\"><a class=\"anchor\" href=\"#_streaming_response\"></a>Streaming response</h4>\n<div class=\"paragraph\">\n<p>A streaming response involves calling <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#write-java.lang.Object-\">write</a></code> for each element of the stream\nand using <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#end--\">end</a></code> to end the stream</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.callHandler(StreamingGrpc.getSourceMethod(), request -&gt; {\n  GrpcServerResponse&lt;Empty, Item&gt; response = request.response();\n  request.handler(empty -&gt; {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">10</span>;i++) {\n      response.write(Item.newBuilder().setValue(<span class=\"hljs-string\">&quot;1&quot;</span>).build());\n    }\n    response.end();\n  });\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_bidi_requestresponse\"><a class=\"anchor\" href=\"#_bidi_requestresponse\"></a>Bidi request/response</h4>\n<div class=\"paragraph\">\n<p>A bidi request/response is simply the combination of a streaming request and a streaming response</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.callHandler(StreamingGrpc.getPipeMethod(), request -&gt; {\n\n  request.handler(item -&gt; request.response().write(item));\n  request.endHandler(v -&gt; request.response().end());\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_flow_control\"><a class=\"anchor\" href=\"#_flow_control\"></a>Flow control</h3>\n<div class=\"paragraph\">\n<p>Request and response are back pressured Vert.x streams.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can pause/resume/fetch a request</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.pause();\n\nperformAsyncOperation().onComplete(ar -&gt; {\n  <span class=\"hljs-comment\">// And then resume</span>\n  request.resume();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can check the writability of a response and set a drain handler</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">if</span> (response.writeQueueFull()) {\n  response.drainHandler(v -&gt; {\n    <span class=\"hljs-comment\">// Writable again</span>\n  });\n} <span class=\"hljs-keyword\">else</span> {\n  response.write(item);\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_compression\"><a class=\"anchor\" href=\"#_compression\"></a>Compression</h3>\n<div class=\"paragraph\">\n<p>You can compress response messages by setting the response encoding <strong>prior</strong> before sending any message</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.encoding(<span class=\"hljs-string\">&quot;gzip&quot;</span>);\n\n<span class=\"hljs-comment\">// Write items after encoding has been defined</span>\nresponse.write(Item.newBuilder().setValue(<span class=\"hljs-string\">&quot;item-1&quot;</span>).build());\nresponse.write(Item.newBuilder().setValue(<span class=\"hljs-string\">&quot;item-2&quot;</span>).build());\nresponse.write(Item.newBuilder().setValue(<span class=\"hljs-string\">&quot;item-3&quot;</span>).build());</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_decompression\"><a class=\"anchor\" href=\"#_decompression\"></a>Decompression</h3>\n<div class=\"paragraph\">\n<p>Decompression is done transparently by the server when the client send encoded requests.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_stub_api\"><a class=\"anchor\" href=\"#_stub_api\"></a>Stub API</h3>\n<div class=\"paragraph\">\n<p>The Vert.x gRPC Server can bridge a gRPC service to use with a generated server stub in a more traditional fashion</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GrpcServer</span> <span class=\"hljs-variable\">grpcServer</span> <span class=\"hljs-operator\">=</span> GrpcServer.server(vertx);\n\nGreeterGrpc.<span class=\"hljs-type\">GreeterImplBase</span> <span class=\"hljs-variable\">service</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">GreeterGrpc</span>.GreeterImplBase() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sayHello</span><span class=\"hljs-params\">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> {\n    responseObserver.onNext(HelloReply.newBuilder().setMessage(<span class=\"hljs-string\">&quot;Hello &quot;</span> + request.getName()).build());\n    responseObserver.onCompleted();\n  }\n};\n\n<span class=\"hljs-comment\">// Bind the service bridge in the gRPC server</span>\n<span class=\"hljs-type\">GrpcServiceBridge</span> <span class=\"hljs-variable\">serverStub</span> <span class=\"hljs-operator\">=</span> GrpcServiceBridge.bridge(service);\nserverStub.bind(grpcServer);\n\n<span class=\"hljs-comment\">// Start the HTTP/2 server</span>\nvertx.createHttpServer(options)\n  .requestHandler(grpcServer)\n  .listen();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_message_level_api\"><a class=\"anchor\" href=\"#_message_level_api\"></a>Message level API</h3>\n<div class=\"paragraph\">\n<p>The server provides a message level API to interact directly with protobuf encoded gRPC messages.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nthe server message level API can be used with the client message level API to write a gRPC reverse proxy\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Such API is useful when you are not interested in the content of the messages, and instead you want to forward them to\nanother service, e.g. you are writing a proxy.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">ServiceName</span> <span class=\"hljs-variable\">greeterServiceName</span> <span class=\"hljs-operator\">=</span> ServiceName.create(<span class=\"hljs-string\">&quot;helloworld&quot;</span>, <span class=\"hljs-string\">&quot;Greeter&quot;</span>);\n\nserver.callHandler(request -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (request.serviceName().equals(greeterServiceName) &amp;&amp; request.methodName().equals(<span class=\"hljs-string\">&quot;SayHello&quot;</span>)) {\n\n    request.handler(protoHello -&gt; {\n      <span class=\"hljs-comment\">// Handle protobuf encoded hello</span>\n      performAsyncOperation(protoHello)\n        .onSuccess(protoReply -&gt; {\n          <span class=\"hljs-comment\">// Reply with protobuf encoded reply</span>\n          request.response().end(protoReply);\n        }).onFailure(err -&gt; {\n          request.response()\n            .status(GrpcStatus.ABORTED)\n            .end();\n        });\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    request.response()\n      .status(GrpcStatus.NOT_FOUND)\n      .end();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also set a <code>messageHandler</code> to handle <code><a href=\"../../apidocs/io/vertx/grpc/common/GrpcMessage.html\">GrpcMessage</a></code>, such messages preserve the\nclient encoding, which is useful the service you are forwarding to can handle compressed messages directly, in this case\nthe message does not need to be decompressed and compressed again.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">ServiceName</span> <span class=\"hljs-variable\">greeterServiceName</span> <span class=\"hljs-operator\">=</span> ServiceName.create(<span class=\"hljs-string\">&quot;helloworld&quot;</span>, <span class=\"hljs-string\">&quot;Greeter&quot;</span>);\n\nserver.callHandler(request -&gt; {\n\n  <span class=\"hljs-keyword\">if</span> (request.serviceName().equals(greeterServiceName) &amp;&amp; request.methodName().equals(<span class=\"hljs-string\">&quot;SayHello&quot;</span>)) {\n\n    request.messageHandler(helloMessage -&gt; {\n\n      <span class=\"hljs-comment\">// Can be identity or gzip</span>\n      <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">helloEncoding</span> <span class=\"hljs-operator\">=</span> helloMessage.encoding();\n\n      <span class=\"hljs-comment\">// Handle hello message</span>\n      handleGrpcMessage(helloMessage)\n        .onSuccess(replyMessage -&gt; {\n          <span class=\"hljs-comment\">// Reply with reply message</span>\n\n          <span class=\"hljs-comment\">// Can be identity or gzip</span>\n          <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">replyEncoding</span> <span class=\"hljs-operator\">=</span> replyMessage.encoding();\n\n          <span class=\"hljs-comment\">// Send the reply</span>\n          request.response().endMessage(replyMessage);\n        }).onFailure(err -&gt; {\n          request.response()\n            .status(GrpcStatus.ABORTED)\n            .end();\n        });\n    });\n  } <span class=\"hljs-keyword\">else</span> {\n    request.response()\n      .status(GrpcStatus.NOT_FOUND)\n      .end();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/grpc/common/GrpcWriteStream.html#writeMessage-io.vertx.grpc.common.GrpcMessage-\">writeMessage</a></code> and <code><a href=\"../../apidocs/io/vertx/grpc/common/GrpcWriteStream.html#endMessage-io.vertx.grpc.common.GrpcMessage-\">endMessage</a></code> will\nhandle the message encoding:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>when the message uses the response encoding, the message is sent as is</p>\n</li>\n<li>\n<p>when the message uses a different encoding, it will be encoded, e.g. compressed or uncompressed</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_vert_x_grpc_client\"><a class=\"anchor\" href=\"#_vert_x_grpc_client\"></a>Vert.x gRPC Client</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x gRPC Client is a new gRPC client powered by Vert.x HTTP client superseding the integrated Netty based gRPC client.</p>\n</div>\n<div class=\"paragraph\">\n<p>This client provides a gRPC request/response client API as well as a the generated stub approach with a gRPC Channel</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_vert_x_grpc_client\"><a class=\"anchor\" href=\"#_using_vert_x_grpc_client\"></a>Using Vert.x gRPC Client</h3>\n<div class=\"paragraph\">\n<p>To use Vert.x gRPC Client, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-grpc-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.3.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">dependencies {\n compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-grpc-client:4.3.0&#x27;</span>\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_grpc_requestresponse_client_api\"><a class=\"anchor\" href=\"#_grpc_requestresponse_client_api\"></a>gRPC request/response client API</h3>\n<div class=\"paragraph\">\n<p>The gRPC request/response client API provides an alternative way to interact with a server without the need of a generated stub.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can easily create the gRPC client</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GrpcClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> GrpcClient.client(vertx);</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_requestresponse_2\"><a class=\"anchor\" href=\"#_requestresponse_2\"></a>Request/response</h4>\n<div class=\"paragraph\">\n<p>Any interaction with a gRPC server involves creating a request to the remote gRPC service</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">SocketAddress</span> <span class=\"hljs-variable\">server</span> <span class=\"hljs-operator\">=</span> SocketAddress.inetSocketAddress(<span class=\"hljs-number\">443</span>, <span class=\"hljs-string\">&quot;example.com&quot;</span>);\nMethodDescriptor&lt;HelloRequest, HelloReply&gt; sayHelloMethod = GreeterGrpc.getSayHelloMethod();\nFuture&lt;GrpcClientRequest&lt;HelloRequest, HelloReply&gt;&gt; fut = client.request(server, sayHelloMethod);\nfut.onSuccess(request -&gt; {\n  <span class=\"hljs-comment\">// The end method calls the service</span>\n  request.end(HelloRequest.newBuilder().setName(<span class=\"hljs-string\">&quot;Bob&quot;</span>).build());\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/grpc/client/GrpcClientRequest.html#response--\">response</a></code> holds the response and the\n<code><a href=\"../../apidocs/io/vertx/grpc/common/GrpcReadStream.html#last--\">last</a></code> holds the result</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.response().onSuccess(response -&gt; {\n  Future&lt;HelloReply&gt; fut = response.last();\n  fut.onSuccess(reply -&gt; {\n    System.out.println(<span class=\"hljs-string\">&quot;Received &quot;</span> + reply.getMessage());\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Future composition can combine all the previous steps together in a compact fashion</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .request(server, GreeterGrpc.getSayHelloMethod()).compose(request -&gt; {\n    request.end(HelloRequest\n      .newBuilder()\n      .setName(<span class=\"hljs-string\">&quot;Bob&quot;</span>)\n      .build());\n    <span class=\"hljs-keyword\">return</span> request.response().compose(response -&gt; response.last());\n  }).onSuccess(reply -&gt; {\n    System.out.println(<span class=\"hljs-string\">&quot;Received &quot;</span> + reply.getMessage());\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming_request_2\"><a class=\"anchor\" href=\"#_streaming_request_2\"></a>Streaming request</h4>\n<div class=\"paragraph\">\n<p>A streaming request involves calling <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#write-java.lang.Object-\">write</a></code> for each element of the stream\nand using <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html#end--\">end</a></code> to end the stream</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .request(server, StreamingGrpc.getSinkMethod())\n  .onSuccess(request -&gt; {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">10</span>;i++) {\n    request.write(Item.newBuilder().setValue(<span class=\"hljs-string\">&quot;1&quot;</span>).build());\n  }\n  request.end();\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming_response_2\"><a class=\"anchor\" href=\"#_streaming_response_2\"></a>Streaming response</h4>\n<div class=\"paragraph\">\n<p>You can set handlers to process response events</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .request(server, StreamingGrpc.getSourceMethod())\n  .compose(request -&gt; {\n    request.end(Empty.getDefaultInstance());\n    <span class=\"hljs-keyword\">return</span> request.response();\n  })\n  .onSuccess(response -&gt; {\n    response.handler(item -&gt; {\n      <span class=\"hljs-comment\">// Process item</span>\n    });\n    response.endHandler(v -&gt; {\n      <span class=\"hljs-comment\">// Done</span>\n    });\n    response.exceptionHandler(err -&gt; {\n      <span class=\"hljs-comment\">// Something went bad</span>\n    });\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_bidi_requestresponse_2\"><a class=\"anchor\" href=\"#_bidi_requestresponse_2\"></a>Bidi request/response</h4>\n<div class=\"paragraph\">\n<p>A bidi request/response is simply the combination of a streaming request and a streaming response.</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_flow_control_2\"><a class=\"anchor\" href=\"#_flow_control_2\"></a>Flow control</h3>\n<div class=\"paragraph\">\n<p>Request and response are back pressured Vert.x streams.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can check the writability of a request and set a drain handler</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">if</span> (request.writeQueueFull()) {\n  request.drainHandler(v -&gt; {\n    <span class=\"hljs-comment\">// Writable again</span>\n  });\n} <span class=\"hljs-keyword\">else</span> {\n  request.write(item);\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can pause/resume/fetch a response</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.pause();\n\nperformAsyncOperation().onComplete(ar -&gt; {\n  <span class=\"hljs-comment\">// And then resume</span>\n  response.resume();\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_cancellation\"><a class=\"anchor\" href=\"#_cancellation\"></a>Cancellation</h3>\n<div class=\"paragraph\">\n<p>You can call <code><a href=\"../../apidocs/io/vertx/grpc/common/GrpcWriteStream.html#cancel--\">cancel</a></code> to cancel a request</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">client\n  .request(server, StreamingGrpc.getSourceMethod())\n  .compose(request -&gt; {\n    request.end(Empty.getDefaultInstance());\n    <span class=\"hljs-keyword\">return</span> request.response();\n  })\n  .onSuccess(response -&gt; {\n    response.handler(item -&gt; {\n      <span class=\"hljs-comment\">// Process item</span>\n    });\n    response.endHandler(v -&gt; {\n      <span class=\"hljs-comment\">// Done</span>\n    });\n    response.exceptionHandler(err -&gt; {\n      <span class=\"hljs-comment\">// Something went bad</span>\n    });\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\ncancellation sends an HTTP/2 reset frame to the server\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_compression_2\"><a class=\"anchor\" href=\"#_compression_2\"></a>Compression</h3>\n<div class=\"paragraph\">\n<p>You can compress request messages by setting the request encoding <strong>prior</strong> before sending any message</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">request.encoding(<span class=\"hljs-string\">&quot;gzip&quot;</span>);\n\n<span class=\"hljs-comment\">// Write items after encoding has been defined</span>\nrequest.write(Item.newBuilder().setValue(<span class=\"hljs-string\">&quot;item-1&quot;</span>).build());\nrequest.write(Item.newBuilder().setValue(<span class=\"hljs-string\">&quot;item-2&quot;</span>).build());\nrequest.write(Item.newBuilder().setValue(<span class=\"hljs-string\">&quot;item-3&quot;</span>).build());</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_decompression_2\"><a class=\"anchor\" href=\"#_decompression_2\"></a>Decompression</h3>\n<div class=\"paragraph\">\n<p>Decompression is done transparently by the client when the server send encoded responses.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_stub_api_2\"><a class=\"anchor\" href=\"#_stub_api_2\"></a>Stub API</h3>\n<div class=\"paragraph\">\n<p>The Vert.x gRPC Client provides a gRPC channel to use with a generated client stub in a more traditional fashion</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">GrpcClientChannel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">GrpcClientChannel</span>(client, SocketAddress.inetSocketAddress(<span class=\"hljs-number\">443</span>, <span class=\"hljs-string\">&quot;example.com&quot;</span>));\n\nGreeterGrpc.<span class=\"hljs-type\">GreeterStub</span> <span class=\"hljs-variable\">greeter</span> <span class=\"hljs-operator\">=</span> GreeterGrpc.newStub(channel);\n\ngreeter.sayHello(HelloRequest.newBuilder().setName(<span class=\"hljs-string\">&quot;Bob&quot;</span>).build(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StreamObserver</span>&lt;HelloReply&gt;() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onNext</span><span class=\"hljs-params\">(HelloReply value)</span> {\n    <span class=\"hljs-comment\">// Process response</span>\n  }\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onCompleted</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-comment\">// Done</span>\n  }\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onError</span><span class=\"hljs-params\">(Throwable t)</span> {\n    <span class=\"hljs-comment\">// Something went bad</span>\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_message_level_api_2\"><a class=\"anchor\" href=\"#_message_level_api_2\"></a>Message level API</h3>\n<div class=\"paragraph\">\n<p>The client provides a message level API to interact directly with protobuf encoded gRPC messages.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nthe client message level API can be used with the server message level API to write a gRPC reverse proxy\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Such API is useful when you are not interested in the content of the messages, and instead you want to forward them to\nanother service, e.g. you are writing a proxy.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;GrpcClientRequest&lt;Buffer, Buffer&gt;&gt; requestFut = client.request(server);\n\nrequestFut.onSuccess(request -&gt; {\n\n  <span class=\"hljs-comment\">// Set the service name and the method to call</span>\n  request.serviceName(ServiceName.create(<span class=\"hljs-string\">&quot;helloworld&quot;</span>, <span class=\"hljs-string\">&quot;Greeter&quot;</span>));\n  request.methodName(<span class=\"hljs-string\">&quot;SayHello&quot;</span>);\n\n  <span class=\"hljs-comment\">// Send the protobuf request</span>\n  request.end(protoHello);\n\n  <span class=\"hljs-comment\">// Handle the response</span>\n  Future&lt;GrpcClientResponse&lt;Buffer, Buffer&gt;&gt; responseFut = request.response();\n  responseFut.onSuccess(response -&gt; {\n    response.handler(protoReply -&gt; {\n      <span class=\"hljs-comment\">// Handle the protobuf reply</span>\n    });\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also set a <code>messageHandler</code> to handle <code><a href=\"../../apidocs/io/vertx/grpc/common/GrpcMessage.html\">GrpcMessage</a></code>, such messages preserve the server encoding.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Future&lt;GrpcClientRequest&lt;Buffer, Buffer&gt;&gt; requestFut = client.request(server);\n\nrequestFut.onSuccess(request -&gt; {\n\n  <span class=\"hljs-comment\">// Set the service name and the method to call</span>\n  request.serviceName(ServiceName.create(<span class=\"hljs-string\">&quot;helloworld&quot;</span>, <span class=\"hljs-string\">&quot;Greeter&quot;</span>));\n  request.methodName(<span class=\"hljs-string\">&quot;SayHello&quot;</span>);\n\n  <span class=\"hljs-comment\">// Send the protobuf request</span>\n  request.endMessage(GrpcMessage.message(<span class=\"hljs-string\">&quot;identity&quot;</span>, protoHello));\n\n  <span class=\"hljs-comment\">// Handle the response</span>\n  Future&lt;GrpcClientResponse&lt;Buffer, Buffer&gt;&gt; responseFut = request.response();\n  responseFut.onSuccess(response -&gt; {\n    response.messageHandler(replyMessage -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;Got reply message encoded as &quot;</span> + replyMessage.encoding());\n    });\n  });\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/grpc/common/GrpcWriteStream.html#writeMessage-io.vertx.grpc.common.GrpcMessage-\">writeMessage</a></code> and <code><a href=\"../../apidocs/io/vertx/grpc/common/GrpcWriteStream.html#endMessage-io.vertx.grpc.common.GrpcMessage-\">endMessage</a></code> will\nhandle the message encoding:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>when the message uses the response encoding, the message is sent as is</p>\n</li>\n<li>\n<p>when the message uses a different encoding, it will be encoded, e.g. compressed or uncompressed</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>","version":"4.3.0"},"__N_SSG":true}