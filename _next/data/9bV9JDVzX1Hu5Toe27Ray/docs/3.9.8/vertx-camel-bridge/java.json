{"pageProps":{"slug":"3.9.8/vertx-camel-bridge/java","title":"Vert.x Camel Bridge","fallbackGitHubStars":13,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vertx_camel_bridge\">Using vertx-camel-bridge</a></li>\n<li><a href=\"#_bridge_configuration\">Bridge configuration</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_inbound_mapping\">Inbound mapping</a></li>\n<li><a href=\"#_outbound_mapping\">Outbound mapping</a></li>\n</ul>\n</li>\n<li><a href=\"#_stopping_the_bridge\">Stopping the bridge</a></li>\n<li><a href=\"#_exchanging_custom_object\">Exchanging custom object</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Camel Bridge</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Apache Camel (<a href=\"http://camel.apache.org\" class=\"bare\">http://camel.apache.org</a>) is an open source Java framework that focuses on making integration easier\nand more accessible to developers. This bridge lets Vert.x applications interact with Camel endpoints:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>the application can send messages to Camel.</p>\n</li>\n<li>\n<p>the application can receive message from Camel.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The bridge relies on the Vert.x event bus and associate an event bus address to a Camel endpoint.</p>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Caution</div>\n</td>\n<td class=\"content\">\nThis component is not <em>polyglot</em> as it requires some classes from Camel that can only be used in Java.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vertx_camel_bridge\"><a class=\"anchor\" href=\"#_using_vertx_camel_bridge\"></a>Using vertx-camel-bridge</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use the Vert.x Camel Bridge, add the following dependency to the <em>dependencies</em> section of your\nbuild descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-camel-bridge<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.8<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-camel-bridge:3.9.8&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_bridge_configuration\"><a class=\"anchor\" href=\"#_bridge_configuration\"></a>Bridge configuration</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Before being used, the bridge needs to be configured and started:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CamelContext</span> <span class=\"hljs-variable\">camel</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultCamelContext</span>();\nCamelBridge.create(vertx,\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CamelBridgeOptions</span>(camel)\n        .addInboundMapping(InboundMapping.fromCamel(<span class=\"hljs-string\">&quot;direct:stuff&quot;</span>).toVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>))\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>).toCamel(<span class=\"hljs-string\">&quot;stream:out&quot;</span>))\n).start();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The bridge requires a <code>CamelContext</code>. It will find the endpoint from the context. The bridge needs to be started\nbefore being used. Be aware the the <code>start</code> method is asynchronous. You can use\n<code><a href=\"../../apidocs/io/vertx/camel/CamelBridge.html#start-io.vertx.core.Handler-\">start</a></code> to be notified when the bridge has been started.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_inbound_mapping\"><a class=\"anchor\" href=\"#_inbound_mapping\"></a>Inbound mapping</h3>\n<div class=\"paragraph\">\n<p>Inbound mapping associates a Camel endpoint to an event bus address. Messages received on this endpoint are\ntransformed to event bus messages.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Endpoint</span> <span class=\"hljs-variable\">endpoint</span> <span class=\"hljs-operator\">=</span> camel.getEndpoint(<span class=\"hljs-string\">&quot;direct:foo&quot;</span>);\n\nCamelBridge.create(vertx,\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CamelBridgeOptions</span>(camel)\n        .addInboundMapping(InboundMapping.fromCamel(<span class=\"hljs-string\">&quot;direct:stuff&quot;</span>).toVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>))\n        .addInboundMapping(InboundMapping.fromCamel(endpoint).toVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>))\n        .addInboundMapping(InboundMapping.fromCamel(endpoint).toVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>)\n            .withoutHeadersCopy())\n        .addInboundMapping(InboundMapping.fromCamel(endpoint).toVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>)\n            .usePublish())\n        .addInboundMapping(InboundMapping.fromCamel(endpoint).toVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>)\n            .withBodyType(String.class))\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The snippet above shows different ways to configure an inbound mapping:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>you can configure the Camel endpoint either using the <code>Endpoint</code> object or its uri</p>\n</li>\n<li>\n<p>you can disables the header copy (Camel message headers are copied to the event bus message)</p>\n</li>\n<li>\n<p>you can uses <code>publish</code> instead of <code>send</code> to broadcast the message to all event bus consumers</p>\n</li>\n<li>\n<p>you can configures the type of the event bus message body. If not set it uses the Camel message payload. If\nsets, it looks in the Camel context for a converter between the Camel message payload and the desired type.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p><em>Note</em>: <code>org.fusesource.hawtbuf.Buffer</code> are automatically converted to <code><a href=\"../../apidocs/io/vertx/core/buffer/Buffer.html\">Buffer</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>If <code>send</code> is used (so not <code>publish</code>), and when the Camel exchange expect a reply (<em>In Out</em> exchange), the Vert.x\ncode expect as reply to the sent message. When the reply arrives it is propagated to the exchange:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Endpoint</span> <span class=\"hljs-variable\">endpoint</span> <span class=\"hljs-operator\">=</span> camel.getEndpoint(<span class=\"hljs-string\">&quot;direct:stuff&quot;</span>);\n\n<span class=\"hljs-type\">CamelBridge</span> <span class=\"hljs-variable\">bridge</span> <span class=\"hljs-operator\">=</span> CamelBridge.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CamelBridgeOptions</span>(camel)\n    .addInboundMapping(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InboundMapping</span>().setAddress(<span class=\"hljs-string\">&quot;test-reply&quot;</span>).setEndpoint(endpoint)));\n\nvertx.eventBus().consumer(<span class=\"hljs-string\">&quot;with-reply&quot;</span>, message -&gt; {\n  message.reply(<span class=\"hljs-string\">&quot;How are you ?&quot;</span>);\n});\n\ncamel.start();\nbridge.start();\n\n<span class=\"hljs-type\">ProducerTemplate</span> <span class=\"hljs-variable\">template</span> <span class=\"hljs-operator\">=</span> camel.createProducerTemplate();\nFuture&lt;Object&gt; future = template.asyncRequestBody(endpoint, <span class=\"hljs-string\">&quot;hello&quot;</span>);\n<span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> template.extractFutureBody(future, String.class);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also configure the reply <code>timeout</code> using <code><a href=\"../../apidocs/io/vertx/camel/InboundMapping.html#setTimeout-int-\">setTimeout</a></code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_outbound_mapping\"><a class=\"anchor\" href=\"#_outbound_mapping\"></a>Outbound mapping</h3>\n<div class=\"paragraph\">\n<p>Outbound mapping associates an event bus address to a Camel endpoint. Messages received on this event bus address\nare transformed to Camel messages and sent to the endpoint.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Endpoint</span> <span class=\"hljs-variable\">endpoint</span> <span class=\"hljs-operator\">=</span> camel.getEndpoint(<span class=\"hljs-string\">&quot;stream:out&quot;</span>);\n\nCamelBridge.create(vertx,\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CamelBridgeOptions</span>(camel)\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>).toCamel(<span class=\"hljs-string\">&quot;stream:out&quot;</span>))\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>).toCamel(endpoint))\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>).toCamel(endpoint)\n            .withoutHeadersCopy())\n        .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">&quot;eventbus-address&quot;</span>).toCamel(endpoint))\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The snippet above shows different ways to configure an outbound mapping.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can connect your outbound mapping to a Camel route:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">camel.addRoutes(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RouteBuilder</span>() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">configure</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n    from(<span class=\"hljs-string\">&quot;direct:start&quot;</span>)\n        .transform(constant(<span class=\"hljs-string\">&quot;OK&quot;</span>));\n  }\n});\n\n<span class=\"hljs-type\">CamelBridge</span> <span class=\"hljs-variable\">bridge</span> <span class=\"hljs-operator\">=</span> CamelBridge.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CamelBridgeOptions</span>(camel)\n    .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">&quot;test&quot;</span>).toCamel(<span class=\"hljs-string\">&quot;direct:start&quot;</span>)));\n\ncamel.start();\nbridge.start();\n\n\nvertx.eventBus().send(<span class=\"hljs-string\">&quot;test&quot;</span>, <span class=\"hljs-string\">&quot;hello&quot;</span>, reply -&gt; {\n  <span class=\"hljs-comment\">// Reply from the route (here it&#x27;s &quot;OK&quot;)</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If when you send the message on the event bus you register a reply handler, it configures the Camel exchange to\nexpect a response (it uses the request-reply pattern of the EIP). The response is passed in the reply body. If the\nroute fails, you get a reply failure (recipient failure), with the message as cause:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">camel.addRoutes(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RouteBuilder</span>() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">configure</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n    from(<span class=\"hljs-string\">&quot;direct:my-route&quot;</span>)\n        .to(<span class=\"hljs-string\">&quot;http://localhost:8080&quot;</span>);\n  }\n});\n\n<span class=\"hljs-type\">CamelBridge</span> <span class=\"hljs-variable\">bridge</span> <span class=\"hljs-operator\">=</span> CamelBridge.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CamelBridgeOptions</span>(camel)\n    .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">&quot;camel-route&quot;</span>).toCamel(<span class=\"hljs-string\">&quot;direct:my-route&quot;</span>)));\n\ncamel.start();\nbridge.start();\n\nvertx.eventBus().send(<span class=\"hljs-string\">&quot;camel-route&quot;</span>, <span class=\"hljs-string\">&quot;hello&quot;</span>, reply -&gt; {\n  <span class=\"hljs-keyword\">if</span> (reply.succeeded()) {\n    <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">theResponse</span> <span class=\"hljs-operator\">=</span> reply.result().body();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-type\">Throwable</span> <span class=\"hljs-variable\">theCause</span> <span class=\"hljs-operator\">=</span> reply.cause();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If the processing you apply is blocking, you*must** set <em>blocking</em> to <code>true</code>. This avoid executing the\nprocessing on the event loop thread:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">camel.addRoutes(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RouteBuilder</span>() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">configure</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception {\n    from(<span class=\"hljs-string\">&quot;direct:my-route&quot;</span>)\n      .process(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Processor</span>() {\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">process</span><span class=\"hljs-params\">(Exchange exchange)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n          <span class=\"hljs-comment\">// Do something blocking...</span>\n        }\n      })\n      .to(<span class=\"hljs-string\">&quot;http://localhost:8080&quot;</span>);\n  }\n});\n\n<span class=\"hljs-type\">CamelBridge</span> <span class=\"hljs-variable\">bridge</span> <span class=\"hljs-operator\">=</span> CamelBridge.create(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CamelBridgeOptions</span>(camel)\n  .addOutboundMapping(OutboundMapping.fromVertx(<span class=\"hljs-string\">&quot;camel-route&quot;</span>).toCamel(<span class=\"hljs-string\">&quot;direct:my-route&quot;</span>).setBlocking(<span class=\"hljs-literal\">true</span>)));\n\ncamel.start();\nbridge.start();\n\nvertx.eventBus().send(<span class=\"hljs-string\">&quot;camel-route&quot;</span>, <span class=\"hljs-string\">&quot;hello&quot;</span>, reply -&gt; {\n  <span class=\"hljs-keyword\">if</span> (reply.succeeded()) {\n    <span class=\"hljs-type\">Object</span> <span class=\"hljs-variable\">theResponse</span> <span class=\"hljs-operator\">=</span> reply.result().body();\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-type\">Throwable</span> <span class=\"hljs-variable\">theCause</span> <span class=\"hljs-operator\">=</span> reply.cause();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>By default it uses the default worker thread pool, this is customizable using the\n<code><a href=\"../../apidocs/io/vertx/camel/OutboundMapping.html#setWorkerExecutor-io.vertx.core.WorkerExecutor-\">setWorkerExecutor</a></code> method.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_stopping_the_bridge\"><a class=\"anchor\" href=\"#_stopping_the_bridge\"></a>Stopping the bridge</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Don&#8217;t forget to stop the bridge using the <code>stop</code> method. The <code>stop</code> method is asynchronous. You can use\n<code><a href=\"../../apidocs/io/vertx/camel/CamelBridge.html#stop-io.vertx.core.Handler-\">stop</a></code> to be notified when the bridge has been stopped.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_exchanging_custom_object\"><a class=\"anchor\" href=\"#_exchanging_custom_object\"></a>Exchanging custom object</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>If you want to send and receive custom objects, you need to register a codec on the event bus:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.eventBus().registerDefaultCodec(Person.class, codec);</code></pre>\n</div>\n</div>\n</div>\n</div>","version":"3.9.8"},"__N_SSG":true}