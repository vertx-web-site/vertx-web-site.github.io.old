{"pageProps":{"slug":"4.1.6/vertx-web-graphql/java","title":"Vert.x Web GraphQL","fallbackGitHubStars":925,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">Getting started</a></li>\n<li><a href=\"#_handlers_setup\">Handlers setup</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_http\">HTTP</a></li>\n<li><a href=\"#_graphiql_ide\">GraphiQL IDE</a></li>\n<li><a href=\"#_apollo_websocketlink\">Apollo WebSocketLink</a></li>\n</ul>\n</li>\n<li><a href=\"#_fetching_data\">Fetching data</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_working_with_callback_based_apis\">Working with callback-based APIs</a></li>\n<li><a href=\"#_working_with_vert_x_futures\">Working with Vert.x Futures</a></li>\n<li><a href=\"#_providing_data_fetchers_with_some_context\">Providing data fetchers with some context</a></li>\n<li><a href=\"#_json_data_results\">JSON data results</a></li>\n<li><a href=\"#_batch_loading\">Batch loading</a></li>\n<li><a href=\"#_file_uploads\">File uploads</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxjava_3_api\">RxJava 3 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_setting_up_with_an_rxified_router\">Setting up with an Rxified router</a></li>\n<li><a href=\"#_working_with_vert_x_rxified_apis\">Working with Vert.x Rxified APIs</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Web GraphQL</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL extends Vert.x Web with the <a href=\"https://www.graphql-java.com\">GraphQL-Java</a> library so that you can build a GraphQL server.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nThis is the reference documentation for Vert.x Web GraphQL.\nIt is highly recommended to get familiar with the GraphQL-Java API first.\nYou may start by reading the <a href=\"https://www.graphql-java.com/documentation/v16/\">GraphQL-Java documentation</a>.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting started</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use this module, add the following to the <em>dependencies</em> section of your Maven POM file:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-graphql<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or, if you use Gradle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-web-graphql:4.1.6&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handlers_setup\"><a class=\"anchor\" href=\"#_handlers_setup\"></a>Handlers setup</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_http\"><a class=\"anchor\" href=\"#_http\"></a>HTTP</h3>\n<div class=\"paragraph\">\n<p>Create a Vert.x Web <code><a href=\"../../apidocs/io/vertx/ext/web/Route.html\">Route</a></code> and a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> for it:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQL graphQL = setupGraphQLJava();\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The handler serves both <code>GET</code> and <code>POST</code> requests.\nHowever, you can restrict the service to one type of HTTP method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQL graphQL = setupGraphQLJava();\n\nrouter.post(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nThe <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> requires a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> to read <code>POST</code> requests content.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_query_batching\"><a class=\"anchor\" href=\"#_query_batching\"></a>Query batching</h4>\n<div class=\"paragraph\">\n<p>Query batching consists in posting an array instead of a single object to the GraphQL endpoint.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL can handle such requests but by default the feature is disabled.\nTo enable it, create the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> with options:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQLHandlerOptions options = <span class=\"hljs-keyword\">new</span> GraphQLHandlerOptions()\n  .setRequestBatchingEnabled(<span class=\"hljs-keyword\">true</span>);\n\nGraphQLHandler handler = GraphQLHandler.create(graphQL, options);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_graphiql_ide\"><a class=\"anchor\" href=\"#_graphiql_ide\"></a>GraphiQL IDE</h3>\n<div class=\"paragraph\">\n<p>As you are building your application, testing your GraphQL queries in <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a> can be handy.</p>\n</div>\n<div class=\"paragraph\">\n<p>To do so, create a route for GraphiQL resources and a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandler.html\">GraphiQLHandler</a></code> for them:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphiQLHandlerOptions options = <span class=\"hljs-keyword\">new</span> GraphiQLHandlerOptions()\n  .setEnabled(<span class=\"hljs-keyword\">true</span>);\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphiql/*&quot;</span>).handler(GraphiQLHandler.create(options));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Then browse to <a href=\"http://localhost:8080/graphiql/\" class=\"bare\">http://localhost:8080/graphiql/</a>.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nThe GraphiQL user interface is disabled by default for security reasons.\nThis is why you must configure the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandlerOptions.html\">GraphiQLHandlerOptions</a></code> to enable it.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nGraphiQL is enabled automatically when Vert.x Web runs in development mode.\nTo switch the development mode on, use the <code>VERTXWEB_ENVIRONMENT</code> environment variable or <code>vertxweb.environment</code> system property and set it to <code>dev</code>.\nIn this case, create the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandler.html\">GraphiQLHandler</a></code> without changing the <code>enabled</code> property.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>If your application is protected by authentication, you can customize the headers sent by GraphiQL dynamically:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">graphiQLHandler.graphiQLRequestHeaders(rc -&gt; {\n  String token = rc.get(<span class=\"hljs-string\">&quot;token&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> MultiMap.caseInsensitiveMultiMap().add(<span class=\"hljs-string\">&quot;Authorization&quot;</span>, <span class=\"hljs-string\">&quot;Bearer &quot;</span> + token);\n});\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphiql/*&quot;</span>).handler(graphiQLHandler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Please refer to the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphiQLHandlerOptions.html\">GraphiQLHandlerOptions</a></code> documentation for further details.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_apollo_websocketlink\"><a class=\"anchor\" href=\"#_apollo_websocketlink\"></a>Apollo WebSocketLink</h3>\n<div class=\"paragraph\">\n<p>You can use an <a href=\"https://www.apollographql.com/docs/link/links/ws/\">Apollo WebSocketLink</a> which connects over a websocket.\nThis is specially useful if you want to add subscriptions to your GraphQL schema, but you can also use the websocket for queries and mutations.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQL graphQL = setupGraphQLJava();\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(ApolloWSHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nTo support the <code>graphql-ws</code> websocket subprotocol, it has to be added to the server configuration:\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpServerOptions httpServerOptions = <span class=\"hljs-keyword\">new</span> HttpServerOptions()\n  .addWebSocketSubProtocol(<span class=\"hljs-string\">&quot;graphql-ws&quot;</span>);\nvertx.createHttpServer(httpServerOptions)\n  .requestHandler(router)\n  .listen(<span class=\"hljs-number\">8080</span>);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nIf you want to support a WebSocketLink and a HttpLink in the same path, you can add the ApolloWSHandler in first place and then the GraphQLHandler.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQL graphQL = setupGraphQLJava();\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(ApolloWSHandler.create(graphQL));\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(GraphQLHandler.create(graphQL));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Here you can find how to configure the Apollo SubscriptionClient: <a href=\"https://github.com/apollographql/subscriptions-transport-ws\" class=\"bare\">https://github.com/apollographql/subscriptions-transport-ws</a></p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nA subscription <code>DataFetcher</code> has to return a <code>org.reactivestreams.Publisher</code> instance.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_fetching_data\"><a class=\"anchor\" href=\"#_fetching_data\"></a>Fetching data</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The GraphQL-Java API is very well suited for the asynchronous world: the asynchronous execution strategy is the default for queries (serial asynchronous for mutations).</p>\n</div>\n<div class=\"paragraph\">\n<p>To <a href=\"https://vertx.io/docs/vertx-core/java/#golden_rule\">avoid blocking the event loop</a>, all you have to do is implement <a href=\"https://www.graphql-java.com/documentation/v16/data-fetching/\">data fetchers</a> that return a <code>CompletionStage</code> instead of the result directly.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">DataFetcher&lt;CompletionStage&lt;List&lt;Link&gt;&gt;&gt; dataFetcher = environment -&gt; {\n\n  CompletableFuture&lt;List&lt;Link&gt;&gt; completableFuture = <span class=\"hljs-keyword\">new</span> CompletableFuture&lt;&gt;();\n\n  retrieveLinksFromBackend(environment, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n      completableFuture.complete(ar.result());\n    } <span class=\"hljs-keyword\">else</span> {\n      completableFuture.completeExceptionally(ar.cause());\n    }\n  });\n\n  <span class=\"hljs-keyword\">return</span> completableFuture;\n};\n\nRuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring()\n  .type(<span class=\"hljs-string\">&quot;Query&quot;</span>, builder -&gt; builder.dataFetcher(<span class=\"hljs-string\">&quot;allLinks&quot;</span>, dataFetcher))\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_callback_based_apis\"><a class=\"anchor\" href=\"#_working_with_callback_based_apis\"></a>Working with callback-based APIs</h3>\n<div class=\"paragraph\">\n<p>Implementing a data fetcher that returns a <code>CompletionStage</code> is not a complex task.\nBut when you work with Vert.x callback-based APIs, it requires a bit of boilerplate.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is where the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxDataFetcher.html\">VertxDataFetcher</a></code> can help:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create((env, promise) -&gt; {\n  retrieveLinksFromBackend(env, promise);\n});\n\nRuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring()\n  .type(<span class=\"hljs-string\">&quot;Query&quot;</span>, builder -&gt; builder.dataFetcher(<span class=\"hljs-string\">&quot;allLinks&quot;</span>, dataFetcher))\n  .build();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_vert_x_futures\"><a class=\"anchor\" href=\"#_working_with_vert_x_futures\"></a>Working with Vert.x Futures</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxDataFetcher.html\">VertxDataFetcher</a></code> can also help with futurized APIs:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create(environment -&gt; {\n  Future&lt;List&lt;Link&gt;&gt; future = retrieveLinksFromBackend(environment);\n  <span class=\"hljs-keyword\">return</span> future;\n});\n\nRuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring()\n  .type(<span class=\"hljs-string\">&quot;Query&quot;</span>, builder -&gt; builder.dataFetcher(<span class=\"hljs-string\">&quot;allLinks&quot;</span>, dataFetcher))\n  .build();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_providing_data_fetchers_with_some_context\"><a class=\"anchor\" href=\"#_providing_data_fetchers_with_some_context\"></a>Providing data fetchers with some context</h3>\n<div class=\"paragraph\">\n<p>Very often, the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> will be declared after other route handlers.\nFor example, you could protect your application with authentication.</p>\n</div>\n<div class=\"paragraph\">\n<p>In this case, it is likely that your data fetchers will need to know which user is logged-in to narrow down the results.\nLet&#8217;s say your authentication layer stores a <code>User</code> object in the <code><a href=\"../../apidocs/io/vertx/ext/web/RoutingContext.html\">RoutingContext</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You may retrieve this object by inspecting the <code>DataFetchingEnvironment</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create((environment, promise) -&gt; {\n\n  RoutingContext routingContext = environment.getContext();\n\n  User user = routingContext.get(<span class=\"hljs-string\">&quot;user&quot;</span>);\n\n  retrieveLinksPostedBy(user, promise);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nThe routing context is available with any kind of data fetchers, not just <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxDataFetcher.html\">VertxDataFetcher</a></code>.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>If you prefer not to expose the routing context to your data fetchers, configure the GraphQL handler to customize the context object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxDataFetcher&lt;List&lt;Link&gt;&gt; dataFetcher = VertxDataFetcher.create((environment, promise) -&gt; {\n\n  <span class=\"hljs-comment\">// User as custom context object</span>\n  User user = environment.getContext();\n\n  retrieveLinksPostedBy(user, promise);\n\n});\n\nGraphQL graphQL = setupGraphQLJava(dataFetcher);\n\n<span class=\"hljs-comment\">// Customize the query context object when setting up the handler</span>\nGraphQLHandler handler = GraphQLHandler.create(graphQL).queryContext(routingContext -&gt; {\n\n  <span class=\"hljs-keyword\">return</span> routingContext.get(<span class=\"hljs-string\">&quot;user&quot;</span>);\n\n});\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(handler);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_data_results\"><a class=\"anchor\" href=\"#_json_data_results\"></a>JSON data results</h3>\n<div class=\"paragraph\">\n<p>The default GraphQL data fetcher is <code>PropertyDataFetcher</code>.\nAs a consequence, it will be able to read the fields of your domain objects without further configuration.</p>\n</div>\n<div class=\"paragraph\">\n<p>Nevertheless, some Vert.x data clients return <code><a href=\"../../apidocs/io/vertx/core/json/JsonArray.html\">JsonArray</a></code> and <code><a href=\"../../apidocs/io/vertx/core/json/JsonObject.html\">JsonObject</a></code> results.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you don&#8217;t need (or don&#8217;t wish to) use a domain object layer, you can configure GraphQL-Java to use <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxPropertyDataFetcher.html\">VertxPropertyDataFetcher</a></code> instead:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RuntimeWiring.Builder builder = RuntimeWiring.newRuntimeWiring();\n\nbuilder.wiringFactory(<span class=\"hljs-keyword\">new</span> WiringFactory() {\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataFetcher&lt;Object&gt; <span class=\"hljs-title\">getDefaultDataFetcher</span><span class=\"hljs-params\">(FieldWiringEnvironment environment)</span> </span>{\n\n    <span class=\"hljs-keyword\">return</span> VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName());\n\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\n<code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/schema/VertxPropertyDataFetcher.html\">VertxPropertyDataFetcher</a></code> wraps a <code>PropertyDataFetcher</code> so you can still use it with domain objects.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batch_loading\"><a class=\"anchor\" href=\"#_batch_loading\"></a>Batch loading</h3>\n<div class=\"paragraph\">\n<p>Dataloaders help you to load data efficiently by batching fetch requests and caching results.</p>\n</div>\n<div class=\"paragraph\">\n<p>First, create a batch loader:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">BatchLoaderWithContext&lt;String, Link&gt; linksBatchLoader = (ids, env) -&gt; {\n  <span class=\"hljs-comment\">// retrieveLinksFromBackend takes a list of ids and returns a CompletionStage for a list of links</span>\n  <span class=\"hljs-keyword\">return</span> retrieveLinksFromBackend(ids, env);\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Then, configure the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> to create a <code>DataLoaderRegistry</code> for each request:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQLHandler handler = GraphQLHandler.create(graphQL).dataLoaderRegistry(rc -&gt; {\n\n  DataLoader&lt;String, Link&gt; linkDataLoader = DataLoader.newDataLoader(linksBatchLoader);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> DataLoaderRegistry().register(<span class=\"hljs-string\">&quot;link&quot;</span>, linkDataLoader);\n\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If you work with Vert.x APIs, you may use a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/dataloader/VertxBatchLoader.html\">VertxBatchLoader</a></code> or a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/dataloader/VertxMappedBatchLoader.html\">VertxMappedBatchLoader</a></code> to simplify your code:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">BatchLoaderWithContext&lt;Long, String&gt; commentsBatchLoader = VertxBatchLoader.create((ids, env) -&gt; {\n  <span class=\"hljs-comment\">// findComments takes a list of ids and returns a Future for a list of links</span>\n  <span class=\"hljs-keyword\">return</span> findComments(ids, env);\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_file_uploads\"><a class=\"anchor\" href=\"#_file_uploads\"></a>File uploads</h3>\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/jaydenseric/graphql-multipart-request-spec\">GraphQL multipart request</a> is an interoperable multipart form field structure for <code>GraphQL</code> requests.\nBy enabling this functionality, GraphQL clients will be able to upload files using a single mutation call.\nAll the server-side file handling will be abstracted by the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>To enable it, create a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> with the requestMultipartEnabled configuration set to true and add the <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code> to the router.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GraphQLHandler graphQLHandler = GraphQLHandler.create(\n  setupGraphQLJava(),\n  <span class=\"hljs-keyword\">new</span> GraphQLHandlerOptions().setRequestMultipartEnabled(<span class=\"hljs-keyword\">true</span>)\n);\n\nRouter router = Router.router(vertx);\n\nrouter.route().handler(BodyHandler.create());\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(graphQLHandler);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nIf the router does not have a <code><a href=\"../../apidocs/io/vertx/ext/web/handler/BodyHandler.html\">BodyHandler</a></code>, the multipart request parser will not be able to handle the GraphQL mutation call.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Finally, create the <code>Upload</code> scalar and set it to the <code>RuntimeWiring</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RuntimeWiring runtimeWiring = RuntimeWiring.newRuntimeWiring().scalar(UploadScalar.build()).build();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>FileUpload</code> instance can be accessed using the <code>DataFetchingEnvironment::getArgument</code> method.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileUpload file = environment.getArgument(<span class=\"hljs-string\">&quot;myFile&quot;</span>);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_3_api\"><a class=\"anchor\" href=\"#_rxjava_3_api\"></a>RxJava 3 API</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_setting_up_with_an_rxified_router\"><a class=\"anchor\" href=\"#_setting_up_with_an_rxified_router\"></a>Setting up with an Rxified router</h3>\n<div class=\"paragraph\">\n<p>To handle GraphQL requests on a Rxified <code><a href=\"../../apidocs/io/vertx/rxjava3/ext/web/Route.html\">Route</a></code>, make sure to import the <code><a href=\"../../apidocs/io/vertx/rxjava3/ext/web/handler/graphql/GraphQLHandler.html\">GraphQLHandler</a></code> class.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_working_with_vert_x_rxified_apis\"><a class=\"anchor\" href=\"#_working_with_vert_x_rxified_apis\"></a>Working with Vert.x Rxified APIs</h3>\n<div class=\"paragraph\">\n<p>GraphQL-Java expects <code>CompletionStage</code> for asynchronous results in data fetchers and batch loaders.</p>\n</div>\n<div class=\"paragraph\">\n<p>Therefore, if you work with the Vert.x Rxified APIs (e.g. the <a href=\"https://vertx.io/docs/vertx-web-client/java/#_rxjava_3_api\">Web Client</a> or the <a href=\"https://vertx.io/docs/vertx-cassandra-client/java/#_rxjava_3_api\">Cassandra Client</a>), you will have to adapt the <code>Single</code> and <code>Maybe</code> objects.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code>RxJavaJdk8Interop</code> library provides the tooling to do just that.\nAdd the following to the <em>dependencies</em> section of your Maven build file:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.github.akarnokd<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>rxjava3-jdk8-interop<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.0.0-RC6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or if you use Gradle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">implementation <span class=\"hljs-string\">&#x27;com.github.akarnokd:rxjava3-jdk8-interop:3.0.0-RC6&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Then you can create a data fetcher from a <code>Single</code> result:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;String&gt; data = loadDataFromBackend();\nDataFetcher&lt;CompletionStage&lt;String&gt;&gt; fetcher = environment -&gt; {\n <span class=\"hljs-keyword\">return</span> data.to(SingleInterop.get());\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For <code>Maybe</code> results, use <code>MaybeInterop</code>.</p>\n</div>\n</div>\n</div>\n</div>","version":"4.1.6"},"__N_SSG":true}