{"pageProps":{"slug":"3.9.13/vertx-junit5/java","title":"Vert.x JUnit 5 integration","fallbackGitHubStars":36,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_use_it_in_your_build\">Use it in your build</a></li>\n<li><a href=\"#_why_testing_asynchronous_code_is_different\">Why testing asynchronous code is different</a></li>\n<li><a href=\"#_a_test_context_for_asynchronous_executions\">A test context for asynchronous executions</a></li>\n<li><a href=\"#_use_any_assertion_library\">Use any assertion library</a></li>\n<li><a href=\"#_checkpoint_when_there_are_multiple_success_conditions\">Checkpoint when there are multiple success conditions</a></li>\n<li><a href=\"#_integration_with_junit_5\">Integration with JUnit 5</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_test_methods\">Test methods</a></li>\n<li><a href=\"#_lifecycle_methods\">Lifecycle methods</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x JUnit 5 integration</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This module offers integration and support for writing Vert.x tests with JUnit 5.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_use_it_in_your_build\"><a class=\"anchor\" href=\"#_use_it_in_your_build\"></a>Use it in your build</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>groupId</code>: <code>io.vertx</code></p>\n</li>\n<li>\n<p><code>artifactId</code>: <code>vertx-junit5</code></p>\n</li>\n<li>\n<p><code>version</code>: (current Vert.x release or SNAPSHOT)</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_why_testing_asynchronous_code_is_different\"><a class=\"anchor\" href=\"#_why_testing_asynchronous_code_is_different\"></a>Why testing asynchronous code is different</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Testing asynchronous operations requires more tools than what a test harness like JUnit provides.\nLet us consider a typical Vert.x creation of a HTTP server, and put it into a JUnit test:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ATest</span> {\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">start_server</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">Vertx</span> <span class=\"hljs-variable\">vertx</span> <span class=\"hljs-operator\">=</span> Vertx.vertx();\n    vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">&quot;Ok&quot;</span>))\n      .listen(<span class=\"hljs-number\">16969</span>, ar -&gt; {\n        <span class=\"hljs-comment\">// (we can check here if the server started or not)</span>\n      });\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>There are issues here since <code>listen</code> does not block as it tries to start a HTTP server asynchronously.\nWe cannot simply assume that the server has properly started upon a <code>listen</code> invocation return.\nAlso:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>the callback passed to <code>listen</code> will be executed from a Vert.x event loop thread, which is different from the thread that runs the JUnit test, and</p>\n</li>\n<li>\n<p>right after calling <code>listen</code>, the test exits and is being considered to be passed, while the HTTP server may not even have finished starting, and</p>\n</li>\n<li>\n<p>since the <code>listen</code> callback executes on a different thread than the one executing the test, then any exception such as one thrown by a failed assertion cannot be capture by the JUnit runner.</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_a_test_context_for_asynchronous_executions\"><a class=\"anchor\" href=\"#_a_test_context_for_asynchronous_executions\"></a>A test context for asynchronous executions</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The first contribution of this module is a <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> object that:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>allows waiting for operations in other threads to notify of completion, and</p>\n</li>\n<li>\n<p>supports assertion failures to be received to mark a test as failed.</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>Here is a very basic usage:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BTest</span> {\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">start_http_server</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Throwable {\n    <span class=\"hljs-type\">VertxTestContext</span> <span class=\"hljs-variable\">testContext</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VertxTestContext</span>();\n\n    <span class=\"hljs-type\">Vertx</span> <span class=\"hljs-variable\">vertx</span> <span class=\"hljs-operator\">=</span> Vertx.vertx();\n    vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end())\n      .listen(<span class=\"hljs-number\">16969</span>, testContext.completing()); <b class=\"conum\">(1)</b>\n\n    assertThat(testContext.awaitCompletion(<span class=\"hljs-number\">5</span>, TimeUnit.SECONDS)).isTrue(); <b class=\"conum\">(2)</b>\n    <span class=\"hljs-keyword\">if</span> (testContext.failed()) {  <b class=\"conum\">(3)</b>\n      <span class=\"hljs-keyword\">throw</span> testContext.causeOfFailure();\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#completing--\">completing</a></code> returns an asynchronous result handler that is expected to succeed and then make the test context pass.</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#awaitCompletion-long-java.util.concurrent.TimeUnit-\">awaitCompletion</a></code> has the semantics of a <code>java.util.concurrent.CountDownLatch</code>, and returns <code>false</code> if the waiting delay expired before the test passed.</p>\n</li>\n<li>\n<p>If the context captures a (potentially asynchronous) error, then after completion we must throw the failure exception to make the test fail.</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_use_any_assertion_library\"><a class=\"anchor\" href=\"#_use_any_assertion_library\"></a>Use any assertion library</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This module does not make any assumption on the assertion library that you should be using.\nYou can use plain JUnit assertions, <a href=\"http://joel-costigliola.github.io/assertj/\">AssertJ</a>, etc.</p>\n</div>\n<div class=\"paragraph\">\n<p>To make assertions in asynchronous code and make sure that <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> is notified of potential failures, you need to wrap them with a call to <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#verify-io.vertx.junit5.VertxTestContext.ExecutionBlock-\">verify</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">WebClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> WebClient.create(vertx);\n\nclient.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n  .as(BodyCodec.string())\n  .send(testContext.succeeding(response -&gt; testContext.verify(() -&gt; {\n    assertThat(response.body()).isEqualTo(<span class=\"hljs-string\">&quot;Plop&quot;</span>);\n    testContext.completeNow();\n  })));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The useful methods in <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> are the following:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#completeNow--\">completeNow</a></code> and <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failNow-java.lang.Throwable-\">failNow</a></code> to notify of a success or failure</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#completing--\">completing</a></code> to provide <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> handlers that expect a success and then completes the test context</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#succeeding--\">succeeding</a></code> to provide <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> handlers that expect a success, and optionally pass the result to another callback</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failing--\">failing</a></code> to provide <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> handlers that expect a failure, and optionally pass the exception to another callback</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#verify-io.vertx.junit5.VertxTestContext.ExecutionBlock-\">verify</a></code> to perform assertions, any exception thrown from the code block is considered as a test failure.</p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nUnlike <code>completing()</code>, calling <code>succeeding</code> and <code>failing</code> methods can only make a test fail (e.g., <code>succeeding</code> gets a failed asynchronous result).\nTo make a test pass you still need to call <code>completeNow</code>, or use checkpoints as explained below.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_checkpoint_when_there_are_multiple_success_conditions\"><a class=\"anchor\" href=\"#_checkpoint_when_there_are_multiple_success_conditions\"></a>Checkpoint when there are multiple success conditions</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Many tests can be marked as passed by simply calling <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#completeNow--\">completeNow</a></code> at some point of the execution.\nThat being said there are also many cases where the success of a test depends on different asynchronous parts to be validated.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can use checkpoints to flag some execution points to be passed.\nA <code><a href=\"../../apidocs/io/vertx/junit5/Checkpoint.html\">Checkpoint</a></code> can require a single flagging, or multiple flags.\nWhen all checkpoints have been flagged, then the corresponding <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> makes the test pass.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here is an example with checkpoints on the HTTP server being started, 10 HTTP requests having being responded, and 10 HTTP client requests having been made:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Checkpoint</span> <span class=\"hljs-variable\">serverStarted</span> <span class=\"hljs-operator\">=</span> testContext.checkpoint();\n<span class=\"hljs-type\">Checkpoint</span> <span class=\"hljs-variable\">requestsServed</span> <span class=\"hljs-operator\">=</span> testContext.checkpoint(<span class=\"hljs-number\">10</span>);\n<span class=\"hljs-type\">Checkpoint</span> <span class=\"hljs-variable\">responsesReceived</span> <span class=\"hljs-operator\">=</span> testContext.checkpoint(<span class=\"hljs-number\">10</span>);\n\nvertx.createHttpServer()\n  .requestHandler(req -&gt; {\n    req.response().end(<span class=\"hljs-string\">&quot;Ok&quot;</span>);\n    requestsServed.flag();\n  })\n  .listen(<span class=\"hljs-number\">8080</span>, ar -&gt; {\n    <span class=\"hljs-keyword\">if</span> (ar.failed()) {\n      testContext.failNow(ar.cause());\n    } <span class=\"hljs-keyword\">else</span> {\n      serverStarted.flag();\n    }\n  });\n\n<span class=\"hljs-type\">WebClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> WebClient.create(vertx);\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n  client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n    .as(BodyCodec.string())\n    .send(ar -&gt; {\n      <span class=\"hljs-keyword\">if</span> (ar.failed()) {\n        testContext.failNow(ar.cause());\n      } <span class=\"hljs-keyword\">else</span> {\n        testContext.verify(() -&gt; assertThat(ar.result().body()).isEqualTo(<span class=\"hljs-string\">&quot;Ok&quot;</span>));\n        responsesReceived.flag();\n      }\n    });\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nCheckpoints should be created only from the test case main thread, not from Vert.x asynchronous event callbacks.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_integration_with_junit_5\"><a class=\"anchor\" href=\"#_integration_with_junit_5\"></a>Integration with JUnit 5</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>JUnit 5 provides a different model compared to the previous versions.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_test_methods\"><a class=\"anchor\" href=\"#_test_methods\"></a>Test methods</h3>\n<div class=\"paragraph\">\n<p>The Vert.x integration is primarily done using the <code><a href=\"../../apidocs/io/vertx/junit5/VertxExtension.html\">VertxExtension</a></code> class, and using test parameter injection of <code>Vertx</code> and <code>VertxTestContext</code> instances:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeTest</span> {\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">some_test</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-comment\">// (...)</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nThe <code>Vertx</code> instance is not clustered and has the default configuration. If you need something else then just don&#8217;t use injection on that parameter and prepare a <code>Vertx</code> object by yourself.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>The test is automatically wrapped around the <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> instance lifecycle, so you don&#8217;t need to insert <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#awaitCompletion-long-java.util.concurrent.TimeUnit-\">awaitCompletion</a></code> calls yourself:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeTest</span> {\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">http_server_check_response</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    vertx.deployVerticle(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpServerVerticle</span>(), testContext.succeeding(id -&gt; {\n      <span class=\"hljs-type\">WebClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> WebClient.create(vertx);\n      client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n        .as(BodyCodec.string())\n        .send(testContext.succeeding(response -&gt; testContext.verify(() -&gt; {\n          assertThat(response.body()).isEqualTo(<span class=\"hljs-string\">&quot;Plop&quot;</span>);\n          testContext.completeNow();\n        })));\n    }));\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can use it with standard JUnit annotations such as <code>@RepeatedTest</code> or lifecycle callbacks annotations:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeTest</span> {\n\n  <span class=\"hljs-comment\">// Deploy the verticle and execute the test methods when the verticle is successfully deployed</span>\n  <span class=\"hljs-meta\">@BeforeEach</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">deploy_verticle</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    vertx.deployVerticle(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpServerVerticle</span>(), testContext.completing());\n  }\n\n  <span class=\"hljs-comment\">// Repeat this test 3 times</span>\n  <span class=\"hljs-meta\">@RepeatedTest(3)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">http_server_check_response</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-type\">WebClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> WebClient.create(vertx);\n    client.get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n      .as(BodyCodec.string())\n      .send(testContext.succeeding(response -&gt; testContext.verify(() -&gt; {\n        assertThat(response.body()).isEqualTo(<span class=\"hljs-string\">&quot;Plop&quot;</span>);\n        testContext.completeNow();\n      })));\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It is also possible to customize the default <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> timeout using the <code><a href=\"../../apidocs/io/vertx/junit5/Timeout.html\">@Timeout</a></code> annotation either on test classes or methods:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeTest</span> {\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@Timeout(value = 10, timeUnit = TimeUnit.SECONDS)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">some_test</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext context)</span> {\n    <span class=\"hljs-comment\">// (...)</span>\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_lifecycle_methods\"><a class=\"anchor\" href=\"#_lifecycle_methods\"></a>Lifecycle methods</h3>\n<div class=\"paragraph\">\n<p>JUnit 5 provides several user-defined lifecycle methods annotated with <code>@BeforeAll</code>, <code>@BeforeEach</code>, <code>@AfterEach</code> and <code>@AfterAll</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>These methods can request the injection of <code>Vertx</code> instances.\nBy doing so, they are likely to perform asynchronous operations with the <code>Vertx</code> instance, so they can request the injection of a <code>VertxTestContext</code> instance to ensure that the JUnit runner waits for them to complete, and report possible errors.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here is an example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LifecycleExampleTest</span> {\n\n  <span class=\"hljs-meta\">@BeforeEach</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;Deploy a verticle&quot;)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">prepare</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    vertx.deployVerticle(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SomeVerticle</span>(), testContext.completing());\n  }\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;A first test&quot;)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">foo</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-comment\">// (...)</span>\n    testContext.completeNow();\n  }\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;A second test&quot;)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bar</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-comment\">// (...)</span>\n    testContext.completeNow();\n  }\n\n  <span class=\"hljs-meta\">@AfterEach</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;Check that the verticle is still there&quot;)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">lastChecks</span><span class=\"hljs-params\">(Vertx vertx)</span> {\n    assertThat(vertx.deploymentIDs())\n      .isNotEmpty()\n      .hasSize(<span class=\"hljs-number\">1</span>);\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_scope_of_vertxtestcontext_objects\"><a class=\"anchor\" href=\"#_scope_of_vertxtestcontext_objects\"></a>Scope of <code>VertxTestContext</code> objects</h4>\n<div class=\"paragraph\">\n<p>Since these objects help waiting for asynchronous operations to complete, a new instance is created for any <code>@Test</code>, <code>@BeforeAll</code>, <code>@BeforeEach</code>, <code>@AfterEach</code> and <code>@AfterAll</code> method.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_scope_of_vertx_objects\"><a class=\"anchor\" href=\"#_scope_of_vertx_objects\"></a>Scope of <code>Vertx</code> objects</h4>\n<div class=\"paragraph\">\n<p>The scope of a <code>Vertx</code> object depends on which lifecycle method in the <a href=\"http://junit.org/junit5/docs/current/user-guide/#extensions-execution-order\">JUnit relative execution order</a> first required a new instance to be created.\nGenerally-speaking, we respect the JUnit extension scoping rules, but here are the specifications.</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>If a parent test context already had a <code>Vertx</code> instance, it is being reused in children extension test contexts.</p>\n</li>\n<li>\n<p>Injecting in a <code>@BeforeAll</code> method creates a new instance that is being shared for injection in all subsequent test and lifecycle methods.</p>\n</li>\n<li>\n<p>Injecting in a <code>@BeforeEach</code> with no parent context or previous <code>@BeforeAll</code> injection creates a new instance shared with the corresponding test and <code>AfterEach</code> method(s).</p>\n</li>\n<li>\n<p>When no instance exists before running a test method, an instance is created for that test (and only for that test).</p>\n</li>\n</ol>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_closing_and_removal_of_vertx_objects\"><a class=\"anchor\" href=\"#_closing_and_removal_of_vertx_objects\"></a>Closing and removal of <code>Vertx</code> objects</h4>\n<div class=\"paragraph\">\n<p>Injected <code>Vertx</code> objects are being automatically closed and removed from their corresponding scopes.</p>\n</div>\n<div class=\"paragraph\">\n<p>For instance if a <code>Vertx</code> object is created for the scope of a test method, it is being closed after the test completes.\nSimilarly, when it is being created by a <code>@BeforeEach</code> method, it is being closed after possible <code>@AfterEach</code> methods have completed.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_warning_on_multiple_methods_for_the_same_lifecycle_events\"><a class=\"anchor\" href=\"#_warning_on_multiple_methods_for_the_same_lifecycle_events\"></a>Warning on multiple methods for the same lifecycle events</h4>\n<div class=\"paragraph\">\n<p>JUnit 5 allows multiple methods to exist for the same lifecycle events.</p>\n</div>\n<div class=\"paragraph\">\n<p>As an example, it is possible to define 3 <code>@BeforeEach</code> methods on the same test.\nBecause of asynchronous operations it is possible that the effects of these methods happen concurrently rather than sequentially, which may lead to inconsistent states.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is a problem of JUnit 5 rather than this module. In case of doubt you may always wonder why a single method can&#8217;t be better than many.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_support_for_rxjava_1_and_2_vertx_instances\"><a class=\"anchor\" href=\"#_support_for_rxjava_1_and_2_vertx_instances\"></a>Support for RxJava 1 and 2 Vertx instances</h4>\n<div class=\"paragraph\">\n<p>Reactive eXtension support in Vert.x is being provided by the <code>vertx-rx-java</code> and <code>vertx-rx-java2</code> modules.\nThey provide shims / wrappers around the Vert.x core APIs, like <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html\">Vertx</a></code> (RxJava 1) and <code><a href=\"../../apidocs/io/vertx/reactivex/core/Vertx.html\">Vertx</a></code> (RxJava 2).</p>\n</div>\n<div class=\"paragraph\">\n<p>Instances of these <em>\"Rx-ified\"</em> <code>Vertx</code> classes can be injected in test and lifecycle methods, as in:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@DisplayName(&quot;ðŸ‘€ A RxJava 2 + Vert.x test&quot;)</span>\n<span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RxJava2Test</span> {\n\n  <span class=\"hljs-meta\">@BeforeEach</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">prepare</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    RxHelper.deployVerticle(vertx, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServerVerticle</span>())\n      .subscribe(id -&gt; testContext.completeNow(), testContext::failNow);\n  }\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;ðŸš€ Start a server and perform requests&quot;)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">server_test</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-type\">Checkpoint</span> <span class=\"hljs-variable\">checkpoints</span> <span class=\"hljs-operator\">=</span> testContext.checkpoint(<span class=\"hljs-number\">10</span>);\n\n    HttpRequest&lt;String&gt; request = WebClient\n      .create(vertx)\n      .get(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n      .as(BodyCodec.string());\n\n    request\n      .rxSend()\n      .repeat(<span class=\"hljs-number\">10</span>)\n      .subscribe(\n        response -&gt; testContext.verify(() -&gt; {\n          assertThat(response.body()).isEqualTo(<span class=\"hljs-string\">&quot;Ok&quot;</span>);\n          checkpoints.flag();\n        }),\n        testContext::failNow);\n  }\n\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServerVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">AbstractVerticle</span> {\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">start</span><span class=\"hljs-params\">(Promise&lt;Void&gt; startFuture)</span> <span class=\"hljs-keyword\">throws</span> Exception {\n      vertx.createHttpServer()\n        .requestHandler(req -&gt; {\n          System.out.println(req.method() + <span class=\"hljs-string\">&quot; &quot;</span> + req.uri() + <span class=\"hljs-string\">&quot; from &quot;</span> + req.remoteAddress().host());\n          req.response().end(<span class=\"hljs-string\">&quot;Ok&quot;</span>);\n        })\n        .rxListen(<span class=\"hljs-number\">8080</span>)\n        .subscribe(server -&gt; startFuture.complete(), startFuture::fail);\n    }\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"3.9.13"},"__N_SSG":true}