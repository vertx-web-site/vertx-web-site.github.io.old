{"pageProps":{"slug":"4.2.4/vertx-grpc/java","title":"Vert.x gRPC","fallbackGitHubStars":68,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_grpc_types\">gRPC types</a></li>\n<li><a href=\"#_a_simple_hello_world\">A simple Hello World</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_compile_the_rpc_definition\">Compile the RPC definition</a></li>\n<li><a href=\"#_grpc_server\">gRPC Server</a></li>\n<li><a href=\"#_grpc_client\">gRPC Client</a></li>\n</ul>\n</li>\n<li><a href=\"#_advanced_configuration\">Advanced configuration</a></li>\n<li><a href=\"#_native_transports\">Native transports</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x gRPC</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The best description of gRPC can be seen at wikipedia.</p>\n</div>\n<div class=\"quoteblock\">\n<blockquote>\n<div class=\"paragraph\">\n<p>gRPC is an open source remote procedure call (RPC) system initially developed at Google. It uses HTTP/2 for\ntransport, Protocol Buffers as the interface description language, and provides features such as authentication,\nbidirectional streaming and flow control, blocking or nonblocking bindings, and cancellation and timeouts. It\ngenerates cross-platform client and server bindings for many languages.</p>\n</div>\n</blockquote>\n<div class=\"attribution\">\n&#8212; wikipedia<br>\n<cite>wikipedia</cite>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x gRPC is a module that will align the programming style of Google gRPC with Vert.x style. As a user of this\nmodule you will be more familiar with the code style using Vert.x Streams and Futures while benefiting from all the\nbenefits of gRPC.</p>\n</div>\n<div class=\"paragraph\">\n<p>For more information related to gRPC please consult the official documentation site <a href=\"http://www.grpc.io/\" class=\"bare\">http://www.grpc.io/</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>In addition Vert.x gRPC supports</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>gRPC service scaling with Verticles</p>\n</li>\n<li>\n<p>non-blocking native transports</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_grpc_types\"><a class=\"anchor\" href=\"#_grpc_types\"></a>gRPC types</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>With gRPC you benefit from HTTP/2 which means that you will have asynchronous streaming support which means that your\nRemote Procedure Calls can have the following characteristics:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Client streams request objects while Server replies with a single response object</p>\n</li>\n<li>\n<p>Client streams request objects while Server replies with a stream of response objects</p>\n</li>\n<li>\n<p>Client sends a single request object while Server replies with a single response object</p>\n</li>\n<li>\n<p>Client sends a single request object while Server replies with a stream of response objects</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>While to the untrained eye this might not look to different from other HTTP based RPC approaches you should be aware\nthat with HTTP/2 your requests do not need to complete before the responses start to arrive. This means that your\ncommunication channel is full duplex. Being full duplex allows you to reduce the response latency and make more\nresponse application.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_a_simple_hello_world\"><a class=\"anchor\" href=\"#_a_simple_hello_world\"></a>A simple Hello World</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>In order to start with your first hello world example, one needs to define the protocol. gRPC requires you to define\nthis protocol using the <code>protobuffer</code> format.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-proto\" data-lang=\"proto\">syntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"examples\";\noption java_outer_classname = \"HelloWorldProto\";\npackage helloworld;\n\n// The greeting service definition.\nservice Greeter {\n // Sends a greeting\n rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n string message = 1;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This is a very simple example showing the single request, single response mode.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_compile_the_rpc_definition\"><a class=\"anchor\" href=\"#_compile_the_rpc_definition\"></a>Compile the RPC definition</h3>\n<div class=\"paragraph\">\n<p>Using the definition above we need to compile it.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can compile the proto file using the <code>protoc</code> compiler if you <a href=\"https://github.com/google/protobuf/tree/master/java#installation---without-maven\">like</a>\nor you can integrate it in your build.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you&#8217;re using Apache Maven you need to add the plugin:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>protobuf-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.6.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.2.0:exe:${os.detected.classifier}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocArtifact</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginId</span>&gt;</span>grpc-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginId</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:${vertx.grpc.version}:exe:${os.detected.classifier}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocPlugins</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocPlugin</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${stack.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mainClass</span>&gt;</span>io.vertx.grpc.protoc.plugin.VertxGrpcGenerator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mainClass</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocPlugin</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocPlugins</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">executions</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">execution</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">outputDirectory</span>&gt;</span>${project.basedir}/src/main/java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">outputDirectory</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clearOutputDirectory</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clearOutputDirectory</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goals</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>compile-custom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goals</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">execution</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">execution</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>test-compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goals</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>test-compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>test-compile-custom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goals</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">execution</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">executions</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>${os.detected.classifier}</code> property is used to make the build OS independant, on OSX it is replaced\nby <em>osx-x86_64</em> and so on. To use it you need to add the os-maven-plugin[<a href=\"https://github.com/trustin/os-maven-plugin\" class=\"bare\">https://github.com/trustin/os-maven-plugin</a>]\nin the <code>build</code> section of your <code>pom.xml</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n ...\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">extensions</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">extension</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>kr.motd.maven<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>os-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.4.1.Final<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">extension</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">extensions</span>&gt;</span>\n ...\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This plugin will compile your proto files under <code>src/main/proto</code> and make them available to your project.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you&#8217;re using Gradle you need to add the plugin:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">...\napply <span class=\"hljs-attr\">plugin:</span> <span class=\"hljs-string\">&#x27;com.google.protobuf&#x27;</span>\n...\nbuildscript {\n ...\n dependencies {\n   <span class=\"hljs-comment\">// ASSUMES GRADLE 2.12 OR HIGHER. Use plugin version 0.7.5 with earlier gradle versions</span>\n   classpath <span class=\"hljs-string\">&#x27;com.google.protobuf:protobuf-gradle-plugin:0.8.0&#x27;</span>\n }\n}\n...\nprotobuf {\n protoc {\n   artifact = <span class=\"hljs-string\">&#x27;com.google.protobuf:protoc:3.2.0&#x27;</span>\n }\n plugins {\n   grpc {\n     artifact = <span class=\"hljs-string\">&quot;io.grpc:protoc-gen-grpc-java:1.25.0&quot;</span>\n   }\n   vertx {\n     artifact = <span class=\"hljs-string\">&quot;io.vertx:vertx-grpc-protoc-plugin:${vertx.grpc.version}&quot;</span>\n   }\n }\n generateProtoTasks {\n   all()*.plugins {\n     grpc\n     vertx\n   }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This plugin will compile your proto files under <code>build/generated/source/proto/main</code> and make them available to your project.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_grpc_server\"><a class=\"anchor\" href=\"#_grpc_server\"></a>gRPC Server</h3>\n<div class=\"paragraph\">\n<p>Now you should have your RPC base code setup it is time to implement your server. As you should recall from above we\ndescribed that our server should implement a <code>sayHello</code> method that receives a <code>HelloRequest</code> objects and returns a\n<code>HelloReply</code> object. So you can implement it as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GreeterGrpc.GreeterImplBase service = <span class=\"hljs-keyword\">new</span> GreeterGrpc.GreeterImplBase() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(\n    HelloRequest request,\n    StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>{\n\n    responseObserver.onNext(\n      HelloReply.newBuilder()\n        .setMessage(request.getName())\n        .build());\n    responseObserver.onCompleted();\n  }\n};</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Once you&#8217;re happy with it you can then make your service available on a server. Vert.x makes the creation of a server\nquite simple all you need to add is:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxServer rpcServer = VertxServerBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">&quot;my.host&quot;</span>, <span class=\"hljs-number\">8080</span>)\n  .addService(service)\n  .build();\n\n<span class=\"hljs-comment\">// Start is asynchronous</span>\nrpcServer.start();</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_vert_x_future_and_streams\"><a class=\"anchor\" href=\"#_using_vert_x_future_and_streams\"></a>Using Vert.x future and streams</h4>\n<div class=\"paragraph\">\n<p>The previous example was using a gRPC server processing asynchronously using gRPC asynchronous constructs such\nas <code>io.grpc.stub.StreamObserver</code>. This code is generated by the protoc compiler.</p>\n</div>\n<div class=\"paragraph\">\n<p>The plugin configuration above configures the following plugin:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocPlugin</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${stack.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mainClass</span>&gt;</span>io.vertx.grpc.protoc.plugin.VertxGrpcGenerator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mainClass</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocPlugin</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This generates a service version that uses Vert.x asynchronous constructs such as <code>Future</code> or <code>ReadStream</code> or <code>WriteStream</code>\nwhich can be more convenient in the Vert.x ecosystem.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxGreeterGrpc.GreeterVertxImplBase service =\n  <span class=\"hljs-keyword\">new</span> VertxGreeterGrpc.GreeterVertxImplBase() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;HelloReply&gt; <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n      <span class=\"hljs-keyword\">return</span> Future.succeededFuture(\n        HelloReply.newBuilder()\n          .setMessage(request.getName())\n          .build());\n    }\n  };</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_server_gzip_compression\"><a class=\"anchor\" href=\"#_server_gzip_compression\"></a>Server gzip compression</h4>\n<div class=\"paragraph\">\n<p>You can enable gzip compression to tell the server to send compressed responses (compressed requests\nare automatically handled by the server).</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxGreeterGrpc.GreeterVertxImplBase service =\n  <span class=\"hljs-keyword\">new</span> VertxGreeterGrpc.GreeterVertxImplBase() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;HelloReply&gt; <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n      <span class=\"hljs-keyword\">return</span> Future.succeededFuture(\n        HelloReply.newBuilder()\n          .setMessage(request.getName())\n          .build());\n    }\n  }\n    .withCompression(<span class=\"hljs-string\">&quot;gzip&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>withCompression</code> configuration is generated by the Vert.x gRPC protoc plugin. You can also enable compression\non default services by casting the <code>ResponseObserver</code> to <code>ServerCallStreamObserver</code> and call <code>setCompression</code> before\nsending the response.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GreeterGrpc.GreeterImplBase service = <span class=\"hljs-keyword\">new</span> GreeterGrpc.GreeterImplBase() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(\n    HelloRequest request,\n    StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>{\n\n    ((ServerCallStreamObserver) responseObserver)\n      .setCompression(<span class=\"hljs-string\">&quot;gzip&quot;</span>);\n\n    responseObserver.onNext(\n      HelloReply.newBuilder()\n        .setMessage(request.getName())\n        .build());\n\n    responseObserver.onCompleted();\n  }\n};</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nyou can use other compressors as long as the server support them and they are registered against the compressor\nregistry when building the <code>ManagedChannel</code>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_ssl_configuration\"><a class=\"anchor\" href=\"#_ssl_configuration\"></a>SSL configuration</h4>\n<div class=\"paragraph\">\n<p>The previous example was simple but your RPC is not secure. In order to make it secure we should enable SSL/TLS:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxServerBuilder builder = VertxServerBuilder.forPort(vertx, <span class=\"hljs-number\">8080</span>)\n  .useSsl(options -&gt; options\n    .setSsl(<span class=\"hljs-keyword\">true</span>)\n    .setUseAlpn(<span class=\"hljs-keyword\">true</span>)\n    .setKeyStoreOptions(<span class=\"hljs-keyword\">new</span> JksOptions()\n      .setPath(<span class=\"hljs-string\">&quot;server-keystore.jks&quot;</span>)\n      .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>)));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Congratulations you just completed your first gRPC server.</p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nsince gRPC uses HTTP/2 transport, SSL/TLS setup requires the\n<a href=\"https://wikipedia.org/wiki/Application-Layer_Protocol_Negotiation\">Application-Layer Protocol Negotiation</a>\nin your server\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_server_scaling\"><a class=\"anchor\" href=\"#_server_scaling\"></a>Server scaling</h4>\n<div class=\"paragraph\">\n<p>When you deploy several instances of the same verticles, the gRPC server will be scaled\non the verticle event-loops.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.deployVerticle(\n\n  <span class=\"hljs-comment\">// Verticle supplier - should be called 4 times</span>\n  () -&gt; <span class=\"hljs-keyword\">new</span> AbstractVerticle() {\n\n    BindableService service = <span class=\"hljs-keyword\">new</span> GreeterGrpc.GreeterImplBase() {\n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(\n        HelloRequest request,\n        StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>{\n\n        responseObserver.onNext(\n          HelloReply.newBuilder()\n            .setMessage(request.getName())\n            .build());\n\n        responseObserver.onCompleted();\n      }\n    };\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n      VertxServerBuilder\n        .forAddress(vertx, <span class=\"hljs-string\">&quot;my.host&quot;</span>, <span class=\"hljs-number\">8080</span>)\n        .addService(service)\n        .build()\n        .start();\n    }\n  },\n\n  <span class=\"hljs-comment\">// Deploy 4 instances, i.e the service is scaled on 4 event-loops</span>\n  <span class=\"hljs-keyword\">new</span> DeploymentOptions()\n    .setInstances(<span class=\"hljs-number\">4</span>));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_blockingserverinterceptor\"><a class=\"anchor\" href=\"#_blockingserverinterceptor\"></a>BlockingServerInterceptor</h4>\n<div class=\"paragraph\">\n<p>gRPC <a href=\"https://grpc.io/grpc-java/javadoc/io/grpc/ServerInterceptor.html\">ServerInterceptor</a> is a mechanism\nfor intercepting incoming calls before they are sent to the service.\nIt has synchronous behavior and will be execute on the Vert.x event loop.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">VertxServer rpcServer = VertxServerBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">&quot;my.host&quot;</span>, <span class=\"hljs-number\">8080</span>)\n  .addService(ServerInterceptors.intercept(service, myInterceptor))\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Suppose we have an interceptor that does something blocking the event loop:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ServerInterceptor</span> </span>{\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> &lt;Q, A&gt; ServerCall.<span class=\"hljs-function\">Listener&lt;Q&gt; <span class=\"hljs-title\">interceptCall</span><span class=\"hljs-params\">(\n    ServerCall&lt;Q, A&gt; call, Metadata headers, ServerCallHandler&lt;Q, A&gt; next)</span> </span>{\n    <span class=\"hljs-comment\">// do something hard and update the metadata, for example</span>\n    <span class=\"hljs-keyword\">return</span> next.startCall(call, headers);\n  }\n}\nMyInterceptor myInterceptor = <span class=\"hljs-keyword\">new</span> MyInterceptor();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>To avoid the blocking one should wrap the interceptor. Then it will be called on the Vert.x worker thread.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServerInterceptor wrapped =\n  BlockingServerInterceptor.wrap(vertx, myInterceptor);\n\n<span class=\"hljs-comment\">// Create the server</span>\nVertxServer rpcServer = VertxServerBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">&quot;my.host&quot;</span>, <span class=\"hljs-number\">8080</span>)\n  .addService(ServerInterceptors.intercept(service, wrapped))\n  .build();\n\n<span class=\"hljs-comment\">// Start it</span>\nrpcServer.start();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_context_server_interceptor\"><a class=\"anchor\" href=\"#_context_server_interceptor\"></a>Context Server Interceptor</h4>\n<div class=\"paragraph\">\n<p>An abstract context server interceptor is available to allow intercepting server calls and extract metadata into the\nvert.x context. This context does not rely on thread locals so it is safe to use on vert.x APIs. This interceptor should\nbe the first (or one of the firsts to be added to the interceptors list).</p>\n</div>\n<div class=\"paragraph\">\n<p>A typical example is the use of a session id. A client can create a client interceptor that sets a session id in all\nconnections as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Metadata extraHeaders = <span class=\"hljs-keyword\">new</span> Metadata();\nextraHeaders.put(\n  Metadata.Key.of(<span class=\"hljs-string\">&quot;sessionId&quot;</span>, Metadata.ASCII_STRING_MARSHALLER), theSessionId);\n\nClientInterceptor clientInterceptor = MetadataUtils\n  .newAttachHeadersInterceptor(extraHeaders);\n\nchannel = VertxChannelBuilder.forAddress(vertx, <span class=\"hljs-string\">&quot;localhost&quot;</span>, port)\n  .intercept(clientInterceptor)\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>And then on the server side an interceptor can be added as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">BindableService service = <span class=\"hljs-keyword\">new</span> VertxGreeterGrpc.GreeterVertxImplBase() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Future&lt;HelloReply&gt; <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> Future.succeededFuture(\n      HelloReply.newBuilder().setMessage(<span class=\"hljs-string\">&quot;Hello &quot;</span> + request.getName()).build());\n  }\n};\n\nServerInterceptor contextInterceptor = <span class=\"hljs-keyword\">new</span> ContextServerInterceptor() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(Metadata metadata)</span> </span>{\n    put(<span class=\"hljs-string\">&quot;sessionId&quot;</span>, metadata.get(SESSION_ID_METADATA_KEY));\n  }\n};\n\n<span class=\"hljs-comment\">// Create the server</span>\nVertxServer rpcServer = VertxServerBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">&quot;my.host&quot;</span>, <span class=\"hljs-number\">8080</span>)\n  .addService(ServerInterceptors.intercept(service, contextInterceptor))\n  .build();</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_grpc_client\"><a class=\"anchor\" href=\"#_grpc_client\"></a>gRPC Client</h3>\n<div class=\"paragraph\">\n<p>A server without a client is of no use, so lets create a client. In order to do this some steps overlap with the\nserver. First we need to have the RPC definition, which should already done otherwise there would be no server and\nthe same definition should have been compiled.</p>\n</div>\n<div class=\"paragraph\">\n<p>Note that the compiler will always generate both the base server and a client stub so if you already compiled once\nyou do not need to re-compile it again.</p>\n</div>\n<div class=\"paragraph\">\n<p>Every client stub will always require a communication channel to a server so first we need to create a gRPC channel:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ManagedChannel channel = VertxChannelBuilder\n  .forAddress(vertx, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">8080</span>)\n  .usePlaintext()\n  .build();\n\n<span class=\"hljs-comment\">// Get a stub to use for interacting with the remote service</span>\nGreeterGrpc.GreeterStub stub = GreeterGrpc.newStub(channel);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Once the stub is created we can communicate with our server, this time it is easier since the stub already provides\nthe correct method definition and parameter types:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HelloRequest request = HelloRequest.newBuilder().setName(<span class=\"hljs-string\">&quot;Julien&quot;</span>).build();\n\n<span class=\"hljs-comment\">// Call the remote service</span>\nstub.sayHello(request, <span class=\"hljs-keyword\">new</span> StreamObserver&lt;HelloReply&gt;() {\n  <span class=\"hljs-keyword\">private</span> HelloReply helloReply;\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(HelloReply helloReply)</span> </span>{\n    <span class=\"hljs-keyword\">this</span>.helloReply = helloReply;\n  }\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable throwable)</span> </span>{\n    System.out.println(<span class=\"hljs-string\">&quot;Coult not reach server &quot;</span> + throwable.getMessage());\n  }\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCompleted</span><span class=\"hljs-params\">()</span> </span>{\n    System.out.println(<span class=\"hljs-string\">&quot;Got the server response: &quot;</span> + helloReply.getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_using_vert_x_future_and_streams_2\"><a class=\"anchor\" href=\"#_using_vert_x_future_and_streams_2\"></a>Using Vert.x future and streams</h4>\n<div class=\"paragraph\">\n<p>The previous example was using a gRPC client processing asynchronously using gRPC asynchronous constructs such\nas <code>io.grpc.stub.StreamObserver</code>. This code is generated by the protoc compiler.</p>\n</div>\n<div class=\"paragraph\">\n<p>The plugin configuration above configures the following plugin:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocPlugin</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-grpc-protoc-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${stack.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mainClass</span>&gt;</span>io.vertx.grpc.protoc.plugin.VertxGrpcGenerator<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mainClass</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocPlugin</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This generates a client version that uses Vert.x asynchronous constructs such as <code>Future</code> or <code>ReadStream</code> or <code>WriteStream</code>\nwhich can be more convenient in the Vert.x ecosystem.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HelloRequest request = HelloRequest.newBuilder().setName(<span class=\"hljs-string\">&quot;Julien&quot;</span>).build();\n\n<span class=\"hljs-comment\">// Call the remote service</span>\nFuture&lt;HelloReply&gt; future = stub.sayHello(request);\n\n<span class=\"hljs-comment\">// Listen to completion events</span>\nfuture\n  .onSuccess(helloReply -&gt; System.out.println(<span class=\"hljs-string\">&quot;Got the server response: &quot;</span> + helloReply.getMessage())).onFailure(err -&gt; System.out.println(<span class=\"hljs-string\">&quot;Coult not reach server &quot;</span> + err));</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_client_gzip_compression\"><a class=\"anchor\" href=\"#_client_gzip_compression\"></a>Client gzip compression</h4>\n<div class=\"paragraph\">\n<p>You can enable gzip compression to tell the client to send compressed messages.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">GreeterGrpc.GreeterStub stub = GreeterGrpc\n  .newStub(channel)\n  .withCompression(<span class=\"hljs-string\">&quot;gzip&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nyou can use other compressors as long as the server support them and they are registered against the compressor\n     registry when building the <code>ManagedChannel</code>\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_ssl_configuration_2\"><a class=\"anchor\" href=\"#_ssl_configuration_2\"></a>SSL configuration</h4>\n<div class=\"paragraph\">\n<p>If you enabled SSL previously your client will also require SSL, in order to do this we need to configure the channel:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ManagedChannel channel = VertxChannelBuilder.\n  forAddress(vertx, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">8080</span>)\n  .useSsl(options -&gt; options\n    .setSsl(<span class=\"hljs-keyword\">true</span>)\n    .setUseAlpn(<span class=\"hljs-keyword\">true</span>)\n    .setTrustStoreOptions(<span class=\"hljs-keyword\">new</span> JksOptions()\n      .setPath(<span class=\"hljs-string\">&quot;client-truststore.jks&quot;</span>)\n      .setPassword(<span class=\"hljs-string\">&quot;secret&quot;</span>)))\n  .build();</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nsince gRPC uses HTTP/2 transport, SSL/TLS setup requires the\n<a href=\"https://wikipedia.org/wiki/Application-Layer_Protocol_Negotiation\">Application-Layer Protocol Negotiation</a>\nin your client\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_advanced_configuration\"><a class=\"anchor\" href=\"#_advanced_configuration\"></a>Advanced configuration</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Until now all gRPC examples where using sensible defaults but there is more, if you need to have full control over\nthe server configuration you should refer to the documentation: <code><a href=\"../../apidocs/io/vertx/grpc/VertxServerBuilder.html\">VertxServerBuilder</a></code>, or if you\nneed to control your client channel <code><a href=\"../../apidocs/io/vertx/grpc/VertxChannelBuilder.html\">VertxChannelBuilder</a></code>. Vert.x gRPC extends the grpc-java\nproject (Netty transport) and therefore reading its <a href=\"http://www.grpc.io/grpc-java/javadoc/\">documentation</a> is\nrecommended.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_native_transports\"><a class=\"anchor\" href=\"#_native_transports\"></a>Native transports</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The client and server can be deployed with Netty&#8217;s native transports, this is achieved when\ncreating the Vert.x instance.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx.vertx(<span class=\"hljs-keyword\">new</span> VertxOptions().setPreferNativeTransport(<span class=\"hljs-keyword\">true</span>));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Please refer Vert.x Core documentation for more information about native transports.</p>\n</div>\n</div>\n</div>","version":"4.2.4"},"__N_SSG":true}