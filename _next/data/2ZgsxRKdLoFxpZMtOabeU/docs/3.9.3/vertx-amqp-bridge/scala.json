{"pageProps":{"slug":"3.9.3/vertx-amqp-bridge/scala","title":"Vert.x AMQP Bridge","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_amqp_bridge\">Using Vert.x AMQP Bridge</a></li>\n<li><a href=\"#_getting_started\">Getting Started</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_sending_a_message\">Sending a Message</a></li>\n<li><a href=\"#_receiving_a_message\">Receiving a Message</a></li>\n</ul>\n</li>\n<li><a href=\"#message_payload\">Message Payload</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_overview\">Overview</a></li>\n<li><a href=\"#_application_properties\">Application Properties</a></li>\n</ul>\n</li>\n<li><a href=\"#_flow_control\">Flow Control</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_producers\">Producers</a></li>\n<li><a href=\"#_consumers\">Consumers</a></li>\n</ul>\n</li>\n<li><a href=\"#_connecting_using_ssl\">Connecting using SSL</a></li>\n<li><a href=\"#_sending_and_receiving_replies\">Sending and Receiving replies.</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_sent_messages_seeking_a_reply\">Sent messages seeking a reply.</a></li>\n<li><a href=\"#_received_messages_seeking_a_reply\">Received messages seeking a reply.</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x AMQP Bridge</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This component provides AMQP 1.0 producer and consumer support via a bridging layer implementing the Vert.x event bus\nMessageProducer and MessageConsumer APIs over the top of <a href=\"https://github.com/vert-x3/vertx-proton/\">vertx-proton</a>.</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nThis component will be removed in Vert.x 4, instead you should use <a href=\"https://vertx.io/docs/vertx-amqp-client/java/\">Vert.x AMQP Client</a>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_amqp_bridge\"><a class=\"anchor\" href=\"#_using_vert_x_amqp_bridge\"></a>Using Vert.x AMQP Bridge</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use Vert.x AMQP Bridge, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-amqp-bridge<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${maven.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile io.<span class=\"hljs-attr\">vertx:</span>vertx-amqp-<span class=\"hljs-attr\">bridge:</span>${maven.version}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting Started</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_sending_a_message\"><a class=\"anchor\" href=\"#_sending_a_message\"></a>Sending a Message</h3>\n<div class=\"paragraph\">\n<p>Here is a simple example of creating a <code><a href=\"../../scaladocs/io/vertx/scala/core/eventbus/MessageProducer.html\">MessageProducer</a></code> and sending a message with it.\nFirst, an <code><a href=\"../../scaladocs/io/vertx/scala/amqpbridge/AmqpBridge.html\">AmqpBridge</a></code> is created and started to establish the underlying AMQP connection,\nthen when this is complete the producer is created and a message sent using it. You can optionally supply a username\nand password when starting the bridge, as well as supplying <code><a href=\"../dataobjects.html#AmqpBridgeOptions\">AmqpBridgeOptions</a></code> in order\nto configure various options such as for using SSL connections.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> bridge = <span class=\"hljs-type\">AmqpBridge</span>.create(vertx)\n<span class=\"hljs-comment\">// Start the bridge, then use the event loop thread to process things thereafter.</span>\nbridge.startFuture(<span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">5672</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">&quot;Success&quot;</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_receiving_a_message\"><a class=\"anchor\" href=\"#_receiving_a_message\"></a>Receiving a Message</h3>\n<div class=\"paragraph\">\n<p>Here is a simple example of creating a <code><a href=\"../../scaladocs/io/vertx/scala/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> and registering a handler with it.\nFirst, an <code><a href=\"../../scaladocs/io/vertx/scala/amqpbridge/AmqpBridge.html\">AmqpBridge</a></code> is created and started to establish the underlying AMQP connection,\nthen when this is complete the consumer is created and a handler registered that prints the body of incoming AMQP\nmessages.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> bridge = <span class=\"hljs-type\">AmqpBridge</span>.create(vertx)\n<span class=\"hljs-comment\">// Start the bridge, then use the event loop thread to process things thereafter.</span>\nbridge.startFuture(<span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">5672</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">&quot;Success&quot;</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Receipt of the AMQP message is accepted automatically as soon as the consumer&#8217;s handler returns upon delivering the\nmessage to the application.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"message_payload\"><a class=\"anchor\" href=\"#message_payload\"></a>Message Payload</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_overview\"><a class=\"anchor\" href=\"#_overview\"></a>Overview</h3>\n<div class=\"paragraph\">\n<p>The message payload is passed as a JsonObject with elements representing various sections of the\n<a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format\">AMQP\nmessage</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The top-level elements supported are:</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>body</strong>: The content for the body section of the AMQP message.\n<strong>body_type</strong>: An optional String used to indicate whether the \"body\" element represents an AmqpValue (default), Data, or AmqpSequence section. The values used are \"value\", \"data\", and \"sequence\" respectively.\n<strong>header</strong>: An optional  JsonObject representing the elements of the message Header section. Expanded below.\n<strong>properties</strong>: An optional JsonObject representing the elements of the message Properties section. Expanded below.\n<strong>application_properties</strong>: An optional JsonObject containing any application defined properties(/headers).\n<strong>message_annotations</strong>: An optional JsonObject representing any message annotations.</p>\n</div>\n<div class=\"paragraph\">\n<p>The elements of the optional \"header\" sub-element are:</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>durable</strong>: optional boolean indicating whether the message is durable (default false).\n<strong>priority</strong>: optional short indicating the message priority (default 4).\n<strong>ttl</strong>: optional long indicating ttl in milliseconds (no default). See also 'properties' absolute expiry time.\n<strong>first_acquirer</strong>: boolean indicating if this is the first acquirer of the message (default false)\n<strong>delivery_count</strong>: long indicating the number of previous <em>failed</em> delivery attempts for message.</p>\n</div>\n<div class=\"paragraph\">\n<p>The elements of the optional \"properties\" sub-element are:</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>to</strong>: optional string with address message is being sent to (no default).\n<strong>reply_to</strong>: optional string with address for replies (no default). Set automatically when sent with reply handler.\n<strong>message_id</strong>: optional string with message id (no default). Set automatically when sending with reply handler.\n<strong>correlation_id</strong>: optional string with correlation id (no default). Set automatically when implicit reply is sent.\n<strong>subject</strong>: optional string with message subject (no default).\n<strong>group_id</strong>: optional string with message group id (no default).\n<strong>group_sequence</strong>: optional long with message group sequence (no default).\n<strong>reply_to_group_id</strong>: optional string with message reply to group id (no default).\n<strong>content_type</strong>: optional string with message content type (no default). Only for use with Data body sections.\n<strong>content_encoding</strong>: optional string with message content encoding (no default).\n<strong>creation_time</strong>: optional long with message creation time in milliseconds since the unix epoch (no default).\n<strong>absolute_expiry_time</strong>: optional long with absolute expiry time as milliseconds since the unix epoch (no default).\n<strong>user_id</strong>: optional string with the id of the user sending the message (no default).</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_application_properties\"><a class=\"anchor\" href=\"#_application_properties\"></a>Application Properties</h3>\n<div class=\"paragraph\">\n<p>To send a message with application properties, the \"application_properties\" element is added to the payload,\ncontaining a JsonObject whose contents represent the application property entries, which have string keys and a\nobject representing a simple value such as String, Boolean, Integer, etc. For example, adding a property to a sent\nmessage could look something like:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> applicationProperties = <span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>()\napplicationProperties.put(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;value&quot;</span>)\n\n<span class=\"hljs-keyword\">var</span> amqpMsgPayload = <span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>()\namqpMsgPayload.put(<span class=\"hljs-string\">&quot;application_properties&quot;</span>, applicationProperties)\n\nproducer.send(amqpMsgPayload)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When receiving a message with application properties, the \"application_properties\" element is added to the JsonObject\npayload returned, containing a JsonObject whose contents represent the application property entries. For example,\nretrieving an application-property from a received message might look like:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// Check the application properties section was present before use, it may not be</span>\n<span class=\"hljs-keyword\">var</span> appProps = amqpMsgPayload.getValue(<span class=\"hljs-string\">&quot;application_properties&quot;</span>)\n<span class=\"hljs-keyword\">if</span> (appProps != <span class=\"hljs-literal\">null</span>) {\n  <span class=\"hljs-keyword\">var</span> propValue = appProps.getValue(<span class=\"hljs-string\">&quot;propertyName&quot;</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_flow_control\"><a class=\"anchor\" href=\"#_flow_control\"></a>Flow Control</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Message transfer between peers, such as clients and servers, is governed by credit in AMQP 1.0, with receiving peers\ngranting sending peers a number of credits to allow them to send messages. As each message is sent a unit of credit\nis used up, with the receiving peer needing to replenish the senders credit over time in order for message delivery\nto progress. This allows for recipients to flow control senders by governing the amount of outstanding credit\navailable.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_producers\"><a class=\"anchor\" href=\"#_producers\"></a>Producers</h3>\n<div class=\"paragraph\">\n<p>While a MessageProducer will buffer outgoing messages if there are insufficient credits to send them all\nimmediately, and then send them once credit is granted, it is typically more desirable for the application to work\nin tandem with the producer and attempt to send only what it knows can actually currently be sent.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is possible by inspecting whether the producer write queue is full, i.e it currently has no credit to send:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">producer.writeQueueFull()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This check can be used in concert with a handler that can be registered to receive callbacks whenever the producer\nreceives more credit and is able to send messages immediately rather than buffer them:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">producer.drainHandler((v: java.lang.<span class=\"hljs-type\">Void</span>) =&gt; {\n  <span class=\"hljs-comment\">// ...do stuff and send...</span>\n})</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_consumers\"><a class=\"anchor\" href=\"#_consumers\"></a>Consumers</h3>\n<div class=\"paragraph\">\n<p>In the case of a MessageConsumer, the bridge automatically gives 1000 credits to the sending peer when the consumer\nhandler is registered, and replenishes this credit automatically as messages are delivered to the handler. It is\npossible to adjust the amount of credit given initially (the value must be at least 1) by adjusting the maximum\nbuffered message value before registering a handler, for example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">consumer.setMaxBufferedMessages(<span class=\"hljs-number\">5</span>)\nconsumer.handler((msg: io.vertx.scala.core.eventbus.<span class=\"hljs-type\">Message</span>&lt;io.vertx.scala.core.json.<span class=\"hljs-type\">JsonObject</span>&gt;) =&gt; {\n  <span class=\"hljs-comment\">// ...handle received messages...</span>\n})</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_using_ssl\"><a class=\"anchor\" href=\"#_connecting_using_ssl\"></a>Connecting using SSL</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can also optionally supply <code><a href=\"../dataobjects.html#AmqpBridgeOptions\">AmqpBridgeOptions</a></code> when creating the bridge in order to\nconfigure various options, the most typically used of which are around behaviour for SSL connections.</p>\n</div>\n<div class=\"paragraph\">\n<p>The following is an example of using configuration to create a bridge connecting to a server using SSL,\nauthenticating with a username and password, and supplying a PKCS12 based trust store to verify trust of the server\ncertificate:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> bridgeOptions = <span class=\"hljs-type\">AmqpBridgeOptions</span>()\nbridgeOptions.setSsl(<span class=\"hljs-literal\">true</span>)\n\n<span class=\"hljs-keyword\">var</span> trustOptions = <span class=\"hljs-type\">PfxOptions</span>()\n  .setPath(<span class=\"hljs-string\">&quot;path/to/pkcs12.truststore&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;password&quot;</span>)\n\nbridgeOptions.setPfxTrustOptions(trustOptions)\n\n<span class=\"hljs-keyword\">var</span> bridge = <span class=\"hljs-type\">AmqpBridge</span>.create(vertx, bridgeOptions)\nbridge.startFuture(<span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">5672</span>, <span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;password&quot;</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">&quot;Success&quot;</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The following is an example of using configuration to create a bridge connecting to a server requiring SSL Client\nCertificate Authentication, supplying both a PKCS12 based trust store to verify trust of the server certificate and\nalso a PKCS12 based key store containing an SSL key and certificate the server can use to verify the client:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> bridgeOptions = <span class=\"hljs-type\">AmqpBridgeOptions</span>()\nbridgeOptions.setSsl(<span class=\"hljs-literal\">true</span>)\n\n<span class=\"hljs-keyword\">var</span> trustOptions = <span class=\"hljs-type\">PfxOptions</span>()\n  .setPath(<span class=\"hljs-string\">&quot;path/to/pkcs12.truststore&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;password&quot;</span>)\n\nbridgeOptions.setPfxTrustOptions(trustOptions)\n\n<span class=\"hljs-keyword\">var</span> keyCertOptions = <span class=\"hljs-type\">PfxOptions</span>()\n  .setPath(<span class=\"hljs-string\">&quot;path/to/pkcs12.keystore&quot;</span>)\n  .setPassword(<span class=\"hljs-string\">&quot;password&quot;</span>)\n\nbridgeOptions.setPfxKeyCertOptions(keyCertOptions)\n\n<span class=\"hljs-keyword\">var</span> bridge = <span class=\"hljs-type\">AmqpBridge</span>.create(vertx, bridgeOptions)\nbridge.startFuture(<span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">5672</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">&quot;Success&quot;</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_sending_and_receiving_replies\"><a class=\"anchor\" href=\"#_sending_and_receiving_replies\"></a>Sending and Receiving replies.</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Like many messaging protocols, AMQP includes support for a reply-to address to be set on each message sent so that\nrecipients can be told where to send any responses required. The vert.x <code><a href=\"../../scaladocs/io/vertx/scala/core/eventbus/Message.html\">Message</a></code>\nobjects also support the concept of a reply address, though when using the Event Bus the sender doesn&#8217;t set it\nexplicitly, and it is instead populated implicitly if a message is sent with a reply <code>Handler</code>.\nThis section describes how the bridge handles sending and receiving AMQP messages with reply-to while using the\nVert.x producer, consumer, and message APIs implemented by the bridge.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sent_messages_seeking_a_reply\"><a class=\"anchor\" href=\"#_sent_messages_seeking_a_reply\"></a>Sent messages seeking a reply.</h3>\n<div class=\"paragraph\">\n<p>There are two options when sending messages to which responses are required:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Populate the AMQP reply-to address of the outgoing message explicitly.</p>\n</li>\n<li>\n<p>Provide a reply handler when sending to populate it implicitly.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>With the first option, you may explicitly populate the \"reply_to\" element of the message \"properties\" section, as\noutlined in the <a href=\"#message_payload\">message payload overview</a>. Here you would provide a string containing the name\nof the AMQP address on the server to which recipients should direct their responses, typically a named queue to which\nyou have already established a consumer to receive the replies. This route may be necessary if you need to receive\nmultiple replies to a given sent AMQP message.</p>\n</div>\n<div class=\"paragraph\">\n<p>With the second option a reply <code>Handler</code> may also be given in addition to the message payload\nwhen sending a message, to be registered such that it is invoked when a [single] response message is received for the\nmessage being sent.</p>\n</div>\n<div class=\"paragraph\">\n<p>To facilitate this, upon startup the bridge internally creates a consumer from a server-named dynamic address, the\nname of which it then uses as the reply-to address on any AMQP messages sent when a replyHandler was given. The\nbridge also populates the <em>message-id</em> of the outgoing AMQP message, and uses this value to keep track of the reply\nhandler. Incoming messages on the internal 'reply consumer' have their <em>correlation-id</em> values inspected in order to\nmatch them to the reply handler originally given, requiring that reply senders populate the <em>correlation-id</em> field\nwith the <em>message-id</em> of the original message.</p>\n</div>\n<div class=\"paragraph\">\n<p>The following shows the process for the second option:</p>\n</div>\n<div class=\"imageblock text-center\">\n<div class=\"content\">\n<img src=\"../../images/producer-reply-handler.png\" alt=\"producer reply handler\">\n</div>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>The producer is used to send a message to an AMQP address, providing a reply handler.</p>\n</li>\n<li>\n<p>The bridge send implementation populates the <em>reply-to</em> and <em>message-id</em> fields of the outgoing AMQP message,\nrecords the handler, and sends the message to the server.</p>\n</li>\n<li>\n<p>The receiving application (perhaps also a Vert.x AMQP bridge) consumes the message and sends\na reply to its <em>reply-to</em> address, setting its <em>correlation-id</em> field as the original messages <em>message-id</em>.</p>\n</li>\n<li>\n<p>The server dispatches the reply message to the internal 'reply consumer' of the bridge.</p>\n</li>\n<li>\n<p>The bridge processes the AMQP message, creating the Vert.x Message with JsonObject body, uses the <em>correlation-id</em>\nvalue to match it with the reply handler, and then invokes the handler with the reply message.</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>The following is a basic example of sending a message and providing a reply-handler to process the response:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> amqpMsgPayload = <span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>()\namqpMsgPayload.put(<span class=\"hljs-string\">&quot;body&quot;</span>, <span class=\"hljs-string\">&quot;myRequest&quot;</span>)\n\nproducer.sendFuture(amqpMsgPayload).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">&quot;Success&quot;</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_received_messages_seeking_a_reply\"><a class=\"anchor\" href=\"#_received_messages_seeking_a_reply\"></a>Received messages seeking a reply.</h3>\n<div class=\"paragraph\">\n<p>When a message arrives, its replyAddress may be inspected. If the AMQP message had its <em>reply-to</em> field populated,\nthen the address given will be returned from the Vert.x message replyAddress method. If no <em>reply-to</em> value was\npresent on the message, the value returned will be null.</p>\n</div>\n<div class=\"paragraph\">\n<p>There are two options when receiving messages to which responses are required:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Populate the AMQP reply-to address of an outgoing message sent explicitly using a producer.</p>\n</li>\n<li>\n<p>Send a reply using the Message reply method.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>With the first option, you may explicitly populate the \"reply_to\" element of the message \"properties\" section, as\noutlined in the <a href=\"#message_payload\">message payload overview</a>, and send it explicitly using a producer established\nto the address using the bridge.</p>\n</div>\n<div class=\"paragraph\">\n<p>With the second option, a reply message may be sent by calling the reply method on the Vert.x message\nobject. The reply method implementation ensures that the outgoing message <em>correlation-id</em> is populated appropriately\nusing the <em>message-id</em> of the original message, such that the response can be matched in the case the original\nmessage was sent from a Vert.x AMQP bridge producer with a reply handler provided.</p>\n</div>\n<div class=\"paragraph\">\n<p>The following outlines the process for both routes, of receiving a message sent by an application (not shown), and\nsending a reply:</p>\n</div>\n<div class=\"imageblock text-center\">\n<div class=\"content\">\n<img src=\"../../images/consumer-reply.png\" alt=\"consumer reply\">\n</div>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>The server sends an AMQP message to the consumer, with a reply-to value set to another address.</p>\n</li>\n<li>\n<p>The bridge processes the AMQP message, creating the Vert.x Message with JsonObject body. The Message replyAddress\nis set to the reply-to value from the AMQP message.</p>\n</li>\n<li>\n<p>The Message is passed to the consumer Handler, which processes it, inspecting the replyAddress and preparing to\nsend a response.</p>\n</li>\n<li>\n<p>The handler chooses to either send a reply using an explicit producer, or call the reply method on the message\nobject.</p>\n</li>\n<li>\n<p>The reply message arrives at the response address on the server, ready to be sent to a reply consumer for the\noriginal sending application .</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>The following is a basic example of sending a reply using the message reply method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">consumer.handler((msg: io.vertx.scala.core.eventbus.<span class=\"hljs-type\">Message</span>&lt;io.vertx.scala.core.json.<span class=\"hljs-type\">JsonObject</span>&gt;) =&gt; {\n  <span class=\"hljs-comment\">// ...do something with received message...then reply...</span>\n  <span class=\"hljs-keyword\">var</span> replyAddress = msg.replyAddress()\n  <span class=\"hljs-keyword\">if</span> (replyAddress != <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">var</span> amqpReplyMessagePayload = <span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>()\n    amqpReplyMessagePayload.put(<span class=\"hljs-string\">&quot;body&quot;</span>, <span class=\"hljs-string\">&quot;myResponse&quot;</span>)\n\n    msg.reply(amqpReplyMessagePayload)\n  }\n})</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"3.9.3"},"__N_SSG":true}