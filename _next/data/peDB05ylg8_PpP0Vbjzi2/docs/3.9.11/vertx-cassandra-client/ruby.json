{"pageProps":{"slug":"3.9.11/vertx-cassandra-client/ruby","title":"Cassandra Client for Vert.x","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">Getting started</a></li>\n<li><a href=\"#_creating_a_client\">Creating a client</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_client_options\">Client options</a></li>\n<li><a href=\"#_shared_clients\">Shared clients</a></li>\n<li><a href=\"#_client_lifecycle\">Client lifecycle</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_the_api\">Using the API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_querying\">Querying</a></li>\n<li><a href=\"#_collector_queries\">Collector queries</a></li>\n<li><a href=\"#_prepared_queries\">Prepared queries</a></li>\n<li><a href=\"#_batching\">Batching</a></li>\n<li><a href=\"#_object_mapper\">Object Mapper</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Cassandra Client for Vert.x</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>A Vert.x client allowing applications to interact with an <a href=\"http://cassandra.apache.org/\">Apache Cassandra</a> service.</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nThis module has <em>Tech Preview</em> status, this means the API can change between versions.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting started</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use this module, add the following to the <em>dependencies</em> section of your Maven POM file:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-cassandra-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.11<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or, if you use Gradle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-cassandra-client:3.9.11&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nThe Cassandra client is not compatible with the Vert.x Dropwizard Metrics library.\nBoth are using a different major version of the Dropwizard Metrics library and the Datastax Java driver <a href=\"https://github.com/datastax/java-driver/pull/943\">won&#8217;t upgrade</a> to the most recent version due to the drop of Java 7.\nThe next major version (4.x) of the driver will use a more recent Dropwizard Metrics library  version.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_client\"><a class=\"anchor\" href=\"#_creating_a_client\"></a>Creating a client</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_client_options\"><a class=\"anchor\" href=\"#_client_options\"></a>Client options</h3>\n<div class=\"paragraph\">\n<p>Cassandra is a distributed system, and it can have many nodes.\nTo connect to Cassandra you need to specify the addresses of some cluster nodes when creating a <code><a href=\"../dataobjects.html#CassandraClientOptions\">CassandraClientOptions</a></code> object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-cassandra/cassandra_client&#x27;</span>\noptions = {\n  <span class=\"hljs-string\">&#x27;contactPoints&#x27;</span> =&gt; [\n    <span class=\"hljs-string\">&quot;node1.address&quot;</span>,\n    <span class=\"hljs-string\">&quot;node2.address&quot;</span>,\n    <span class=\"hljs-string\">&quot;node3.address&quot;</span>\n  ]\n}\nclient = VertxCassandra::CassandraClient.create(vertx, options)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>By default, the Cassandra client for Vert.x connects to the local machine&#8217;s port <code>9042</code> and is not tied to any specific keyspace.\nBut you can set either or both of these options:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-cassandra/cassandra_client&#x27;</span>\noptions = {\n  <span class=\"hljs-string\">&#x27;port&#x27;</span> =&gt; <span class=\"hljs-number\">9142</span>,\n  <span class=\"hljs-string\">&#x27;keyspace&#x27;</span> =&gt; <span class=\"hljs-string\">&quot;my_keyspace&quot;</span>\n}\nclient = VertxCassandra::CassandraClient.create(vertx, options)</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nFor fine tuning purposes, <code><a href=\"../dataobjects.html#CassandraClientOptions\">CassandraClientOptions</a></code> exposes a <code>com.datastax.driver.core.Cluster.Builder</code> instance.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_shared_clients\"><a class=\"anchor\" href=\"#_shared_clients\"></a>Shared clients</h3>\n<div class=\"paragraph\">\n<p>If you deploy multiple instances of your verticle or have different verticles interacting with the same database, it is recommended to create a shared client:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-cassandra/cassandra_client&#x27;</span>\noptions = {\n  <span class=\"hljs-string\">&#x27;contactPoints&#x27;</span> =&gt; [\n    <span class=\"hljs-string\">&quot;node1.address&quot;</span>,\n    <span class=\"hljs-string\">&quot;node2.address&quot;</span>,\n    <span class=\"hljs-string\">&quot;node3.address&quot;</span>\n  ],\n  <span class=\"hljs-string\">&#x27;keyspace&#x27;</span> =&gt; <span class=\"hljs-string\">&quot;my_keyspace&quot;</span>\n}\nclient = VertxCassandra::CassandraClient.create_shared(vertx, <span class=\"hljs-string\">&quot;sharedClientName&quot;</span>, options)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Shared clients with the same name will use a single underlying <code>com.datastax.driver.core.Session</code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_client_lifecycle\"><a class=\"anchor\" href=\"#_client_lifecycle\"></a>Client lifecycle</h3>\n<div class=\"paragraph\">\n<p>After the client is created, it is not connected until the first query is executed.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nA shared client can be connected after creation if another client with the same name has already executed a query.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Clients created inside a verticle are automatically stopped when the verticle is undeployed.\nIn other words, you do not need to invoke <code><a href=\"../../yardoc/VertxCassandra/CassandraClient.html#close-instance_method\">close</a></code> in the verticle <code>stop</code> method.</p>\n</div>\n<div class=\"paragraph\">\n<p>In all other cases, you must manually close the client.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nWhen a shared client is closed, the driver dession is not closed if other clients with the same name are still running.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_api\"><a class=\"anchor\" href=\"#_using_the_api\"></a>Using the API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The client API is represented by <code><a href=\"../../yardoc/VertxCassandra/CassandraClient.html\">CassandraClient</a></code>.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_querying\"><a class=\"anchor\" href=\"#_querying\"></a>Querying</h3>\n<div class=\"paragraph\">\n<p>You can get query results using three different ways.</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming\"><a class=\"anchor\" href=\"#_streaming\"></a>Streaming</h4>\n<div class=\"paragraph\">\n<p>The streaming API is most appropriate when you need to consume results iteratively, e.g you want to process each item.\nThis is very efficient specially for large amount of rows.</p>\n</div>\n<div class=\"paragraph\">\n<p>In order to give you some inspiration and ideas on how you can use the API, we&#8217;d like to you to consider this example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">cassandraClient.query_stream(<span class=\"hljs-string\">&quot;SELECT my_string_col FROM my_keyspace.my_table where my_key = &#x27;my_value&#x27;&quot;</span>) { <span class=\"hljs-params\">|queryStream_err,queryStream|</span>\n  <span class=\"hljs-keyword\">if</span> (queryStream_err == <span class=\"hljs-literal\">nil</span>)\n    stream = queryStream\n\n    <span class=\"hljs-comment\"># resume stream when queue is ready to accept buffers again</span>\n    response.drain_handler() { <span class=\"hljs-params\">|v|</span>\n      stream.resume()\n    }\n\n    stream.handler() { <span class=\"hljs-params\">|row|</span>\n      value = row.get_string(<span class=\"hljs-string\">&quot;my_string_col&quot;</span>)\n      response.write(value)\n\n      <span class=\"hljs-comment\"># pause row stream when we buffer queue is full</span>\n      <span class=\"hljs-keyword\">if</span> (response.write_queue_full?())\n        stream.pause()\n      <span class=\"hljs-keyword\">end</span>\n    }\n\n    <span class=\"hljs-comment\"># end request when we reached end of the stream</span>\n    stream.end_handler() { <span class=\"hljs-params\">|<span class=\"hljs-keyword\">end</span>|</span>\n      response.<span class=\"hljs-keyword\">end</span>()\n    }\n\n  <span class=\"hljs-keyword\">else</span>\n    queryStream_err.print_stack_trace()\n    <span class=\"hljs-comment\"># response with internal server error if we are not able to execute given query</span>\n    response.set_status_code(<span class=\"hljs-number\">500</span>).<span class=\"hljs-keyword\">end</span>(<span class=\"hljs-string\">&quot;Unable to execute the query&quot;</span>)\n  <span class=\"hljs-keyword\">end</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In the example, we are executing a query, and stream results via HTTP.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_bulk_fetching\"><a class=\"anchor\" href=\"#_bulk_fetching\"></a>Bulk fetching</h4>\n<div class=\"paragraph\">\n<p>This API should be used when you need to process all the rows at the same time.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">cassandraClient.execute_with_full_fetch(<span class=\"hljs-string\">&quot;SELECT * FROM my_keyspace.my_table where my_key = &#x27;my_value&#x27;&quot;</span>) { <span class=\"hljs-params\">|executeWithFullFetch_err,executeWithFullFetch|</span>\n  <span class=\"hljs-keyword\">if</span> (executeWithFullFetch_err == <span class=\"hljs-literal\">nil</span>)\n    rows = executeWithFullFetch\n    rows.each <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|row|</span>\n      <span class=\"hljs-comment\"># handle each row here</span>\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">else</span>\n    puts <span class=\"hljs-string\">&quot;Unable to execute the query&quot;</span>\n    executeWithFullFetch_err.print_stack_trace()\n  <span class=\"hljs-keyword\">end</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Caution</div>\n</td>\n<td class=\"content\">\nUse bulk fetching only if you can afford to load the full result set in memory.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>Collector queries</h3>\n<div class=\"paragraph\">\n<p>You can use Java collectors with the query API:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">Code <span class=\"hljs-keyword\">not</span> translatable</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_low_level_fetch\"><a class=\"anchor\" href=\"#_low_level_fetch\"></a>Low level fetch</h4>\n<div class=\"paragraph\">\n<p>This API provides greater control over loading at the expense of being a bit lower-level than the streaming and bulk fetching APIs.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">cassandraClient.execute(<span class=\"hljs-string\">&quot;SELECT * FROM my_keyspace.my_table where my_key = &#x27;my_value&#x27;&quot;</span>) { <span class=\"hljs-params\">|execute_err,execute|</span>\n  <span class=\"hljs-keyword\">if</span> (execute_err == <span class=\"hljs-literal\">nil</span>)\n    resultSet = execute\n\n    resultSet.one() { <span class=\"hljs-params\">|one_err,one|</span>\n      <span class=\"hljs-keyword\">if</span> (one_err == <span class=\"hljs-literal\">nil</span>)\n        row = one\n        puts <span class=\"hljs-string\">&quot;One row successfully fetched&quot;</span>\n      <span class=\"hljs-keyword\">else</span>\n        puts <span class=\"hljs-string\">&quot;Unable to fetch a row&quot;</span>\n        one_err.print_stack_trace()\n      <span class=\"hljs-keyword\">end</span>\n    }\n\n    resultSet.fetch_more_results() { <span class=\"hljs-params\">|fetchMoreResults_err,fetchMoreResults|</span>\n      <span class=\"hljs-keyword\">if</span> (fetchMoreResults_err == <span class=\"hljs-literal\">nil</span>)\n        availableWithoutFetching = resultSet.get_available_without_fetching()\n        puts <span class=\"hljs-string\">&quot;Now we have <span class=\"hljs-subst\">#{availableWithoutFetching}</span> rows fetched, but not consumed!&quot;</span>\n        <span class=\"hljs-keyword\">if</span> (resultSet.fully_fetched?())\n          puts <span class=\"hljs-string\">&quot;The result is fully fetched, we don&#x27;t need to call this method for one more time!&quot;</span>\n        <span class=\"hljs-keyword\">else</span>\n          puts <span class=\"hljs-string\">&quot;The result still does not fully fetched&quot;</span>\n        <span class=\"hljs-keyword\">end</span>\n      <span class=\"hljs-keyword\">else</span>\n        puts <span class=\"hljs-string\">&quot;Unable to fetch more results&quot;</span>\n        fetchMoreResults_err.print_stack_trace()\n      <span class=\"hljs-keyword\">end</span>\n    }\n\n  <span class=\"hljs-keyword\">else</span>\n    puts <span class=\"hljs-string\">&quot;Unable to execute the query&quot;</span>\n    execute_err.print_stack_trace()\n  <span class=\"hljs-keyword\">end</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>Prepared queries</h3>\n<div class=\"paragraph\">\n<p>For security and efficiency reasons, it is a good idea to use prepared statements for all the queries you are using more than once.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can prepare a query:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">cassandraClient.prepare(<span class=\"hljs-string\">&quot;SELECT * FROM my_keyspace.my_table where my_key = ? &quot;</span>) { <span class=\"hljs-params\">|preparedStatementResult_err,preparedStatementResult|</span>\n  <span class=\"hljs-keyword\">if</span> (preparedStatementResult_err == <span class=\"hljs-literal\">nil</span>)\n    puts <span class=\"hljs-string\">&quot;The query has successfully been prepared&quot;</span>\n    preparedStatement = preparedStatementResult\n    <span class=\"hljs-comment\"># now you can use this PreparedStatement object for the next queries</span>\n  <span class=\"hljs-keyword\">else</span>\n    puts <span class=\"hljs-string\">&quot;Unable to prepare the query&quot;</span>\n    preparedStatementResult_err.print_stack_trace()\n  <span class=\"hljs-keyword\">end</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>And then use the <a href=\"https://docs.datastax.com/en/drivers/java/3.5/com/datastax/driver/core/PreparedStatement.html\"><code>PreparedStatement</code></a> for all the next queries:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-comment\"># You can execute you prepared statement using any way to execute queries.</span>\n\n<span class=\"hljs-comment\"># Low level fetch API</span>\ncassandraClient.execute(preparedStatement.bind(<span class=\"hljs-string\">&quot;my_value&quot;</span>)) { <span class=\"hljs-params\">|done_err,done|</span>\n  results = done\n  <span class=\"hljs-comment\"># handle results here</span>\n}\n\n<span class=\"hljs-comment\"># Bulk fetching API</span>\ncassandraClient.execute_with_full_fetch(preparedStatement.bind(<span class=\"hljs-string\">&quot;my_value&quot;</span>)) { <span class=\"hljs-params\">|done_err,done|</span>\n  results = done\n  <span class=\"hljs-comment\"># handle results here</span>\n}\n\n<span class=\"hljs-comment\"># Streaming API</span>\ncassandraClient.query_stream(preparedStatement.bind(<span class=\"hljs-string\">&quot;my_value&quot;</span>)) { <span class=\"hljs-params\">|done_err,done|</span>\n  results = done\n  <span class=\"hljs-comment\"># handle results here</span>\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batching\"><a class=\"anchor\" href=\"#_batching\"></a>Batching</h3>\n<div class=\"paragraph\">\n<p>In case you&#8217;d like to execute several queries at once, you can use <a href=\"https://docs.datastax.com/en/drivers/java/3.5/com/datastax/driver/core/BatchStatement.html\"><code>BatchStatement</code></a> for that:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">batchStatement = Java::ComDatastaxDriverCore::BatchStatement.new().add(Java::ComDatastaxDriverCore::SimpleStatement.new(<span class=\"hljs-string\">&quot;INSERT INTO NAMES (name) VALUES (&#x27;Pavel&#x27;)&quot;</span>)).add(Java::ComDatastaxDriverCore::SimpleStatement.new(<span class=\"hljs-string\">&quot;INSERT INTO NAMES (name) VALUES (&#x27;Thomas&#x27;)&quot;</span>)).add(Java::ComDatastaxDriverCore::SimpleStatement.new(<span class=\"hljs-string\">&quot;INSERT INTO NAMES (name) VALUES (&#x27;Julien&#x27;)&quot;</span>))\n\ncassandraClient.execute(batchStatement) { <span class=\"hljs-params\">|result_err,result|</span>\n  <span class=\"hljs-keyword\">if</span> (result_err == <span class=\"hljs-literal\">nil</span>)\n    puts <span class=\"hljs-string\">&quot;The given batch executed successfully&quot;</span>\n  <span class=\"hljs-keyword\">else</span>\n    puts <span class=\"hljs-string\">&quot;Unable to execute the batch&quot;</span>\n    result_err.print_stack_trace()\n  <span class=\"hljs-keyword\">end</span>\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_object_mapper\"><a class=\"anchor\" href=\"#_object_mapper\"></a>Object Mapper</h3>\n<div class=\"paragraph\">\n<p>You can use the object <code><a href=\"../../yardoc/VertxCassandra/Mapper.html\">Mapper</a></code> to map between domain classes and queries.</p>\n</div>\n<div class=\"paragraph\">\n<p>First, add the following to the <em>dependencies</em> section of your Maven POM file:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.datastax.cassandra<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>cassandra-driver-mapping<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or, if you use Gradle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;com.datastax.cassandra:cassandra-driver-mapping:3.5.0&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Consider the following entity:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Table(keyspace = &quot;test&quot;, name = &quot;names&quot;)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MappedClass</span> </span>{\n <span class=\"hljs-meta\">@PartitionKey</span>\n <span class=\"hljs-keyword\">private</span> String name;\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MappedClass</span><span class=\"hljs-params\">(String name)</span> </span>{\n   <span class=\"hljs-keyword\">this</span>.name = name;\n }\n\n MappedClass() {\n   <span class=\"hljs-comment\">// Required for mapping</span>\n }\n\n <span class=\"hljs-comment\">// getters / setters</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Create a mapper for it and you may save, retrieve or delete data from the corresponding table:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-cassandra/mapping_manager&#x27;</span>\nmappingManager = VertxCassandra::MappingManager.create(cassandraClient)\nmapper = mappingManager.mapper(Java::ExamplesCassandraClientExamples::MappedClass::<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>)</span>\n\nvalue = Java::ExamplesCassandraClientExamples::MappedClass.new(<span class=\"hljs-string\">&quot;foo&quot;</span>)\n\nmapper.save(value) { <span class=\"hljs-params\">|handler_err,handler|</span>\n  <span class=\"hljs-comment\"># Entity saved</span>\n}\n\nmapper.get(Java::JavaUtil::Collections.singleton_list(<span class=\"hljs-string\">&quot;foo&quot;</span>)) { <span class=\"hljs-params\">|handler_err,handler|</span>\n  <span class=\"hljs-comment\"># Entity loaded</span>\n}\n\nmapper.delete(Java::JavaUtil::Collections.singleton_list(<span class=\"hljs-string\">&quot;foo&quot;</span>)) { <span class=\"hljs-params\">|handler_err,handler|</span>\n  <span class=\"hljs-comment\"># Entity deleted</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nIt is safe to reuse mapping manager and mapper instances for a given Cassandra client.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>","version":"3.9.11"},"__N_SSG":true}