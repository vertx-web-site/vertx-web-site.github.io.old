{"pageProps":{"slug":"vertx-cassandra-client/java","title":"Cassandra Client for Vert.x","fallbackGitHubStars":30,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">Getting started</a></li>\n<li><a href=\"#_creating_a_client\">Creating a client</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_client_options\">Client options</a></li>\n<li><a href=\"#_shared_clients\">Shared clients</a></li>\n<li><a href=\"#_client_lifecycle\">Client lifecycle</a></li>\n</ul>\n</li>\n<li><a href=\"#_using_the_api\">Using the API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_querying\">Querying</a></li>\n<li><a href=\"#_collector_queries\">Collector queries</a></li>\n<li><a href=\"#_prepared_queries\">Prepared queries</a></li>\n<li><a href=\"#_batching\">Batching</a></li>\n</ul>\n</li>\n<li><a href=\"#_tracing_queries\">Tracing queries</a></li>\n<li><a href=\"#_rxjava_3_api\">RxJava 3 API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_creating_an_rxified_client\">Creating an Rxified client</a></li>\n<li><a href=\"#_querying_2\">Querying</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Cassandra Client for Vert.x</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>A Vert.x client allowing applications to interact with an <a href=\"http://cassandra.apache.org/\">Apache Cassandra</a> service.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting started</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use this module, add the following to the <em>dependencies</em> section of your Maven POM file:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-cassandra-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.3.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or, if you use Gradle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-cassandra-client:4.3.0&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_client\"><a class=\"anchor\" href=\"#_creating_a_client\"></a>Creating a client</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_client_options\"><a class=\"anchor\" href=\"#_client_options\"></a>Client options</h3>\n<div class=\"paragraph\">\n<p>Cassandra is a distributed system, and it can have many nodes.\nTo connect to Cassandra you need to specify the addresses of some cluster nodes when creating a <code><a href=\"../../apidocs/io/vertx/cassandra/CassandraClientOptions.html\">CassandraClientOptions</a></code> object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CassandraClientOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CassandraClientOptions</span>()\n  .addContactPoint(<span class=\"hljs-string\">&quot;node1.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node2.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node3.address&quot;</span>, <span class=\"hljs-number\">9142</span>);\n<span class=\"hljs-type\">CassandraClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> CassandraClient.create(vertx, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>By default, the Cassandra client for Vert.x connects to the local machine&#8217;s port <code>9042</code> and is not tied to any specific keyspace.\nBut you can set either or both of these options:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CassandraClientOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CassandraClientOptions</span>()\n  .addContactPoint(<span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .setKeyspace(<span class=\"hljs-string\">&quot;my_keyspace&quot;</span>);\n<span class=\"hljs-type\">CassandraClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> CassandraClient.create(vertx, options);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nFor fine tuning purposes, <code><a href=\"../../apidocs/io/vertx/cassandra/CassandraClientOptions.html\">CassandraClientOptions</a></code> exposes a <code>com.datastax.driver.core.Cluster.Builder</code> instance.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_shared_clients\"><a class=\"anchor\" href=\"#_shared_clients\"></a>Shared clients</h3>\n<div class=\"paragraph\">\n<p>If you deploy multiple instances of your verticle or have different verticles interacting with the same database, it is recommended to create a shared client:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CassandraClientOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CassandraClientOptions</span>()\n  .addContactPoint(<span class=\"hljs-string\">&quot;node1.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node2.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node3.address&quot;</span>, <span class=\"hljs-number\">9142</span>)\n  .setKeyspace(<span class=\"hljs-string\">&quot;my_keyspace&quot;</span>);\n<span class=\"hljs-type\">CassandraClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> CassandraClient.createShared(vertx, <span class=\"hljs-string\">&quot;sharedClientName&quot;</span>, options);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Shared clients with the same name will use a single underlying <code>com.datastax.driver.core.Session</code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_client_lifecycle\"><a class=\"anchor\" href=\"#_client_lifecycle\"></a>Client lifecycle</h3>\n<div class=\"paragraph\">\n<p>After the client is created, it is not connected until the first query is executed.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nA shared client can be connected after creation if another client with the same name has already executed a query.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Clients created inside a verticle are automatically stopped when the verticle is undeployed.\nIn other words, you do not need to invoke <code><a href=\"../../apidocs/io/vertx/cassandra/CassandraClient.html#close--\">close</a></code> in the verticle <code>stop</code> method.</p>\n</div>\n<div class=\"paragraph\">\n<p>In all other cases, you must manually close the client.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nWhen a shared client is closed, the driver dession is not closed if other clients with the same name are still running.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_the_api\"><a class=\"anchor\" href=\"#_using_the_api\"></a>Using the API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The client API is represented by <code><a href=\"../../apidocs/io/vertx/cassandra/CassandraClient.html\">CassandraClient</a></code>.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_querying\"><a class=\"anchor\" href=\"#_querying\"></a>Querying</h3>\n<div class=\"paragraph\">\n<p>You can get query results using three different ways.</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming\"><a class=\"anchor\" href=\"#_streaming\"></a>Streaming</h4>\n<div class=\"paragraph\">\n<p>The streaming API is most appropriate when you need to consume results iteratively, e.g you want to process each item.\nThis is very efficient specially for large amount of rows.</p>\n</div>\n<div class=\"paragraph\">\n<p>In order to give you some inspiration and ideas on how you can use the API, we&#8217;d like to you to consider this example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.queryStream(<span class=\"hljs-string\">&quot;SELECT my_string_col FROM my_keyspace.my_table where my_key = &#x27;my_value&#x27;&quot;</span>, queryStream -&gt; {\n  <span class=\"hljs-keyword\">if</span> (queryStream.succeeded()) {\n    <span class=\"hljs-type\">CassandraRowStream</span> <span class=\"hljs-variable\">stream</span> <span class=\"hljs-operator\">=</span> queryStream.result();\n\n    <span class=\"hljs-comment\">// resume stream when queue is ready to accept buffers again</span>\n    response.drainHandler(v -&gt; stream.resume());\n\n    stream.handler(row -&gt; {\n      <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">value</span> <span class=\"hljs-operator\">=</span> row.getString(<span class=\"hljs-string\">&quot;my_string_col&quot;</span>);\n      response.write(value);\n\n      <span class=\"hljs-comment\">// pause row stream when we buffer queue is full</span>\n      <span class=\"hljs-keyword\">if</span> (response.writeQueueFull()) {\n        stream.pause();\n      }\n    });\n\n    <span class=\"hljs-comment\">// end request when we reached end of the stream</span>\n    stream.endHandler(end -&gt; response.end());\n\n  } <span class=\"hljs-keyword\">else</span> {\n    queryStream.cause().printStackTrace();\n    <span class=\"hljs-comment\">// response with internal server error if we are not able to execute given query</span>\n    response\n      .setStatusCode(<span class=\"hljs-number\">500</span>)\n      .end(<span class=\"hljs-string\">&quot;Unable to execute the query&quot;</span>);\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In the example, we are executing a query, and stream results via HTTP.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_bulk_fetching\"><a class=\"anchor\" href=\"#_bulk_fetching\"></a>Bulk fetching</h4>\n<div class=\"paragraph\">\n<p>This API should be used when you need to process all the rows at the same time.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.executeWithFullFetch(<span class=\"hljs-string\">&quot;SELECT * FROM my_keyspace.my_table where my_key = &#x27;my_value&#x27;&quot;</span>, executeWithFullFetch -&gt; {\n  <span class=\"hljs-keyword\">if</span> (executeWithFullFetch.succeeded()) {\n    List&lt;Row&gt; rows = executeWithFullFetch.result();\n    <span class=\"hljs-keyword\">for</span> (Row row : rows) {\n      <span class=\"hljs-comment\">// handle each row here</span>\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Unable to execute the query&quot;</span>);\n    executeWithFullFetch.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Caution</div>\n</td>\n<td class=\"content\">\nUse bulk fetching only if you can afford to load the full result set in memory.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_collector_queries\"><a class=\"anchor\" href=\"#_collector_queries\"></a>Collector queries</h3>\n<div class=\"paragraph\">\n<p>You can use Java collectors with the query API:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.execute(<span class=\"hljs-string\">&quot;SELECT * FROM users&quot;</span>, listCollector, ar -&gt; {\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Get the string created by the collector</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">list</span> <span class=\"hljs-operator\">=</span> ar.result();\n    System.out.println(<span class=\"hljs-string\">&quot;Got &quot;</span> + list);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Failure: &quot;</span> + ar.cause().getMessage());\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_low_level_fetch\"><a class=\"anchor\" href=\"#_low_level_fetch\"></a>Low level fetch</h4>\n<div class=\"paragraph\">\n<p>This API provides greater control over loading at the expense of being a bit lower-level than the streaming and bulk fetching APIs.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.execute(<span class=\"hljs-string\">&quot;SELECT * FROM my_keyspace.my_table where my_key = &#x27;my_value&#x27;&quot;</span>, execute -&gt; {\n  <span class=\"hljs-keyword\">if</span> (execute.succeeded()) {\n    <span class=\"hljs-type\">ResultSet</span> <span class=\"hljs-variable\">resultSet</span> <span class=\"hljs-operator\">=</span> execute.result();\n\n    <span class=\"hljs-keyword\">if</span> (resultSet.remaining() != <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-type\">Row</span> <span class=\"hljs-variable\">row</span> <span class=\"hljs-operator\">=</span> resultSet.one();\n      System.out.println(<span class=\"hljs-string\">&quot;One row successfully fetched&quot;</span>);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!resultSet.hasMorePages()) {\n      System.out.println(<span class=\"hljs-string\">&quot;No pages to fetch&quot;</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      resultSet.fetchNextPage().onComplete(fetchMoreResults -&gt; {\n        <span class=\"hljs-keyword\">if</span> (fetchMoreResults.succeeded()) {\n          <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">availableWithoutFetching</span> <span class=\"hljs-operator\">=</span> resultSet.remaining();\n          System.out.println(<span class=\"hljs-string\">&quot;Now we have &quot;</span> + availableWithoutFetching + <span class=\"hljs-string\">&quot; rows fetched, but not consumed!&quot;</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n          System.out.println(<span class=\"hljs-string\">&quot;Unable to fetch more results&quot;</span>);\n          fetchMoreResults.cause().printStackTrace();\n        }\n      });\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Unable to execute the query&quot;</span>);\n    execute.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_prepared_queries\"><a class=\"anchor\" href=\"#_prepared_queries\"></a>Prepared queries</h3>\n<div class=\"paragraph\">\n<p>For security and efficiency reasons, it is a good idea to use prepared statements for all the queries you are using more than once.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can prepare a query:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.prepare(<span class=\"hljs-string\">&quot;SELECT * FROM my_keyspace.my_table where my_key = ? &quot;</span>, preparedStatementResult -&gt; {\n  <span class=\"hljs-keyword\">if</span> (preparedStatementResult.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;The query has successfully been prepared&quot;</span>);\n    <span class=\"hljs-type\">PreparedStatement</span> <span class=\"hljs-variable\">preparedStatement</span> <span class=\"hljs-operator\">=</span> preparedStatementResult.result();\n    <span class=\"hljs-comment\">// now you can use this PreparedStatement object for the next queries</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Unable to prepare the query&quot;</span>);\n    preparedStatementResult.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>And then use the <a href=\"https://docs.datastax.com/en/drivers/java/${datastax.driver.minor.version}/com/datastax/driver/core/PreparedStatement.html\"><code>PreparedStatement</code></a> for all the next queries:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.execute(preparedStatement.bind(<span class=\"hljs-string\">&quot;my_value&quot;</span>), done -&gt; {\n  <span class=\"hljs-type\">ResultSet</span> <span class=\"hljs-variable\">results</span> <span class=\"hljs-operator\">=</span> done.result();\n  <span class=\"hljs-comment\">// handle results here</span>\n});\n\n<span class=\"hljs-comment\">// Bulk fetching API</span>\ncassandraClient.executeWithFullFetch(preparedStatement.bind(<span class=\"hljs-string\">&quot;my_value&quot;</span>), done -&gt; {\n  List&lt;Row&gt; results = done.result();\n  <span class=\"hljs-comment\">// handle results here</span>\n});\n\n<span class=\"hljs-comment\">// Streaming API</span>\ncassandraClient.queryStream(preparedStatement.bind(<span class=\"hljs-string\">&quot;my_value&quot;</span>), done -&gt; {\n  <span class=\"hljs-type\">CassandraRowStream</span> <span class=\"hljs-variable\">results</span> <span class=\"hljs-operator\">=</span> done.result();\n  <span class=\"hljs-comment\">// handle results here</span>\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_batching\"><a class=\"anchor\" href=\"#_batching\"></a>Batching</h3>\n<div class=\"paragraph\">\n<p>In case you&#8217;d like to execute several queries at once, you can use <a href=\"https://docs.datastax.com/en/drivers/java/${datastax.driver.minor.version}/com/datastax/driver/core/BatchStatement.html\"><code>BatchStatement</code></a> for that:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">BatchStatement</span> <span class=\"hljs-variable\">batchStatement</span> <span class=\"hljs-operator\">=</span> BatchStatement.newInstance(BatchType.LOGGED)\n  .add(SimpleStatement.newInstance(<span class=\"hljs-string\">&quot;INSERT INTO NAMES (name) VALUES (&#x27;Pavel&#x27;)&quot;</span>))\n  .add(SimpleStatement.newInstance(<span class=\"hljs-string\">&quot;INSERT INTO NAMES (name) VALUES (&#x27;Thomas&#x27;)&quot;</span>))\n  .add(SimpleStatement.newInstance(<span class=\"hljs-string\">&quot;INSERT INTO NAMES (name) VALUES (&#x27;Julien&#x27;)&quot;</span>));\n\ncassandraClient.execute(batchStatement, result -&gt; {\n  <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n    System.out.println(<span class=\"hljs-string\">&quot;The given batch executed successfully&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    System.out.println(<span class=\"hljs-string\">&quot;Unable to execute the batch&quot;</span>);\n    result.cause().printStackTrace();\n  }\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_tracing_queries\"><a class=\"anchor\" href=\"#_tracing_queries\"></a>Tracing queries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Cassandra Client can trace query execution when Vert.x has tracing enabled.</p>\n</div>\n<div class=\"paragraph\">\n<p>The client reports the following <em>client</em> spans:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Query</code> operation name</p>\n</li>\n<li>\n<p>tags</p>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>peer.address</code>: list of nodes known to the driver, in the form <code>[127_0_0_1:9042,localhost:9042,myhost_mydomain:9042]</code></p>\n</li>\n<li>\n<p><code>span.kind</code>: <code>client</code></p>\n</li>\n<li>\n<p><code>db.instance</code>: the keyspace</p>\n</li>\n<li>\n<p><code>db.statement</code>: the CQL query</p>\n</li>\n<li>\n<p><code>db.type</code>: <code>cassandra</code></p>\n</li>\n</ul>\n</div>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The default tracing policy is <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#PROPAGATE\">PROPAGATE</a></code>, the client will only create a span when involved in an active trace.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can change the client policy with <code><a href=\"../../apidocs/io/vertx/cassandra/CassandraClientOptions.html#setTracingPolicy-io.vertx.core.tracing.TracingPolicy-\">setTracingPolicy</a></code>.\nFor example, you can set <code><a href=\"../../apidocs/io/vertx/core/tracing/TracingPolicy.html#ALWAYS\">ALWAYS</a></code> to always report a span:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CassandraClientOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CassandraClientOptions</span>()\n  .setTracingPolicy(TracingPolicy.ALWAYS);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxjava_3_api\"><a class=\"anchor\" href=\"#_rxjava_3_api\"></a>RxJava 3 API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Cassandra client provides an Rxified version of the original API.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_creating_an_rxified_client\"><a class=\"anchor\" href=\"#_creating_an_rxified_client\"></a>Creating an Rxified client</h3>\n<div class=\"paragraph\">\n<p>To create an Rxified Cassandra client, make sure to import the <code><a href=\"../../apidocs/io/vertx/rxjava3/cassandra/CassandraClient.html\">CassandraClient</a></code> class.\nThen use one of the <code>create</code> methods to get an instance:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">CassandraClientOptions</span> <span class=\"hljs-variable\">options</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CassandraClientOptions</span>()\n  .addContactPoint(<span class=\"hljs-string\">&quot;node1.corp.int&quot;</span>, <span class=\"hljs-number\">7000</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node2.corp.int&quot;</span>, <span class=\"hljs-number\">7000</span>)\n  .addContactPoint(<span class=\"hljs-string\">&quot;node3.corp.int&quot;</span>, <span class=\"hljs-number\">7000</span>);\n<span class=\"hljs-type\">CassandraClient</span> <span class=\"hljs-variable\">cassandraClient</span> <span class=\"hljs-operator\">=</span> CassandraClient.createShared(vertx, options);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_querying_2\"><a class=\"anchor\" href=\"#_querying_2\"></a>Querying</h3>\n<div class=\"paragraph\">\n<p>In this section, we will reconsider some of the previous use cases with the Rxified API.</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_streaming_2\"><a class=\"anchor\" href=\"#_streaming_2\"></a>Streaming</h4>\n<div class=\"paragraph\">\n<p>A <code><a href=\"../../apidocs/io/vertx/rxjava3/cassandra/CassandraRowStream.html\">CassandraRowStream</a></code> can be converted to a <code><a href=\"../../apidocs/io/reactivex/rxjava3/core/Flowable.html\">Flowable</a></code>, which is handy when you have to deal with large data sets:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.rxQueryStream(<span class=\"hljs-string\">&quot;SELECT my_key FROM my_keyspace.my_table where my_key = my_value&quot;</span>)\n  <span class=\"hljs-comment\">// Convert the stream to a Flowable</span>\n  .flatMapPublisher(CassandraRowStream::toFlowable)\n  .subscribe(row -&gt; {\n    <span class=\"hljs-comment\">// Handle single row</span>\n  }, t -&gt; {\n    <span class=\"hljs-comment\">// Handle failure</span>\n  }, () -&gt; {\n    <span class=\"hljs-comment\">// End of stream</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_bulk_fetching_2\"><a class=\"anchor\" href=\"#_bulk_fetching_2\"></a>Bulk fetching</h4>\n<div class=\"paragraph\">\n<p>When your data set is small, it might be easier to get all results at once:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">cassandraClient.rxExecuteWithFullFetch(<span class=\"hljs-string\">&quot;SELECT my_key FROM my_keyspace.my_table where my_key = my_value&quot;</span>)\n  .subscribe(rows -&gt; {\n    <span class=\"hljs-comment\">// Handle list of rows</span>\n  }, throwable -&gt; {\n    <span class=\"hljs-comment\">// Handle failure</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>"},"__N_SSG":true}