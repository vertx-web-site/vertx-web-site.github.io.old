{"pageProps":{"slug":"4.1.5/vertx-redis-client/java","title":"Vert.x-redis","fallbackGitHubStars":109,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_redis\">Using Vert.x-Redis</a></li>\n<li><a href=\"#_connecting_to_redis\">Connecting to Redis</a></li>\n<li><a href=\"#_connection_string\">Connection String</a></li>\n<li><a href=\"#_running_commands\">Running commands</a></li>\n<li><a href=\"#_high_availability_mode\">High Availability mode</a></li>\n<li><a href=\"#_cluster_mode\">Cluster mode</a></li>\n<li><a href=\"#_pubsub_mode\">Pub/Sub mode</a></li>\n<li><a href=\"#_domain_sockets\">Domain Sockets</a></li>\n<li><a href=\"#_connection_pooling\">Connection Pooling</a></li>\n<li><a href=\"#_implementing_reconnect_on_error\">Implementing Reconnect on Error</a></li>\n<li><a href=\"#_protocol_parser\">Protocol Parser</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x-redis</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x-redis is redis client to be used with Vert.x.</p>\n</div>\n<div class=\"paragraph\">\n<p>This module allows data to be saved, retrieved, searched for, and deleted in a Redis. Redis is an open source, advanced\nkey-value store. It is often referred to as a data structure server since keys can contain  strings, hashes, lists, sets\nand sorted sets. To use this module you must have a Redis server instance running on your network.</p>\n</div>\n<div class=\"paragraph\">\n<p>Redis has a rich API and it can be organized in the following groups:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Cluster - Commands related to cluster management, note that using most of these commands you will need a redis server with version &gt;=3.0.0</p>\n</li>\n<li>\n<p>Connection - Commands that allow you to switch DBs, connect, disconnect and authenticate to a server.</p>\n</li>\n<li>\n<p>Hashes - Commands that allow operations on hashes.</p>\n</li>\n<li>\n<p>HyperLogLog - Commands to approximating the number of distinct elements in a multiset, a HyperLogLog.</p>\n</li>\n<li>\n<p>Keys - Commands to work with Keys.</p>\n</li>\n<li>\n<p>List - Commands to work with Lists.</p>\n</li>\n<li>\n<p>Pub/Sub - Commands to create queues and pub/sub clients.</p>\n</li>\n<li>\n<p>Scripting - Commands to run Lua Scripts in redis.</p>\n</li>\n<li>\n<p>Server - Commands to manage and get server configurations.</p>\n</li>\n<li>\n<p>Sets - Commands to work with un ordered sets.</p>\n</li>\n<li>\n<p>Sorted Sets - Commands to work with sorted sets.</p>\n</li>\n<li>\n<p>Strings - Commands to work with Strings.</p>\n</li>\n<li>\n<p>Transactions - Commands to handle transaction lifecycle.</p>\n</li>\n<li>\n<p>Streams - Commands to handle streaming.</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_redis\"><a class=\"anchor\" href=\"#_using_vert_x_redis\"></a>Using Vert.x-Redis</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use the Vert.x Redis client, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-redis-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-redis-client:4.1.5&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connecting_to_redis\"><a class=\"anchor\" href=\"#_connecting_to_redis\"></a>Connecting to Redis</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Redis client can operate in 3 distinct modes:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Simple client (probably what most users need).</p>\n</li>\n<li>\n<p>Sentinel (when working with Redis in High Availability mode).</p>\n</li>\n<li>\n<p>Cluster (when working with Redis in Clustered mode).</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The connection mode is selected by the factory method on the Redis interface. Regardless of the mode the client can be\nconfigured using a <code><a href=\"../../apidocs/io/vertx/redis/client/RedisOptions.html\">RedisOptions</a></code> data object. By default, some configuration values are\ninitialized with the following values:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>netClientOptions</code>: default is <code>TcpKeepAlive: true</code>, <code>TcpNoDelay: true</code></p>\n</li>\n<li>\n<p><code>endpoint</code>: default is <code>redis://localhost:6379</code></p>\n</li>\n<li>\n<p><code>masterName</code>: default is <code>mymaster</code></p>\n</li>\n<li>\n<p><code>role</code> default is <code>MASTER</code></p>\n</li>\n<li>\n<p><code>useReplicas</code> default is <code>NEVER</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>In order to obtain a connection use the following code:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(vertx)\n  .connect()\n  .onSuccess(conn -&gt; {\n    <span class=\"hljs-comment\">// use the connection</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In the configuration contains a <code>password</code> and/or a <code>select</code> database, these 2 commands will be executed automatically\nonce a successful connection is established to the server.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(\n  vertx,\n  <span class=\"hljs-comment\">// The client handles REDIS URLs. The select database as per spec is the</span>\n  <span class=\"hljs-comment\">// numerical path of the URL and the password is the password field of</span>\n  <span class=\"hljs-comment\">// the URL authority</span>\n  <span class=\"hljs-string\">&quot;redis://:abracadabra@localhost:6379/1&quot;</span>)\n  .connect()\n  .onSuccess(conn -&gt; {\n    <span class=\"hljs-comment\">// use the connection</span>\n  });</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connection_string\"><a class=\"anchor\" href=\"#_connection_string\"></a>Connection String</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The client will recognize addresses that follow the expression:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>redis://[:password@]host[:port][/db-number]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>unix://[:password@]/domain/docker.sock[?select=db-number]</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When specifying a password or a database those commands are always executed on connection start.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_running_commands\"><a class=\"anchor\" href=\"#_running_commands\"></a>Running commands</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Given that the redis client is connected to the server, all commands are now possible to execute using this module.\nThe module offers a clean API for executing commands without the need to hand write the command itself, for example\nif one wants to get a value of a key it can be done as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RedisAPI redis = RedisAPI.api(client);\n\nredis\n  .get(<span class=\"hljs-string\">&quot;mykey&quot;</span>)\n  .onSuccess(value -&gt; {\n    <span class=\"hljs-comment\">// do something...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The response object is a generic type that allow converting from the basic redis types to your language types. For\nexample, if your response is of type <code>INTEGER</code> then you can get the value as any numeric primitive type <code>int</code>, <code>long</code>,\netc&#8230;&#8203;</p>\n</div>\n<div class=\"paragraph\">\n<p>Or you can perform more complex tasks such as handling responses as iterators:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">if</span> (response.type() == ResponseType.MULTI) {\n  <span class=\"hljs-keyword\">for</span> (Response item : response) {\n    <span class=\"hljs-comment\">// do something with item...</span>\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_high_availability_mode\"><a class=\"anchor\" href=\"#_high_availability_mode\"></a>High Availability mode</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To work with high availability mode the connection creation is quite similar:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> RedisOptions()\n    .setType(RedisClientType.SENTINEL)\n    .addConnectionString(<span class=\"hljs-string\">&quot;redis://127.0.0.1:5000&quot;</span>)\n    .addConnectionString(<span class=\"hljs-string\">&quot;redis://127.0.0.1:5001&quot;</span>)\n    .addConnectionString(<span class=\"hljs-string\">&quot;redis://127.0.0.1:5002&quot;</span>)\n    .setMasterName(<span class=\"hljs-string\">&quot;sentinel7000&quot;</span>)\n    .setRole(RedisRole.MASTER))\n  .connect()\n  .onSuccess(conn -&gt; {\n    conn.send(Request.cmd(Command.INFO))\n      .onSuccess(info -&gt; {\n        <span class=\"hljs-comment\">// do something...</span>\n      });\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>What is important to notice is that in this mode, an extra connection is established to the server(s) and behind the\nscenes the client will listen for events from the sentinel. When the sentinel notifies that we switched masters, then\nan exception is send to the client and you can decide what to do next.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cluster_mode\"><a class=\"anchor\" href=\"#_cluster_mode\"></a>Cluster mode</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To work with cluster the connection creation is quite similar:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">final</span> RedisOptions options = <span class=\"hljs-keyword\">new</span> RedisOptions()\n  .addConnectionString(<span class=\"hljs-string\">&quot;redis://127.0.0.1:7000&quot;</span>)\n  .addConnectionString(<span class=\"hljs-string\">&quot;redis://127.0.0.1:7001&quot;</span>)\n  .addConnectionString(<span class=\"hljs-string\">&quot;redis://127.0.0.1:7002&quot;</span>)\n  .addConnectionString(<span class=\"hljs-string\">&quot;redis://127.0.0.1:7003&quot;</span>)\n  .addConnectionString(<span class=\"hljs-string\">&quot;redis://127.0.0.1:7004&quot;</span>)\n  .addConnectionString(<span class=\"hljs-string\">&quot;redis://127.0.0.1:7005&quot;</span>);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In this case the configuration requires one of more members of the cluster to be known. This list will be used to ask\nthe cluster for the current configuration, which means if any of the listed members is not available it will be skipped.</p>\n</div>\n<div class=\"paragraph\">\n<p>In cluster mode a connection is established to each node and special care is needed when executing commands. It is\nrecommended to read redis manual in order to understand how clustering works. The client operating in this mode will do\na best effort to identify which slot is used by the executed command in order to execute it on the right node. There\ncould be cases where this isn&#8217;t possible to identify and in that case as a best effort the command will be run on a\nrandom node.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_pubsub_mode\"><a class=\"anchor\" href=\"#_pubsub_mode\"></a>Pub/Sub mode</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Redis supports queues and pub/sub mode, when operated in this mode once a connection invokes a subscriber mode then\nit cannot be used for running other commands than the command to leave that mode.</p>\n</div>\n<div class=\"paragraph\">\n<p>To start a subscriber one would do:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(vertx, <span class=\"hljs-keyword\">new</span> RedisOptions())\n  .connect()\n  .onSuccess(conn -&gt; {\n    conn.handler(message -&gt; {\n      <span class=\"hljs-comment\">// do whatever you need to do with your message</span>\n    });\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>And from another place in the code publish messages to the queue:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">redis.send(Request.cmd(Command.PUBLISH).arg(<span class=\"hljs-string\">&quot;channel1&quot;</span>).arg(<span class=\"hljs-string\">&quot;Hello World!&quot;</span>))\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// published!</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nIt is important to remember that the commands <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code> and <code>PUNSUBSCRIBE</code> are <code>void</code>.\nThis means that the result in case of success is <code>null</code> not a instance of response. All messages are then routed through\nthe handler on the client.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_domain_sockets\"><a class=\"anchor\" href=\"#_domain_sockets\"></a>Domain Sockets</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Most of the examples shown connecting to a TCP sockets, however it is also possible to use Redis connecting to a UNIX\ndomain docket:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(vertx, <span class=\"hljs-string\">&quot;unix:///tmp/redis.sock&quot;</span>)\n  .connect()\n  .onSuccess(conn -&gt; {\n    <span class=\"hljs-comment\">// so something...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Be aware that HA and cluster modes report server addresses always on TCP addresses not domain sockets. So the\ncombination is not possible. Not because of this client but how Redis works.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_connection_pooling\"><a class=\"anchor\" href=\"#_connection_pooling\"></a>Connection Pooling</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>All client variations are backed by a connection pool. By default the configuration sets the pool size to 1, which means\nthat it operates just like a single connection. There are 4 tunnables for the pool:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>maxPoolSize</code> the max number of connections on the pool (default <code>6</code>)</p>\n</li>\n<li>\n<p><code>maxPoolWaiting</code> the max waiting handlers to get a connection on a queue (default <code>24</code>)</p>\n</li>\n<li>\n<p><code>poolCleanerInterval</code> the interval when connections will be clean default is <code>-1</code> (disabled)</p>\n</li>\n<li>\n<p><code>poolRecycleTimeout</code> the timeout to keep an open connection on the pool waiting and then close (default <code>15_000</code>)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Pooling is quite useful to avoid custom connection management, for example you can just use as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(vertx, <span class=\"hljs-string\">&quot;redis://localhost:7006&quot;</span>)\n  .send(Request.cmd(Command.PING))\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// Should have received a pong...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It is important to observe that no connection was acquired or returned, it&#8217;s all handled by the pool. However there might\nbe some scalability issues when more than 1 concurrent request attempts to get a connection from the pool, in order to\novercome this we need to tune the pool. A common configuration is to set the maximum size of the pool to the number of\navailable CPU cores and allow requests to get a connection from the pool to queue:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Redis.createClient(\n  vertx,\n  <span class=\"hljs-keyword\">new</span> RedisOptions()\n    .setConnectionString(<span class=\"hljs-string\">&quot;redis://localhost:7006&quot;</span>)\n    <span class=\"hljs-comment\">// allow at max 8 connections to redis</span>\n    .setMaxPoolSize(<span class=\"hljs-number\">8</span>)\n    <span class=\"hljs-comment\">// allow 32 connection requests to queue waiting</span>\n    <span class=\"hljs-comment\">// for a connection to be available.</span>\n    .setMaxWaitingHandlers(<span class=\"hljs-number\">32</span>))\n  .send(Request.cmd(Command.PING))\n  .onSuccess(res -&gt; {\n    <span class=\"hljs-comment\">// Should have received a pong...</span>\n  });</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nPooling is not compatible with <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code> or <code>PUNSUBSCRIBE</code> because these commands\nwill modify the way the connection operates and the connection cannot be reused.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_implementing_reconnect_on_error\"><a class=\"anchor\" href=\"#_implementing_reconnect_on_error\"></a>Implementing Reconnect on Error</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>While the connection pool is quite useful, for performance, a connection should not be auto managed but controlled by\nyou. In this case you will need to handle connection recovery, error handling and reconnect.</p>\n</div>\n<div class=\"paragraph\">\n<p>A typical scenario is that a user will want to reconnect to the server whenever an error occurs. The automatic reconnect\nis not part of the redis client as it will force a behaviour that might not match the user expectations, for example:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>What should happen to current in-flight requests?</p>\n</li>\n<li>\n<p>Should the exception handler be invoked or not?</p>\n</li>\n<li>\n<p>What if the retry will also fail?</p>\n</li>\n<li>\n<p>Should the previous state (db, authentication, subscriptions) be restored?</p>\n</li>\n<li>\n<p>Etc&#8230;&#8203;</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>In order to give the user full flexibility, this decision should not be performed by the client. However a simple\nreconnect with backoff timeout could be implemented as follows:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RedisVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractVerticle</span> </span>{\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MAX_RECONNECT_RETRIES = <span class=\"hljs-number\">16</span>;\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> RedisOptions options = <span class=\"hljs-keyword\">new</span> RedisOptions();\n  <span class=\"hljs-keyword\">private</span> RedisConnection client;\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n    createRedisClient()\n      .onSuccess(conn -&gt; {\n        <span class=\"hljs-comment\">// connected to redis!</span>\n      });\n  }\n\n  <span class=\"hljs-comment\">/**\n   * Will create a redis client and setup a reconnect handler when there is\n   * an exception in the connection.\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Future&lt;RedisConnection&gt; <span class=\"hljs-title\">createRedisClient</span><span class=\"hljs-params\">()</span> </span>{\n    Promise&lt;RedisConnection&gt; promise = Promise.promise();\n\n    Redis.createClient(vertx, options)\n      .connect()\n      .onSuccess(conn -&gt; {\n        <span class=\"hljs-comment\">// make sure the client is reconnected on error</span>\n        conn.exceptionHandler(e -&gt; {\n          <span class=\"hljs-comment\">// attempt to reconnect,</span>\n          <span class=\"hljs-comment\">// if there is an unrecoverable error</span>\n          attemptReconnect(<span class=\"hljs-number\">0</span>);\n        });\n        <span class=\"hljs-comment\">// allow further processing</span>\n        promise.complete(conn);\n      });\n\n    <span class=\"hljs-keyword\">return</span> promise.future();\n  }\n\n  <span class=\"hljs-comment\">/**\n   * Attempt to reconnect up to MAX_RECONNECT_RETRIES\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">attemptReconnect</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> retry)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (retry &gt; MAX_RECONNECT_RETRIES) {\n      <span class=\"hljs-comment\">// we should stop now, as there&#x27;s nothing we can do.</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// retry with backoff up to 10240 ms</span>\n      <span class=\"hljs-keyword\">long</span> backoff = (<span class=\"hljs-keyword\">long</span>) (Math.pow(<span class=\"hljs-number\">2</span>, Math.min(retry, <span class=\"hljs-number\">10</span>)) * <span class=\"hljs-number\">10</span>);\n\n      vertx.setTimer(backoff, timer -&gt; {\n        createRedisClient()\n          .onFailure(t -&gt; attemptReconnect(retry + <span class=\"hljs-number\">1</span>));\n      });\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In this example the client object will be replaced on reconnect and the application will retry up to 16 times with a\nbackoff up to 1280ms. By discarding the client we ensure that all old inflight responses are lost and all new ones\nwill be on the new connection.</p>\n</div>\n<div class=\"paragraph\">\n<p>It is important to note that, the reconnect will create a new connection object, so these object references should not\nbe cached and evaluated every time.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_protocol_parser\"><a class=\"anchor\" href=\"#_protocol_parser\"></a>Protocol Parser</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This client supports both <code>RESP2</code> and <code>RESP3</code> protocols, at the connection handshake time the client will automatically\ndetect which version is supported by the server and use it.</p>\n</div>\n<div class=\"paragraph\">\n<p>The parser internally creates an \"infinite\" readable buffer from all the chunks received from the server, in order to\navoid creating too much garbage in terms of memory collection, a tunnable watermark value is configurable at JVM startup\ntime. The system property <code>io.vertx.redis.parser.watermark</code> defines how much data is keept in this readable buffer\nbefore it gets discarded. By default this value is 512Kb. This means that each connection to the server will use at\nleast this amount of memory. As the client works in pipeline mode, keeping the number of connections low provides best\nresults, which means <code>512Kb * nconn</code> memory will be used. If the application will require a large number of connections,\nthen reducing the watermark value to a smaller value or even disable it entirely is advisable.</p>\n</div>\n</div>\n</div>","version":"4.1.5"},"__N_SSG":true}