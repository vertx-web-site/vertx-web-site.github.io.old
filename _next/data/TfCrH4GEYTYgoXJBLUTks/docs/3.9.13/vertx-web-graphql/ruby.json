{"pageProps":{"slug":"3.9.13/vertx-web-graphql/ruby","title":"Vert.x Web GraphQL","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_getting_started\">Getting started</a></li>\n<li><a href=\"#_handler_setup\">Handler setup</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_graphiql_client\">GraphiQL client</a></li>\n<li><a href=\"#_enable_query_batching\">Enable query batching</a></li>\n</ul>\n</li>\n<li><a href=\"#_building_a_graphql_server\">Building a GraphQL server</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_fetching_data_with_callback_based_apis\">Fetching data with callback-based APIs</a></li>\n<li><a href=\"#_providing_data_fetchers_with_some_context\">Providing data fetchers with some context</a></li>\n<li><a href=\"#_json_data_results\">JSON data results</a></li>\n<li><a href=\"#_using_dataloaders\">Using dataloaders</a></li>\n<li><a href=\"#_apollo_websocketlink\">Apollo WebSocketLink</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x Web GraphQL</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL extends Vert.x Web with the <a href=\"https://www.graphql-java.com\">GraphQL-Java</a> library so that you can build a GraphQL server.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nThis is the reference documentation for Vert.x Web GraphQL.\nIt is highly recommended to get familiar with the GraphQL-Java API first.\nYou may start by reading the <a href=\"https://www.graphql-java.com/documentation/v13/\">GraphQL-Java documentation</a>.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nThis module has <em>Tech Preview</em> status, this means the API can change between versions.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting started</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To use this module, add the following to the <em>dependencies</em> section of your Maven POM file:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-web-graphql<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.13<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or, if you use Gradle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-web-graphql:3.9.13&#x27;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handler_setup\"><a class=\"anchor\" href=\"#_handler_setup\"></a>Handler setup</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Create a Vert.x Web <code><a href=\"../../yardoc/VertxWeb/Route.html\">Route</a></code> and a <code><a href=\"../../yardoc/VertxWebGraphql/GraphQLHandler.html\">GraphQLHandler</a></code> for it:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-web-graphql/graph_ql_handler&#x27;</span>\ngraphQL = setup_graph_ql_java()\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(&amp;VertxWebGraphql::GraphQLHandler.create(graphQL).method(<span class=\"hljs-symbol\">:handle</span>))</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The handler serves both <code>GET</code> and <code>POST</code> requests.\nHowever you can restrict the service to one type of HTTP method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-web-graphql/graph_ql_handler&#x27;</span>\ngraphQL = setup_graph_ql_java()\n\nrouter.post(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(&amp;VertxWebGraphql::GraphQLHandler.create(graphQL).method(<span class=\"hljs-symbol\">:handle</span>))</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nThe <code><a href=\"../../yardoc/VertxWebGraphql/GraphQLHandler.html\">GraphQLHandler</a></code> does not require a <code><a href=\"../../yardoc/VertxWeb/BodyHandler.html\">BodyHandler</a></code> to read <code>POST</code> requests content.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_graphiql_client\"><a class=\"anchor\" href=\"#_graphiql_client\"></a>GraphiQL client</h3>\n<div class=\"paragraph\">\n<p>As you are building your application, testing your GraphQL queries in <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a> can be handy.</p>\n</div>\n<div class=\"paragraph\">\n<p>To do so, create a route for GraphiQL resources and a <code><a href=\"../../yardoc/VertxWebGraphql/GraphiQLHandler.html\">GraphiQLHandler</a></code> for them:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-web-graphql/graphi_ql_handler&#x27;</span>\noptions = {\n  <span class=\"hljs-string\">&#x27;enabled&#x27;</span> =&gt; <span class=\"hljs-literal\">true</span>\n}\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphiql/*&quot;</span>).handler(&amp;VertxWebGraphql::GraphiQLHandler.create(options).method(<span class=\"hljs-symbol\">:handle</span>))</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Then browse to <a href=\"http://localhost:8080/graphiql/\" class=\"bare\">http://localhost:8080/graphiql/</a>.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nThe GraphiQL user interface is disabled by default for security reasons.\nThis is why you must configure the <code><a href=\"../dataobjects.html#GraphiQLHandlerOptions\">GraphiQLHandlerOptions</a></code> to enable it.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nGraphiQL is enabled automatically when Vert.x Web runs in development mode.\nTo switch the development mode on, use the <code>VERTXWEB_ENVIRONMENT</code> environment variable or <code>vertxweb.environment</code> system property and set it to <code>dev</code>.\nIn this case, create the <code><a href=\"../../yardoc/VertxWebGraphql/GraphiQLHandler.html\">GraphiQLHandler</a></code> without changing the <code>enabled</code> property.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>If your application is protected by authentication, you can customize the headers sent by GraphiQL dynamically:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx/multi_map&#x27;</span>\ngraphiQLHandler.graphi_ql_request_headers(<span class=\"hljs-built_in\">lambda</span> { |<span class=\"hljs-params\">rc</span>|\n  token = rc.get(<span class=\"hljs-string\">&quot;token&quot;</span>)\n  <span class=\"hljs-keyword\">return</span> Vertx::MultiMap.case_insensitive_multi_map().add(Java::IoVertxCoreHttp::HttpHeaders::<span class=\"hljs-variable constant_\">AUTHORIZATION</span>, <span class=\"hljs-string\">&quot;Bearer <span class=\"hljs-subst\">#{token}</span>&quot;</span>)\n})\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphiql/*&quot;</span>).handler(&amp;graphiQLHandler.method(<span class=\"hljs-symbol\">:handle</span>))</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Please refer to the <code><a href=\"../dataobjects.html#GraphiQLHandlerOptions\">GraphiQLHandlerOptions</a></code> documentation for further details.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_enable_query_batching\"><a class=\"anchor\" href=\"#_enable_query_batching\"></a>Enable query batching</h3>\n<div class=\"paragraph\">\n<p>Query batching consists in posting an array instead of a single object to the GraphQL endpoint.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x Web GraphQL can handle such requests but by default the feature is disabled.\nTo enable it, create the <code><a href=\"../../yardoc/VertxWebGraphql/GraphQLHandler.html\">GraphQLHandler</a></code> with options:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-web-graphql/graph_ql_handler&#x27;</span>\noptions = {\n  <span class=\"hljs-string\">&#x27;requestBatchingEnabled&#x27;</span> =&gt; <span class=\"hljs-literal\">true</span>\n}\n\nhandler = VertxWebGraphql::GraphQLHandler.create(graphQL, options)</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_building_a_graphql_server\"><a class=\"anchor\" href=\"#_building_a_graphql_server\"></a>Building a GraphQL server</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The GraphQL-Java API is very well suited for the asynchronous world: the asynchronous execution strategy is the default for queries (serial asynchronous for mutations).</p>\n</div>\n<div class=\"paragraph\">\n<p>To <a href=\"https://vertx.io/docs/vertx-core/java/#golden_rule\">avoid blocking the event loop</a>, all you have to do is implement <a href=\"https://www.graphql-java.com/documentation/v13/data-fetching/\">data fetchers</a> that return a <code>CompletionStage</code> instead of the result directly.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">dataFetcher = <span class=\"hljs-built_in\">lambda</span> { |<span class=\"hljs-params\">environment</span>|\n\n  completableFuture = <span class=\"hljs-title class_\">Java::JavaUtilConcurrent::CompletableFuture</span>.new()\n\n  retrieve_links_from_backend(environment) { |<span class=\"hljs-params\">ar_err,ar</span>|\n    <span class=\"hljs-keyword\">if</span> (ar_err == <span class=\"hljs-literal\">nil</span>)\n      completableFuture.complete?(ar)\n    <span class=\"hljs-keyword\">else</span>\n      completableFuture.complete_exceptionally?(ar_err)\n    <span class=\"hljs-keyword\">end</span>\n  }\n\n  <span class=\"hljs-keyword\">return</span> completableFuture\n}\n\nruntimeWiring = Java::GraphqlSchemaIdl::RuntimeWiring.new_runtime_wiring().type(<span class=\"hljs-string\">&quot;Query&quot;</span>, <span class=\"hljs-built_in\">lambda</span> { |<span class=\"hljs-params\">builder</span>|\n  builder.data_fetcher(<span class=\"hljs-string\">&quot;allLinks&quot;</span>, dataFetcher)\n}).build()</code></pre>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_fetching_data_with_callback_based_apis\"><a class=\"anchor\" href=\"#_fetching_data_with_callback_based_apis\"></a>Fetching data with callback-based APIs</h3>\n<div class=\"paragraph\">\n<p>Implementing a data fetcher that returns a <code>CompletionStage</code> is not a complex task.\nBut when you work with Vert.x callback-based APIs, it requires a bit of boilerplate.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is where the <code><a href=\"unavailable\">VertxDataFetcher</a></code> can help:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">dataFetcher = <span class=\"hljs-title class_\">Java::IoVertxExtWebHandlerGraphql::VertxDataFetcher</span>.new(<span class=\"hljs-built_in\">lambda</span> { |<span class=\"hljs-params\">environment,future</span>|\n\n  retrieve_links_from_backend(environment, &amp;future)\n\n})\n\nruntimeWiring = Java::GraphqlSchemaIdl::RuntimeWiring.new_runtime_wiring().type(<span class=\"hljs-string\">&quot;Query&quot;</span>, <span class=\"hljs-built_in\">lambda</span> { |<span class=\"hljs-params\">builder</span>|\n  builder.data_fetcher(<span class=\"hljs-string\">&quot;allLinks&quot;</span>, dataFetcher)\n}).build()</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_providing_data_fetchers_with_some_context\"><a class=\"anchor\" href=\"#_providing_data_fetchers_with_some_context\"></a>Providing data fetchers with some context</h3>\n<div class=\"paragraph\">\n<p>Very often, the <code><a href=\"../../yardoc/VertxWebGraphql/GraphQLHandler.html\">GraphQLHandler</a></code> will be declared after other route handlers.\nFor example, you could protect your application with authentication.</p>\n</div>\n<div class=\"paragraph\">\n<p>In this case, it is likely that your data fetchers will need to know which user is logged-in to narrow down the results.\nLet&#8217;s say your authentication layer stores a <code>User</code> object in the <code><a href=\"../../yardoc/VertxWeb/RoutingContext.html\">RoutingContext</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You may retrieve this object by inspecting the <code>DataFetchingEnvironment</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">dataFetcher = <span class=\"hljs-title class_\">Java::IoVertxExtWebHandlerGraphql::VertxDataFetcher</span>.new(<span class=\"hljs-built_in\">lambda</span> { |<span class=\"hljs-params\">environment,future</span>|\n\n  routingContext = environment.get_context()\n\n  user = routingContext.get(<span class=\"hljs-string\">&quot;user&quot;</span>)\n\n  retrieve_links_posted_by(user, &amp;future)\n\n})</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nThe routing context is available with any kind of data fetchers, not just <code><a href=\"unavailable\">VertxDataFetcher</a></code>.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>If you prefer not to expose the routing context to your data fetchers, configure the GraphQL handler to customize the context object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-web-graphql/graph_ql_handler&#x27;</span>\ndataFetcher = <span class=\"hljs-title class_\">Java::IoVertxExtWebHandlerGraphql::VertxDataFetcher</span>.new(<span class=\"hljs-built_in\">lambda</span> { |<span class=\"hljs-params\">environment,future</span>|\n\n  <span class=\"hljs-comment\"># User as custom context object</span>\n  user = environment.get_context()\n\n  retrieve_links_posted_by(user, &amp;future)\n\n})\n\ngraphQL = setup_graph_ql_java(dataFetcher)\n\n<span class=\"hljs-comment\"># Customize the query context object when setting up the handler</span>\nhandler = VertxWebGraphql::GraphQLHandler.create(graphQL).query_context(<span class=\"hljs-built_in\">lambda</span> { |<span class=\"hljs-params\">routingContext</span>|\n\n  <span class=\"hljs-keyword\">return</span> routingContext.get(<span class=\"hljs-string\">&quot;user&quot;</span>)\n\n})\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(&amp;handler.method(<span class=\"hljs-symbol\">:handle</span>))</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_data_results\"><a class=\"anchor\" href=\"#_json_data_results\"></a>JSON data results</h3>\n<div class=\"paragraph\">\n<p>The default GraphQL data fetcher is <code>PropertyDataFetcher</code>.\nAs a consequence, it will be able to read the fields of your domain objects without further configuration.</p>\n</div>\n<div class=\"paragraph\">\n<p>Nevertheless, some Vert.x data clients return <code><a href=\"unavailable\">JsonArray</a></code> and <code><a href=\"unavailable\">JsonObject</a></code> results.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you don&#8217;t need (or don&#8217;t wish to) use a domain object layer, you can configure GraphQL-Java to use <code><a href=\"unavailable\">VertxPropertyDataFetcher</a></code> instead:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">builder = Java::GraphqlSchemaIdl::RuntimeWiring.new_runtime_wiring()\n\nbuilder.wiring_factory(<span class=\"hljs-title class_\">Java::GraphqlSchemaIdl::WiringFactory</span>.new())</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\n<code><a href=\"unavailable\">VertxPropertyDataFetcher</a></code> wraps a <code>PropertyDataFetcher</code> so you can still use it with domain objects.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_dataloaders\"><a class=\"anchor\" href=\"#_using_dataloaders\"></a>Using dataloaders</h3>\n<div class=\"paragraph\">\n<p>Dataloaders help you to load data efficiently by batching fetch requests and caching results.</p>\n</div>\n<div class=\"paragraph\">\n<p>First, create a batch loader:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">linksBatchLoader = <span class=\"hljs-built_in\">lambda</span> { |<span class=\"hljs-params\">keys,environment</span>|\n\n  <span class=\"hljs-keyword\">return</span> retrieve_links_from_backend(keys, environment)\n\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nIf you work with Vert.x callback-based APIs, you may use a <code><a href=\"unavailable\">VertxBatchLoader</a></code> or a <code><a href=\"unavailable\">VertxMappedBatchLoader</a></code> to simplify your code.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Then, configure the <code><a href=\"../../yardoc/VertxWebGraphql/GraphQLHandler.html\">GraphQLHandler</a></code> to create a <code>DataLoaderRegistry</code> for each request:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">Code <span class=\"hljs-keyword\">not</span> translatable</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_apollo_websocketlink\"><a class=\"anchor\" href=\"#_apollo_websocketlink\"></a>Apollo WebSocketLink</h3>\n<div class=\"paragraph\">\n<p>You can use an <a href=\"https://www.apollographql.com/docs/link/links/ws/\">Apollo WebSocketLink</a> which connects over a websocket.\nThis is specially useful if you want to add subscriptions to your GraphQL schema, but you can also use the websocket for queries and mutations.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-web-graphql/apollo_ws_handler&#x27;</span>\ngraphQL = setup_graph_ql_java()\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(&amp;VertxWebGraphql::ApolloWSHandler.create(graphQL).method(<span class=\"hljs-symbol\">:handle</span>))</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nTo support the <code>graphql-ws</code> websocket subprotocol, it has to be added to the server configuration:\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\">httpServerOptions = {\n  <span class=\"hljs-string\">&#x27;webSocketSubProtocols&#x27;</span> =&gt; [\n    <span class=\"hljs-string\">&quot;graphql-ws&quot;</span>\n  ]\n}\nvertx.create_http_server(httpServerOptions).request_handler(&amp;router.method(<span class=\"hljs-symbol\">:handle</span>)).listen(<span class=\"hljs-number\">8080</span>)</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nIf you want to support a WebSocketLink and a HttpLink in the same path, you can add the ApolloWSHandler in first place and then the GraphQLHandler.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-web-graphql/apollo_ws_handler&#x27;</span>\n<span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">&#x27;vertx-web-graphql/graph_ql_handler&#x27;</span>\ngraphQL = setup_graph_ql_java()\n\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(&amp;VertxWebGraphql::ApolloWSHandler.create(graphQL).method(<span class=\"hljs-symbol\">:handle</span>))\nrouter.route(<span class=\"hljs-string\">&quot;/graphql&quot;</span>).handler(&amp;VertxWebGraphql::GraphQLHandler.create(graphQL).method(<span class=\"hljs-symbol\">:handle</span>))</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Here you can find how to configure the Apollo SubscriptionClient: <a href=\"https://github.com/apollographql/subscriptions-transport-ws\" class=\"bare\">https://github.com/apollographql/subscriptions-transport-ws</a></p>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nA subscription <code>DataFetcher</code> has to return a <code>org.reactivestreams.Publisher</code> instance.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n</div>","version":"3.9.13"},"__N_SSG":true}