{"pageProps":{"slug":"3.9.12/vertx-rx/groovy","title":"Vert.x for RxGroovy","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_read_stream_support\">Read stream support</a></li>\n<li><a href=\"#_handler_support\">Handler support</a></li>\n<li><a href=\"#_async_result_support\">Async result support</a></li>\n<li><a href=\"#_scheduler_support\">Scheduler support</a></li>\n<li><a href=\"#_json_unmarshalling\">Json unmarshalling</a></li>\n<li><a href=\"#_marshall_other_dataformats\">Marshall other dataformats</a></li>\n<li><a href=\"#_api_examples\">Api examples</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_eventbus_message_stream\">EventBus message stream</a></li>\n<li><a href=\"#_timers\">Timers</a></li>\n<li><a href=\"#_http_client_requests\">Http client requests</a></li>\n<li><a href=\"#_http_server_requests\">Http server requests</a></li>\n<li><a href=\"#_websocket_client\">Websocket client</a></li>\n<li><a href=\"#_websocket_server\">Websocket server</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x for RxGroovy</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a> is a popular library for composing asynchronous and event\nbased programs using observable sequences for the Java VM. <a href=\"https://github.com/ReactiveX/RxGroovy\">RxGroovy</a>\nis the Reactive Extensions for Groovy. This adaptor allows <code>groovy.lang.Closure</code> functions to be used\nand RxJava will know how to invoke them.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x integrates naturally with RxGroovy, allowing to use observable wherever you can use streams or asynchronous results.</p>\n</div>\n<div class=\"paragraph\">\n<p>To use vert.x API for RxGroovy, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>{maven-groupId}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>{maven-artifactId}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>{maven-version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile {maven-groupId}:{maven-artifactId}:{maven-version}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_read_stream_support\"><a class=\"anchor\" href=\"#_read_stream_support\"></a>Read stream support</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>RxJava observable is a perfect match for Vert.x <code>ReadStream</code> class : both provide a flow of items.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x API for Groovy provides <code>io.vertx.groovy.core.stream.ReadStream</code> objects, the RxGroovy provides a\nGroovy extension module that adds the <code>toObservable</code> method to the read stream class.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> fs = vertx.fileSystem()\nfs.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, [:], { result -&gt;\n  <span class=\"hljs-keyword\">def</span> file = result.result()\n  <span class=\"hljs-keyword\">def</span> observable = file.toObservable()\n  observable.forEach({ data -&gt; println(<span class=\"hljs-string\">&quot;Read data: ${data.toString(&quot;</span>UTF<span class=\"hljs-number\">-8</span><span class=\"hljs-string\">&quot;)}&quot;</span>) })\n})</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_handler_support\"><a class=\"anchor\" href=\"#_handler_support\"></a>Handler support</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The RxJava <code>io.vertx.ext.rx.java.RxHelper</code> should be used to:\n- create an <code>io.vertx.ext.rx.java.ObservableHandler</code>,\n- transform actions to an handler</p>\n</div>\n<div class=\"paragraph\">\n<p>The RxGroovy extension module adds the <code>toHandler</code> method on the <code>rx.Observer</code> class:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Observer&lt;Long&gt; observer = Observers.create({ item -&gt; println(<span class=\"hljs-string\">&quot;Timer fired!&quot;</span>) })\nHandler&lt;Long&gt; handler = observer.toHandler()\nvertx.setTimer(<span class=\"hljs-number\">1000</span>, handler)</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_async_result_support\"><a class=\"anchor\" href=\"#_async_result_support\"></a>Async result support</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>In Vert.x future objects are modelled as async result handlers and occur as last parameter of asynchronous methods.</p>\n</div>\n<div class=\"paragraph\">\n<p>The RxGroovy extension module adds the <code>toFuture</code> method on the <code>rx.Observer</code> class:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Observer&lt;HttpServer&gt; observer = Observers.create({ server -&gt; println(<span class=\"hljs-string\">&quot;Server started&quot;</span>) })\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler = observer.toFuture()\nvertx.createHttpServer([<span class=\"hljs-attr\">port:</span><span class=\"hljs-number\">1234</span>,<span class=\"hljs-attr\">host:</span><span class=\"hljs-string\">&quot;localhost&quot;</span>]).listen(handler)</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_scheduler_support\"><a class=\"anchor\" href=\"#_scheduler_support\"></a>Scheduler support</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The reactive extension sometimes needs to schedule actions, for instance <code>Observable#timer</code> create and returns\na timer that emit periodic events. By default, scheduled actions are managed by RxJava, it means that the\ntimer thread are not Vert.x threads and therefore not executing in a Vert.x event loop.</p>\n</div>\n<div class=\"paragraph\">\n<p>When an RxJava method deals with a scheduler, it accepts an overloaded method accepting an extra <code>Rx.Scheduler</code>,\nthe RxGroovy extension module adds to the <code>Vertx</code> class the <code>scheduler()</code> method will return a scheduler that can be used in such places.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Observable&lt;Long&gt; timer = Observable.timer(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, vertx.scheduler())</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For blocking scheduled actions, a scheduler can be created with the <code>blockingScheduler</code> method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Scheduler scheduler = vertx.blockingScheduler();\nObservable&lt;Integer&gt; obs = blockingObservable.observeOn(scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava can also be configured to use a scheduler by default, the returned scheduler hook uses a blocking\nscheduler for IO actions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">RxJavaSchedulersHook hook = RxHelper.schedulerHook(vertx)\nRxJavaPlugins.getInstance().registerSchedulersHook(hook)</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_json_unmarshalling\"><a class=\"anchor\" href=\"#_json_unmarshalling\"></a>Json unmarshalling</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <code>io.vertx.rx.groovy.RxHelper#unmarshaller(java.lang.Class)}</code> creates an <code>rx.Observable.Operator</code> that\ntransforms an <code>Observable&lt;Buffer&gt;</code> in json format into an object observable:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> fileSystem = vertx.fileSystem()\nfileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, [:], { result -&gt;\n  AsyncFile file = result.result()\n  Observable&lt;Buffer&gt; observable = file.toObservable()\n  observable.lift(RxHelper.unmarshaller(MyPojo.<span class=\"hljs-keyword\">class</span>)).subscribe({ mypojo -&gt;\n      <span class=\"hljs-comment\">// Process the object</span>\n  })\n})</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_marshall_other_dataformats\"><a class=\"anchor\" href=\"#_marshall_other_dataformats\"></a>Marshall other dataformats</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <code>io.vertx.rx.groovy.RxHelper#unmarshaller(java.lang.Class, ObjectMapper)}</code> creates an <code>rx.Observable.Operator</code> that\ntransforms an <code>Observable&lt;Buffer&gt;</code> in a format the mapper can parse  into an object observable.</p>\n</div>\n<div class=\"paragraph\">\n<p>Include the appropriate dependency from here: <a href=\"https://github.com/FasterXML/jackson-dataformats-text\">jackson-dataformats-text</a></p>\n</div>\n<div class=\"paragraph\">\n<p>In order to use it to parse YAML you can do the following:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Unresolved directive <span class=\"hljs-keyword\">in</span> index.adoc - <span class=\"hljs-attr\">include:</span>:unmarhsallYaml.groovy[tags=example]</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_api_examples\"><a class=\"anchor\" href=\"#_api_examples\"></a>Api examples</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Let&#8217;s study now a few examples of using Vert.x with RxJava.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_eventbus_message_stream\"><a class=\"anchor\" href=\"#_eventbus_message_stream\"></a>EventBus message stream</h3>\n<div class=\"paragraph\">\n<p>The event bus <code>MessageConsumer</code> provides naturally an <code>Observable&lt;Message&lt;T&gt;&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">EventBus eb = vertx.eventBus()\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>)\nObservable&lt;Message&lt;String&gt;&gt; observable = consumer.toObservable()\nSubscription sub = observable.subscribe({ msg -&gt;\n  <span class=\"hljs-comment\">// Got message</span>\n});\n\n<span class=\"hljs-comment\">// Unregisters the stream after 10 seconds</span>\nvertx.setTimer(<span class=\"hljs-number\">10000</span>, { id -&gt;\n  sub.unsubscribe()\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>MessageConsumer</code> provides a stream of <code>Message</code>.\nThe <code>Message#body()</code> gives access to a new stream of message bodies if needed:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">EventBus eb = vertx.eventBus()\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>)\nObservable&lt;String&gt; observable = consumer.bodyStream().toObservable()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava map/reduce composition style can be then be used:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Observable&lt;Double&gt; observable = vertx.eventBus().\n&lt;Double&gt;consumer(<span class=\"hljs-string\">&quot;heat-sensor&quot;</span>).\n    bodyStream().\n    toObservable()\n\nobservable.\n    buffer(<span class=\"hljs-number\">1</span>, TimeUnit.SECONDS).\n    map({ samples -&gt; samples.sum() }).\n    subscribe({ heat -&gt;\n      vertx.eventBus().send(<span class=\"hljs-string\">&quot;news-feed&quot;</span>, <span class=\"hljs-string\">&quot;Current heat is &quot;</span> + heat)\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timers\"><a class=\"anchor\" href=\"#_timers\"></a>Timers</h3>\n<div class=\"paragraph\">\n<p>Timer task can be created with <code>Vertx#timerStream(long)</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.timerStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe({ id -&gt;\n          println(<span class=\"hljs-string\">&quot;Callback after 1 second&quot;</span>)\n        }\n    )</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Periodic task can be created with <code>Vertx#periodicStream(long)</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe({ id -&gt;\n          println(<span class=\"hljs-string\">&quot;Callback every second&quot;</span>)\n        }\n    )</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The observable can be cancelled with an unsubscription:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(<span class=\"hljs-keyword\">new</span> Subscriber&lt;Long&gt;() {\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> onNext(Long aLong) {\n        <span class=\"hljs-comment\">// Callback</span>\n        unsubscribe()\n      }\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> onError(Throwable e) {}\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> onCompleted() {}\n    })</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_client_requests\"><a class=\"anchor\" href=\"#_http_client_requests\"></a>Http client requests</h3>\n<div class=\"paragraph\">\n<p><code>HttpClientRequest#toObservable()</code> provides a one shot callback with the <code>HttpClientResponse</code>}\n object. The observable reports a request failure.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">HttpClientRequest request = client.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\nrequest.toObservable().subscribe({ response -&gt;\n  <span class=\"hljs-comment\">// Process the response</span>\n}, { error -&gt;\n  <span class=\"hljs-comment\">// Could not connect</span>\n})\nrequest.end()</code></pre>\n</div>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre> The response can be processed as an `Observable&lt;Buffer&gt;` with the\n`HttpClientResponse#toObservable()` method:</pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">HttpClientRequest request = client.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\nrequest.toObservable().\n    subscribe(\n        { response -&gt;\n          Observable&lt;Buffer&gt; observable = response.toObservable()\n          observable.forEach(\n              { buffer -&gt;\n                <span class=\"hljs-comment\">// Process buffer</span>\n              })\n        })</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The same flow can be achieved with the <code>flatMap</code> operation:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">request.toObservable().\n    flatMap({resp -&gt; resp.&amp;toObservable}).\n    forEach(\n        { buffer -&gt;\n      <span class=\"hljs-comment\">// Process buffer</span>\n    })</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>We can also unmarshall the <code>Observable&lt;Buffer&gt;</code> into an object using the {@link io.vertx.rx.groovy.RxHelpe.RxHelper#unmarshaller(java.lang.Class)}\nstatic method. This method creates an <code>Rx.Observable.Operator</code> unmarshalling buffers to an object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">request.toObservable().\n    flatMap({ resp -&gt; resp.&amp;toObservable }).\n    lift(RxHelper.unmarshaller(MyPojo.<span class=\"hljs-keyword\">class</span>)).\n    forEach({ pojo -&gt;\n      <span class=\"hljs-comment\">// Process pojo</span>\n    })</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_server_requests\"><a class=\"anchor\" href=\"#_http_server_requests\"></a>Http server requests</h3>\n<div class=\"paragraph\">\n<p>The <code>HttpServer#requestStream()</code> provides a callback for each incoming request:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable()\nrequestObservable.subscribe({ request -&gt;\n  <span class=\"hljs-comment\">// Process request</span>\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>HttpServerRequest</code> can then be adapted to an <code>Observable&lt;Buffer&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable()\nrequestObservable.subscribe({ request -&gt;\n  Observable&lt;Buffer&gt; observable = request.toObservable()\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>io.vertx.rx.groovy.RxHelpe.RxHelper#unmarshaller(java.lang.Class)}</code> can be used to parse and map a json request to an object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable()\nrequestObservable.subscribe({ request -&gt;\n  Observable&lt;MyPojo&gt; observable = request.\n      toObservable().\n      lift(RxHelper.unmarshaller(MyPojo.<span class=\"hljs-keyword\">class</span>))\n})</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_client\"><a class=\"anchor\" href=\"#_websocket_client\"></a>Websocket client</h3>\n<div class=\"paragraph\">\n<p>The`HttpClient#websocketStream`} provides a single callback when the websocket connects, otherwise a failure:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">HttpClient client = vertx.createHttpClient()\nWebSocketStream stream = client.websocketStream(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\nObservable&lt;WebSocket&gt; socketObservable = stream.toObservable()\nsocketObservable.subscribe(\n    { ws -&gt;\n      <span class=\"hljs-comment\">// Use the websocket</span>\n    }, { error -&gt;\n  <span class=\"hljs-comment\">// Could not connect</span>\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>WebSocket</code> can then be turned into an <code>Observable&lt;Buffer&gt;</code> easily</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">socketObservable.subscribe(\n    { socket -&gt;\n      Observable&lt;Buffer&gt; dataObs = socket.toObservable()\n      dataObs.subscribe({ buffer -&gt;\n        println(<span class=\"hljs-string\">&quot;Got message ${buffer.toString(&quot;</span>UTF<span class=\"hljs-number\">-8</span><span class=\"hljs-string\">&quot;)}&quot;</span>)\n      })\n    })</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_server\"><a class=\"anchor\" href=\"#_websocket_server\"></a>Websocket server</h3>\n<div class=\"paragraph\">\n<p>The <code>HttpServer#websocketStream()</code> provides a callback for each incoming connection:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Observable&lt;ServerWebSocket&gt; socketObservable = server.websocketStream().toObservable()\nsocketObservable.subscribe(\n    { socket -&gt; println(<span class=\"hljs-string\">&quot;Web socket connect&quot;</span>) },\n    { failure -&gt; println(<span class=\"hljs-string\">&quot;Should never be called&quot;</span>) },\n    { println(<span class=\"hljs-string\">&quot;Subscription ended or server closed&quot;</span>) }\n)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>ServerWebSocket</code> can be turned into an <code>Observable&lt;Buffer&gt;</code> easily:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">Observable&lt;ServerWebSocket&gt; socketObservable = server.websocketStream().toObservable()\nsocketObservable.subscribe({ socket -&gt;\n  Observable&lt;Buffer&gt; dataObs = socket.toObservable()\n  dataObs.subscribe({ buffer -&gt;\n    println(<span class=\"hljs-string\">&quot;Got message ${buffer.toString(&quot;</span>UTF<span class=\"hljs-number\">-8</span><span class=\"hljs-string\">&quot;)}&quot;</span>)\n  })\n})</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"3.9.12"},"__N_SSG":true}