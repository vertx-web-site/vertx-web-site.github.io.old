{"pageProps":{"slug":"3.9.2/vertx-auth-oauth2/scala","title":"The OAuth2 auth provider","fallbackGitHubStars":null,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_the_oauth2_auth_provider\">The OAuth2 auth provider</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_authorization_code_flow\">Authorization Code Flow</a></li>\n<li><a href=\"#_password_credentials_flow\">Password Credentials Flow</a></li>\n<li><a href=\"#_client_credentials_flow\">Client Credentials Flow</a></li>\n<li><a href=\"#_extensions\">Extensions</a></li>\n<li><a href=\"#_getting_started\">Getting Started</a></li>\n<li><a href=\"#_openid_connect_discovery\">OpenID Connect Discovery</a></li>\n<li><a href=\"#_accesstoken_object\">AccessToken object</a></li>\n<li><a href=\"#_example_configuration_for_common_oauth2_providers\">Example configuration for common OAuth2 providers</a></li>\n<li><a href=\"#_token_introspection\">Token Introspection</a></li>\n<li><a href=\"#_verifying_jwt_tokens\">Verifying JWT tokens</a></li>\n</ul>\n</li>\n<li><a href=\"#_role_based_access_control\">Role Based Access Control</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_keycloak_jwt\">Keycloak JWT</a></li>\n<li><a href=\"#_microprofile_jwt_1_1_spec\">MicroProfile JWT 1.1 spec</a></li>\n</ul>\n</li>\n<li><a href=\"#_token_management\">Token Management</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_check_if_it_is_expired\">Check if it is expired</a></li>\n<li><a href=\"#_refresh_token\">Refresh token</a></li>\n<li><a href=\"#_revoke_token\">Revoke token</a></li>\n<li><a href=\"#_introspect\">Introspect</a></li>\n<li><a href=\"#_logging_out\">Logging out</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"\n<div class=\"sect1\">\n<h2 id=\"_the_oauth2_auth_provider\"><a class=\"anchor\" href=\"#_the_oauth2_auth_provider\"></a>The OAuth2 auth provider</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This component contains an out of the box OAuth2 (and to some extent OpenID Connect) relying party implementation.\nTo use this project, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-auth-oauth2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>${maven.version}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-auth-oauth2:${maven.version}&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>OAuth2 lets users grant the access to the desired resources to third party applications, giving them the possibility\nto enable and disable those accesses whenever they want.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x OAuth2 supports the following flows.</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Authorization Code Flow (for apps with servers that can store persistent information).</p>\n</li>\n<li>\n<p>Password Credentials Flow (when previous flow can&#8217;t be used or during development).</p>\n</li>\n<li>\n<p>Client Credentials Flow (the client can request an access token using only its client credentials)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The same code will work with OpenID Connect <a href=\"https://openid.net/connect/\" class=\"bare\">https://openid.net/connect/</a> servers and supports the Discovery protocol\nas specified in <a href=\"http://openid.net/specs/openid-connect-discovery-1_0.html\" class=\"bare\">http://openid.net/specs/openid-connect-discovery-1_0.html</a> .</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_authorization_code_flow\"><a class=\"anchor\" href=\"#_authorization_code_flow\"></a>Authorization Code Flow</h3>\n<div class=\"paragraph\">\n<p>The authorization code grant type is used to obtain both access tokens and refresh tokens and is optimized for\nconfidential clients. As a redirection-based flow, the client must be capable of interacting with the resource\nowner&#8217;s user-agent (typically a web browser) and capable of receiving incoming requests (via redirection) from the\nauthorization server.</p>\n</div>\n<div class=\"paragraph\">\n<p>For more details see <a href=\"http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.1\">Oauth2 specification, section 4.1</a>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_password_credentials_flow\"><a class=\"anchor\" href=\"#_password_credentials_flow\"></a>Password Credentials Flow</h3>\n<div class=\"paragraph\">\n<p>The resource owner password credentials grant type is suitable in cases where the resource owner has a trust\nrelationship with the client, such as the device operating system or a highly privileged application. The\nauthorization server should take special care when enabling this grant type, and only allow it when other flows are\nnot viable.</p>\n</div>\n<div class=\"paragraph\">\n<p>The grant type is suitable for clients capable of obtaining the resource owner&#8217;s credentials (username and password,\ntypically using an interactive form).  It is also used to migrate existing clients using direct authentication\nschemes such as HTTP Basic or Digest authentication to OAuth by converting the stored credentials to an access token.</p>\n</div>\n<div class=\"paragraph\">\n<p>For more details see <a href=\"http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.3\">Oauth2 specification, section 4.3</a>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_client_credentials_flow\"><a class=\"anchor\" href=\"#_client_credentials_flow\"></a>Client Credentials Flow</h3>\n<div class=\"paragraph\">\n<p>The client can request an access token using only its client credentials (or other supported means of authentication)\nwhen the client is requesting access to the protected resources under its control, or those of another resource owner\nthat have been previously arranged with the authorization server (the method of which is beyond the scope of this\nspecification).</p>\n</div>\n<div class=\"paragraph\">\n<p>The client credentials grant type MUST only be used by confidential clients.</p>\n</div>\n<div class=\"paragraph\">\n<p>For more details see <a href=\"http://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-4.4\">Oauth2 specification, section 4.4</a>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_extensions\"><a class=\"anchor\" href=\"#_extensions\"></a>Extensions</h3>\n<div class=\"paragraph\">\n<p>The provider supports RFC7523 an extension to allow server to server authorization based on JWT.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_getting_started\"><a class=\"anchor\" href=\"#_getting_started\"></a>Getting Started</h3>\n<div class=\"paragraph\">\n<p>An example on how to use this provider and authenticate with GitHub can be implemented as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-keyword\">var</span> oauth2 = <span class=\"hljs-type\">OAuth2Auth</span>.create(vertx, <span class=\"hljs-type\">OAuth2FlowType</span>.<span class=\"hljs-type\">AUTH_CODE</span>, <span class=\"hljs-type\">OAuth2ClientOptions</span>()\n  .setClientID(<span class=\"hljs-string\">&quot;YOUR_CLIENT_ID&quot;</span>)\n  .setClientSecret(<span class=\"hljs-string\">&quot;YOUR_CLIENT_SECRET&quot;</span>)\n  .setSite(<span class=\"hljs-string\">&quot;https://github.com/login&quot;</span>)\n  .setTokenPath(<span class=\"hljs-string\">&quot;/oauth/access_token&quot;</span>)\n  .setAuthorizationPath(<span class=\"hljs-string\">&quot;/oauth/authorize&quot;</span>)\n)\n\n<span class=\"hljs-comment\">// when there is a need to access a protected resource or call a protected method,</span>\n<span class=\"hljs-comment\">// call the authZ url for a challenge</span>\n\n<span class=\"hljs-keyword\">var</span> authorization_uri = oauth2.authorizeURL(<span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;redirect_uri&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:8080/callback&quot;</span>).put(<span class=\"hljs-string\">&quot;scope&quot;</span>, <span class=\"hljs-string\">&quot;notifications&quot;</span>).put(<span class=\"hljs-string\">&quot;state&quot;</span>, <span class=\"hljs-string\">&quot;3(#0/!~&quot;</span>))\n\n<span class=\"hljs-comment\">// when working with web application use the above string as a redirect url</span>\n\n<span class=\"hljs-comment\">// in this case GitHub will call you back in the callback uri one should now complete the handshake as:</span>\n\n\n<span class=\"hljs-keyword\">var</span> code = <span class=\"hljs-string\">&quot;xxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>\n\noauth2.authenticateFuture(<span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;code&quot;</span>, code).put(<span class=\"hljs-string\">&quot;redirect_uri&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:8080/callback&quot;</span>)).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// error, the code provided is not valid</span>\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_authorization_code_flow_2\"><a class=\"anchor\" href=\"#_authorization_code_flow_2\"></a>Authorization Code flow</h4>\n<div class=\"paragraph\">\n<p>The Authorization Code flow is made up from two parts. At first your application asks to the user the permission to\naccess their data. If the user approves the OAuth2 server sends to the client an authorization code. In the second\npart, the client POST the authorization code along with its client secret to the authority server in order to get the\naccess token.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// Set the client credentials and the OAuth2 server</span>\n<span class=\"hljs-keyword\">var</span> credentials = <span class=\"hljs-type\">OAuth2ClientOptions</span>()\n  .setClientID(<span class=\"hljs-string\">&quot;&lt;client-id&gt;&quot;</span>)\n  .setClientSecret(<span class=\"hljs-string\">&quot;&lt;client-secret&gt;&quot;</span>)\n  .setSite(<span class=\"hljs-string\">&quot;https://api.oauth.com&quot;</span>)\n\n\n\n<span class=\"hljs-comment\">// Initialize the OAuth2 Library</span>\n<span class=\"hljs-keyword\">var</span> oauth2 = <span class=\"hljs-type\">OAuth2Auth</span>.create(vertx, <span class=\"hljs-type\">OAuth2FlowType</span>.<span class=\"hljs-type\">AUTH_CODE</span>, credentials)\n\n<span class=\"hljs-comment\">// Authorization oauth2 URI</span>\n<span class=\"hljs-keyword\">var</span> authorization_uri = oauth2.authorizeURL(<span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;redirect_uri&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:8080/callback&quot;</span>).put(<span class=\"hljs-string\">&quot;scope&quot;</span>, <span class=\"hljs-string\">&quot;&lt;scope&gt;&quot;</span>).put(<span class=\"hljs-string\">&quot;state&quot;</span>, <span class=\"hljs-string\">&quot;&lt;state&gt;&quot;</span>))\n\n<span class=\"hljs-comment\">// Redirect example using Vert.x</span>\nresponse.putHeader(<span class=\"hljs-string\">&quot;Location&quot;</span>, authorization_uri).setStatusCode(<span class=\"hljs-number\">302</span>).end()\n\n<span class=\"hljs-keyword\">var</span> tokenConfig = <span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;code&quot;</span>, <span class=\"hljs-string\">&quot;&lt;code&gt;&quot;</span>).put(<span class=\"hljs-string\">&quot;redirect_uri&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:3000/callback&quot;</span>)\n\n<span class=\"hljs-comment\">// Callbacks</span>\n<span class=\"hljs-comment\">// Save the access token</span>\noauth2.authenticateFuture(tokenConfig).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-type\">System</span>.err.println(<span class=\"hljs-string\">s&quot;Access Token Error: <span class=\"hljs-subst\">${res.cause().getMessage()}</span>&quot;</span>)\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_password_credentials_flow_2\"><a class=\"anchor\" href=\"#_password_credentials_flow_2\"></a>Password Credentials Flow</h4>\n<div class=\"paragraph\">\n<p>This flow is suitable when the resource owner has a trust relationship with the client, such as its computer\noperating system or a highly privileged application. Use this flow only when other flows are not viable or when you\nneed a fast way to test your application.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// Initialize the OAuth2 Library</span>\n<span class=\"hljs-keyword\">var</span> oauth2 = <span class=\"hljs-type\">OAuth2Auth</span>.create(vertx, <span class=\"hljs-type\">OAuth2FlowType</span>.<span class=\"hljs-type\">PASSWORD</span>)\n\n<span class=\"hljs-keyword\">var</span> tokenConfig = <span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;username&quot;</span>).put(<span class=\"hljs-string\">&quot;password&quot;</span>, <span class=\"hljs-string\">&quot;password&quot;</span>)\n\n<span class=\"hljs-comment\">// Callbacks</span>\n<span class=\"hljs-comment\">// Save the access token</span>\noauth2.authenticateFuture(tokenConfig).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-type\">System</span>.err.println(<span class=\"hljs-string\">s&quot;Access Token Error: <span class=\"hljs-subst\">${res.cause().getMessage()}</span>&quot;</span>)\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_client_credentials_flow_2\"><a class=\"anchor\" href=\"#_client_credentials_flow_2\"></a>Client Credentials Flow</h4>\n<div class=\"paragraph\">\n<p>This flow is suitable when client is requesting access to the protected resources under its control.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// Set the client credentials and the OAuth2 server</span>\n<span class=\"hljs-keyword\">var</span> credentials = <span class=\"hljs-type\">OAuth2ClientOptions</span>()\n  .setClientID(<span class=\"hljs-string\">&quot;&lt;client-id&gt;&quot;</span>)\n  .setClientSecret(<span class=\"hljs-string\">&quot;&lt;client-secret&gt;&quot;</span>)\n  .setSite(<span class=\"hljs-string\">&quot;https://api.oauth.com&quot;</span>)\n\n\n\n<span class=\"hljs-comment\">// Initialize the OAuth2 Library</span>\n<span class=\"hljs-keyword\">var</span> oauth2 = <span class=\"hljs-type\">OAuth2Auth</span>.create(vertx, <span class=\"hljs-type\">OAuth2FlowType</span>.<span class=\"hljs-type\">CLIENT</span>, credentials)\n\n<span class=\"hljs-keyword\">var</span> tokenConfig = <span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>()\n\n<span class=\"hljs-comment\">// Callbacks</span>\n<span class=\"hljs-comment\">// Save the access token</span>\noauth2.authenticateFuture(tokenConfig).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-type\">System</span>.err.println(<span class=\"hljs-string\">s&quot;Access Token Error: <span class=\"hljs-subst\">${res.cause().getMessage()}</span>&quot;</span>)\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_openid_connect_discovery\"><a class=\"anchor\" href=\"#_openid_connect_discovery\"></a>OpenID Connect Discovery</h3>\n<div class=\"paragraph\">\n<p>There is limited support for OpenID Discovery servers. Using OIDC Discovery will simplify the configuration of your\nauth module into a single line of code, for example, consider setting up your auth using Google:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-type\">OpenIDConnectAuth</span>.discover(vertx, <span class=\"hljs-type\">OAuth2ClientOptions</span>()\n  .setSite(<span class=\"hljs-string\">&quot;https://accounts.google.com&quot;</span>)\n  .setClientID(<span class=\"hljs-string\">&quot;clientId&quot;</span>)\n, {\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// the setup call succeeded.</span>\n    <span class=\"hljs-comment\">// at this moment your auth is ready to use and</span>\n    <span class=\"hljs-comment\">// google signature keys are loaded so tokens can be decoded and verified.</span>\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Behind the scenes a couple of actions are performed:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>HTTP get request to the <code>.well-known/openid-configuration</code> resource</p>\n</li>\n<li>\n<p>Validation of the response <code>issuer</code> field as mandated by the spec (the issuer value must match the request one)</p>\n</li>\n<li>\n<p>If the JWK uri is present, keys are loaded from the server and added to the auth keychain</p>\n</li>\n<li>\n<p>the auth module is configure and returned to the user.</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>A couple of well known OpenID Connect Discovery providers are:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Keycloak: <code><a href=\"http://keycloakhost:keycloakport/auth/realms/{realm}\" class=\"bare\">http://keycloakhost:keycloakport/auth/realms/{realm}</a></code></p>\n</li>\n<li>\n<p>Google: <code><a href=\"https://accounts.google.com\" class=\"bare\">https://accounts.google.com</a></code></p>\n</li>\n<li>\n<p>SalesForce: <code><a href=\"https://login.salesforce.com\" class=\"bare\">https://login.salesforce.com</a></code></p>\n</li>\n<li>\n<p>Microsoft: <code><a href=\"https://login.windows.net/common\" class=\"bare\">https://login.windows.net/common</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>This and the given <code>client id</code> is enough to configure your auth provider object.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_accesstoken_object\"><a class=\"anchor\" href=\"#_accesstoken_object\"></a>AccessToken object</h3>\n<div class=\"paragraph\">\n<p>When a token expires we need to refresh it. OAuth2 offers the AccessToken class that add a couple of useful methods\nto refresh the access token when it is expired.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// Check if the token is expired. If expired it is refreshed.</span>\n<span class=\"hljs-keyword\">if</span> (token.expired()) {\n  <span class=\"hljs-comment\">// Callbacks</span>\n  token.refreshFuture().onComplete{\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n      <span class=\"hljs-comment\">// success</span>\n    }\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n      println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When you&#8217;ve done with the token or you want to log out, you can revoke the access token and refresh token.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// Revoke only the access token</span>\ntoken.revokeFuture(<span class=\"hljs-string\">&quot;access_token&quot;</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">&quot;Success&quot;</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_example_configuration_for_common_oauth2_providers\"><a class=\"anchor\" href=\"#_example_configuration_for_common_oauth2_providers\"></a>Example configuration for common OAuth2 providers</h3>\n<div class=\"paragraph\">\n<p>For convenience there are several helpers to assist your with your configuration. Currently we provide:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Azure Active Directory <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/AzureADAuth.html\">AzureADAuth</a></code></p>\n</li>\n<li>\n<p>Box.com <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/BoxAuth.html\">BoxAuth</a></code></p>\n</li>\n<li>\n<p>Dropbox <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/DropboxAuth.html\">DropboxAuth</a></code></p>\n</li>\n<li>\n<p>Facebook <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/FacebookAuth.html\">FacebookAuth</a></code></p>\n</li>\n<li>\n<p>Foursquare <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/FoursquareAuth.html\">FoursquareAuth</a></code></p>\n</li>\n<li>\n<p>Github <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/GithubAuth.html\">GithubAuth</a></code></p>\n</li>\n<li>\n<p>Google <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/GoogleAuth.html\">GoogleAuth</a></code></p>\n</li>\n<li>\n<p>Instagram <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/InstagramAuth.html\">InstagramAuth</a></code></p>\n</li>\n<li>\n<p>Keycloak <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/KeycloakAuth.html\">KeycloakAuth</a></code></p>\n</li>\n<li>\n<p>LinkedIn <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/LinkedInAuth.html\">LinkedInAuth</a></code></p>\n</li>\n<li>\n<p>Mailchimp <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/MailchimpAuth.html\">MailchimpAuth</a></code></p>\n</li>\n<li>\n<p>Salesforce <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/SalesforceAuth.html\">SalesforceAuth</a></code></p>\n</li>\n<li>\n<p>Shopify <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/ShopifyAuth.html\">ShopifyAuth</a></code></p>\n</li>\n<li>\n<p>Soundcloud <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/SoundcloudAuth.html\">SoundcloudAuth</a></code></p>\n</li>\n<li>\n<p>Stripe <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/StripeAuth.html\">StripeAuth</a></code></p>\n</li>\n<li>\n<p>Twitter <code><a href=\"../../scaladocs/io/vertx/scala/ext/auth/oauth2/providers/TwitterAuth.html\">TwitterAuth</a></code></p>\n</li>\n</ul>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_jboss_keycloak\"><a class=\"anchor\" href=\"#_jboss_keycloak\"></a>JBoss Keycloak</h4>\n<div class=\"paragraph\">\n<p>When using this Keycloak the provider has knowledge on how to parse access tokens and extract grants from inside.\nThis information is quite valuable since it allows to do authorization at the API level, for example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// you would get this config from the keycloak admin console</span>\n<span class=\"hljs-keyword\">var</span> keycloakJson = <span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;realm&quot;</span>, <span class=\"hljs-string\">&quot;master&quot;</span>).put(<span class=\"hljs-string\">&quot;realm-public-key&quot;</span>, <span class=\"hljs-string\">&quot;MIIBIjANBgkqhk...wIDAQAB&quot;</span>).put(<span class=\"hljs-string\">&quot;auth-server-url&quot;</span>, <span class=\"hljs-string\">&quot;http://localhost:9000/auth&quot;</span>).put(<span class=\"hljs-string\">&quot;ssl-required&quot;</span>, <span class=\"hljs-string\">&quot;external&quot;</span>).put(<span class=\"hljs-string\">&quot;resource&quot;</span>, <span class=\"hljs-string\">&quot;frontend&quot;</span>).put(<span class=\"hljs-string\">&quot;credentials&quot;</span>, <span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;secret&quot;</span>, <span class=\"hljs-string\">&quot;2fbf5e18-b923-4a83-9657-b4ebd5317f60&quot;</span>))\n\n<span class=\"hljs-comment\">// Initialize the OAuth2 Library</span>\n<span class=\"hljs-keyword\">var</span> oauth2 = <span class=\"hljs-type\">KeycloakAuth</span>.create(vertx, <span class=\"hljs-type\">OAuth2FlowType</span>.<span class=\"hljs-type\">PASSWORD</span>, keycloakJson)\n\n<span class=\"hljs-comment\">// first get a token (authenticate)</span>\noauth2.authenticateFuture(<span class=\"hljs-keyword\">new</span> io.vertx.core.json.<span class=\"hljs-type\">JsonObject</span>().put(<span class=\"hljs-string\">&quot;username&quot;</span>, <span class=\"hljs-string\">&quot;user&quot;</span>).put(<span class=\"hljs-string\">&quot;password&quot;</span>, <span class=\"hljs-string\">&quot;secret&quot;</span>)).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// error handling...</span>\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>We also provide a helper class for Keycloak so that we can we can easily retrieve decoded token and some necessary\ndata (e.g. <code>preferred_username</code>) from the Keycloak principal. For example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// you can get the decoded `id_token` from the Keycloak principal</span>\n<span class=\"hljs-keyword\">var</span> idToken = <span class=\"hljs-type\">KeycloakHelper</span>.idToken(principal)\n\n<span class=\"hljs-comment\">// you can also retrieve some properties directly from the Keycloak principal</span>\n<span class=\"hljs-comment\">// e.g. `preferred_username`</span>\n<span class=\"hljs-keyword\">var</span> username = <span class=\"hljs-type\">KeycloakHelper</span>.preferredUsername(principal)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Please remember that Keycloak <strong>does</strong> implement OpenID Connect, so you can configure it just by using it&#8217;s discovery url:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-type\">OpenIDConnectAuth</span>.discover(vertx, <span class=\"hljs-type\">OAuth2ClientOptions</span>()\n  .setSite(<span class=\"hljs-string\">&quot;http://server:port/auth/realms/your_realm&quot;</span>)\n  .setClientID(<span class=\"hljs-string\">&quot;clientId&quot;</span>)\n, {\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// the setup call succeeded.</span>\n    <span class=\"hljs-comment\">// at this moment your auth is ready to use and</span>\n    <span class=\"hljs-comment\">// google signature keys are loaded so tokens can be decoded and verified.</span>\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Since you can deploy your Keycloak server anywhere, just replace <code>server:port</code> with the correct value and the <code>your_realm</code>\nvalue with your application realm.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_google_server_to_server\"><a class=\"anchor\" href=\"#_google_server_to_server\"></a>Google Server to Server</h4>\n<div class=\"paragraph\">\n<p>The provider also supports Server to Server or the RFC7523 extension. This is a feature present on Google with their\nservice account.</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_token_introspection\"><a class=\"anchor\" href=\"#_token_introspection\"></a>Token Introspection</h3>\n<div class=\"paragraph\">\n<p>Tokens can be introspected in order to assert that they are still valid. Although there is RFC7662 for this purpose\nnot many providers implement it. Instead there are variations also known as <code>TokenInfo</code> end points. The OAuth2\nprovider will accept both end points as a configuration. Currently we are known to work with <code>Google</code> and <code>Keycloak</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Token introspection assumes that tokens are opaque, so they need to be validated on the provider server. Every time a\ntoken is validated it requires a round trip to the provider. Introspection can be performed at the OAuth2 level or at\nthe User level:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// OAuth2Auth level</span>\noauth2.introspectTokenFuture(<span class=\"hljs-string\">&quot;opaque string&quot;</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// token is valid!</span>\n    <span class=\"hljs-keyword\">var</span> accessToken = result\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}\n\n<span class=\"hljs-comment\">// User level</span>\ntoken.introspectFuture().onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// Token is valid!</span>\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_verifying_jwt_tokens\"><a class=\"anchor\" href=\"#_verifying_jwt_tokens\"></a>Verifying JWT tokens</h3>\n<div class=\"paragraph\">\n<p>We&#8217;ve just covered how to introspect a token however when dealing with JWT tokens one can reduce the amount of trips\nto the provider server thus enhancing your overall response times. In this case tokens will be verified using the\nJWT protocol at your application side only. Verifying JWT tokens is cheaper and offers better performance, however\ndue to the stateless nature of JWTs it is not possible to know if a user is logged out and a token is invalid. For\nthis specific case one needs to use the token introspection if the provider supports it.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// OAuth2Auth level</span>\noauth2.decodeTokenFuture(<span class=\"hljs-string\">&quot;jwt-token&quot;</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// token is valid!</span>\n    <span class=\"hljs-keyword\">var</span> accessToken = result\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Until now we covered mostly authentication, although the implementation is relying party (that means that the real\nauthentication happens somewhere else), there is more you can do with the handler. For example you can also do\nauthorization if the provider is known to support JSON web tokens. This is a common feature if your provider is a\nOpenId Connect provider or if the provider does support `access_token`s as JWTs.</p>\n</div>\n<div class=\"paragraph\">\n<p>Such provider is Keycloak that is a OpenId Connect implementation. In that case you will be able to perform\nauthorization in a very easy way.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_role_based_access_control\"><a class=\"anchor\" href=\"#_role_based_access_control\"></a>Role Based Access Control</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>OAuth2 is an AuthN protocol, however OpenId Connect adds JWTs to the token format which means that AuthZ can be encoded\nat the token level. Currently there are 2 known JWT AuthZ known formats:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Keycloak</p>\n</li>\n<li>\n<p>MicroProfile JWT 1.1 spec</p>\n</li>\n</ul>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_keycloak_jwt\"><a class=\"anchor\" href=\"#_keycloak_jwt\"></a>Keycloak JWT</h3>\n<div class=\"paragraph\">\n<p>Given that Keycloak does provide <code>JWT</code> `access_token`s one can authorize at two distinct levels:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>role</p>\n</li>\n<li>\n<p>authority</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>To distinct the two, the auth provider follows the same recommendations from the base user class, i.e.: use the`:` as\na separator for the two. It should be noted that both role and authorities do not need to be together, in the most\nsimple case an authority is enough.</p>\n</div>\n<div class=\"paragraph\">\n<p>In order to map to keycloak&#8217;s token format the following checks are performed:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>If no role is provided, it is assumed to the the provider realm name</p>\n</li>\n<li>\n<p>If the role is <code>realm</code> then the lookup happens in <code>realm_access</code> list</p>\n</li>\n<li>\n<p>If a role is provided then the lookup happends in the <code>resource_access</code> list under the role name</p>\n</li>\n</ol>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_check_for_a_specific_authorities\"><a class=\"anchor\" href=\"#_check_for_a_specific_authorities\"></a>Check for a specific authorities</h4>\n<div class=\"paragraph\">\n<p>Here is one example how you can perform authorization after the user has been loaded from the oauth2 handshake, for\nexample you want to see if the user can <code>print</code> in the current application:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">user.isAuthorizedFuture(<span class=\"hljs-string\">&quot;print&quot;</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">&quot;Success&quot;</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>However this is quite specific, you might want to verify if the user can <code>add-user</code> to the whole system (the realm):</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">user.isAuthorizedFuture(<span class=\"hljs-string\">&quot;realm:add-user&quot;</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">&quot;Success&quot;</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or if the user can access the <code>year-report</code> in the <code>finance</code> department:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">user.isAuthorizedFuture(<span class=\"hljs-string\">&quot;finance:year-report&quot;</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; println(<span class=\"hljs-string\">&quot;Success&quot;</span>)\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; println(<span class=\"hljs-string\">&quot;Failure&quot;</span>)\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_microprofile_jwt_1_1_spec\"><a class=\"anchor\" href=\"#_microprofile_jwt_1_1_spec\"></a>MicroProfile JWT 1.1 spec</h3>\n<div class=\"paragraph\">\n<p>Another format in the form of a spec is the MP-JWT 1.1. This spec defines a JSON array of strings under the property\nname <code>groups</code> that define the \"groups\" the token has an authority over.</p>\n</div>\n<div class=\"paragraph\">\n<p>In order to use this spec to assert AuthZ the right handler must be set:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// use the MP-JWT 1.1 spec handler to</span>\n<span class=\"hljs-comment\">// handle Role-Based Access Control (AuthZ)</span>\noauth2Auth.rbacHandler(<span class=\"hljs-type\">MicroProfileRBAC</span>.create())</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_token_management\"><a class=\"anchor\" href=\"#_token_management\"></a>Token Management</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_check_if_it_is_expired\"><a class=\"anchor\" href=\"#_check_if_it_is_expired\"></a>Check if it is expired</h3>\n<div class=\"paragraph\">\n<p>Tokens are usually fetched from the server and cached, in this case when used later they might have already expired\nand be invalid, you can verify if the token is still valid like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\"><span class=\"hljs-comment\">// internal validation against, expiration date</span>\n<span class=\"hljs-keyword\">var</span> isExpired = user.expired()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This call is totally offline, it could still happen that the Oauth2 server invalidated your token but you get a non\nexpired token result. The reason behind this is that the expiration is checked against the token expiration dates,\nnot before date and such values.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_refresh_token\"><a class=\"anchor\" href=\"#_refresh_token\"></a>Refresh token</h3>\n<div class=\"paragraph\">\n<p>There are times you know the token is about to expire and would like to avoid to redirect the user again to the login\nscreen. In this case you can refresh the token. To refresh a token you need to have already a user and call:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">user.refreshFuture().onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// the refresh call succeeded</span>\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_revoke_token\"><a class=\"anchor\" href=\"#_revoke_token\"></a>Revoke token</h3>\n<div class=\"paragraph\">\n<p>Since tokens can be shared across various applications you might want to disallow the usage of the current token by\nany application. In order to do this one needs to revoke the token against the Oauth2 server:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">user.revokeFuture(<span class=\"hljs-string\">&quot;access_token&quot;</span>).onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// the refresh call succeeded</span>\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It is important to note that this call requires a token type. The reason is because some providers will return more\nthan one token e.g.:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>id_token</p>\n</li>\n<li>\n<p>refresh_token</p>\n</li>\n<li>\n<p>access_token</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>So one needs to know what token to invalidate. It should be obvious that if you invalidate the <code>refresh_token</code> you&#8217;re\nstill logged in but you won&#8217;t be able to refresh anymore, which means that once the token expires you need to redirect\nthe user again to the login page.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_introspect\"><a class=\"anchor\" href=\"#_introspect\"></a>Introspect</h3>\n<div class=\"paragraph\">\n<p>Introspect a token is similar to a expiration check, however one needs to note that this check is fully online. This\nmeans that the check happens on the OAuth2 server.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">user.introspectFuture().onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// the introspection call succeeded</span>\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Important note is that even if the <code>expired()</code> call is <code>true</code> the return from the <code>introspect</code> call can still be an\nerror. This is because the OAuth2 might have received a request to invalidate the token or a loggout in between.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_logging_out\"><a class=\"anchor\" href=\"#_logging_out\"></a>Logging out</h3>\n<div class=\"paragraph\">\n<p>Logging out is not a <code>Oauth2</code> feature but it is present on <code>OpenID Connect</code> and most providers do support some sort\nof logging out. This provider also covers this area if the configuration is enough to let it make the call. For the\nuser this is as simple as:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-scala\" data-lang=\"scala\">user.logoutFuture().onComplete{\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Success</span>(result) =&gt; {\n    <span class=\"hljs-comment\">// the logout call succeeded</span>\n  }\n  <span class=\"hljs-keyword\">case</span> <span class=\"hljs-type\">Failure</span>(cause) =&gt; {\n    println(<span class=\"hljs-string\">s&quot;<span class=\"hljs-subst\">$cause</span>&quot;</span>)\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"3.9.2"},"__N_SSG":true}