{"pageProps":{"slug":"4.1.0/vertx-rx/java","title":"Vert.x RxJava","fallbackGitHubStars":138,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_vert_x_api_for_rxjava\">Vert.x API for RxJava</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_using_vert_x_api_for_rxjava1\">Using Vert.x API for RxJava1</a></li>\n<li><a href=\"#_read_stream_support\">Read stream support</a></li>\n<li><a href=\"#_write_stream_support\">Write stream support</a></li>\n<li><a href=\"#_handler_support\">Handler support</a></li>\n<li><a href=\"#_async_result_support\">Async result support</a></li>\n<li><a href=\"#_scheduler_support\">Scheduler support</a></li>\n<li><a href=\"#_json_unmarshalling\">Json unmarshalling</a></li>\n<li><a href=\"#_deploying_a_verticle\">Deploying a Verticle</a></li>\n</ul>\n</li>\n<li><a href=\"#_rxified_api\">Rxified API</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_embedding_rxfified_vert_x\">Embedding Rxfified Vert.x</a></li>\n<li><a href=\"#_as_a_verticle\">As a Verticle</a></li>\n</ul>\n</li>\n<li><a href=\"#_api_examples\">Api examples</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_eventbus_message_stream\">EventBus message stream</a></li>\n<li><a href=\"#_timers\">Timers</a></li>\n<li><a href=\"#_http_client_requests\">Http client requests</a></li>\n<li><a href=\"#_http_server_requests\">Http server requests</a></li>\n<li><a href=\"#_websocket_client\">Websocket client</a></li>\n<li><a href=\"#_websocket_server\">Websocket server</a></li>\n</ul>\n</li>\n</ul>\n</div>","contents":"<h1>Vert.x RxJava</h1>\n\n<div class=\"sect1\">\n<h2 id=\"_vert_x_api_for_rxjava\"><a class=\"anchor\" href=\"#_vert_x_api_for_rxjava\"></a>Vert.x API for RxJava</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a> is a popular library for composing asynchronous and event based programs using\nobservable sequences for the Java VM. Vert.x integrates naturally with RxJava, allowing using\nobservable wherever you can use streams or asynchronous results.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_vert_x_api_for_rxjava1\"><a class=\"anchor\" href=\"#_using_vert_x_api_for_rxjava1\"></a>Using Vert.x API for RxJava1</h3>\n<div class=\"paragraph\">\n<p>To use Vert.x API for RxJava1, add the following dependency to the <em>dependencies</em> section of your build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-rx-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-rx-java:4.1.0&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>There are two ways for using the RxJava API with Vert.x:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>via the original Vert.x API with the <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html\">RxHelper</a></code> helper class that provides static\nmethods for converting objects between Vert.x core API and RxJava API.</p>\n</li>\n<li>\n<p>via the <em>Rxified</em> Vert.x API enhancing the core Vert.x API.</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_read_stream_support\"><a class=\"anchor\" href=\"#_read_stream_support\"></a>Read stream support</h3>\n<div class=\"paragraph\">\n<p>RxJava <code>Observable</code> is a perfect match for Vert.x <code>ReadStream</code> class : both provide a flow of items.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#toObservable-io.vertx.core.streams.ReadStream-\">RxHelper.toObservable</a></code> static methods convert\na Vert.x read stream to an <code>rx.Observable</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fileSystem = vertx.fileSystem();\nfileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = RxHelper.toObservable(file);\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API provides a <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/ReadStream.html#toObservable--\">toObservable</a></code>  method on\n<code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/ReadStream.html\">ReadStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">FileSystem fs = vertx.fileSystem();\nfs.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = file.toObservable();\n  observable.forEach(data -&gt; System.out.println(<span class=\"hljs-string\">&quot;Read data: &quot;</span> + data.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>)));\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Such observables are <strong>hot</strong> observables, i.e. they will produce notifications regardless of subscriptions because\na <code>ReadStream</code> can potentially emit items spontaneously or not, depending on the implementation:</p>\n</div>\n<div class=\"paragraph\">\n<p>At subscription time, the adapter calls <code><a href=\"../../apidocs/io/vertx/core/streams/ReadStream.html#handler-io.vertx.core.Handler-\">handler</a></code>\nto set its own handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>Some <code>ReadStream</code> implementations can start to emit events after this call, others will emit events whether an\nhandler is set or not:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>AsyncFile</code> produces buffer events after the handler is set</p>\n</li>\n<li>\n<p><code>HttpServerRequest</code> produces events independantly of the handler (i.e buffer may be lost if no handler is set)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>In both cases, subscribing to the <code>Observable</code> in the same call is safe because the event loop or the worker\nverticles cannot be called concurrently, so the subscription will always happens before the handler starts emitting\ndata.</p>\n</div>\n<div class=\"paragraph\">\n<p>When you need to delay the subscription, you need to <code>pause</code> the <code>ReadStream</code> and then <code>resume</code> it, which is what\nyou would do with a <code>ReadStream</code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">server.requestHandler(request -&gt; {\n  <span class=\"hljs-keyword\">if</span> (request.method() == HttpMethod.POST) {\n\n    <span class=\"hljs-comment\">// Stop receiving buffers</span>\n    request.pause();\n\n    checkAuth(res -&gt; {\n\n      <span class=\"hljs-comment\">// Now we can receive buffers again</span>\n      request.resume();\n\n      <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n        Observable&lt;Buffer&gt; observable = request.toObservable();\n        observable.subscribe(buff -&gt; {\n          <span class=\"hljs-comment\">// Get buffers</span>\n        });\n      }\n    });\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Likewise it is possible to turn an existing <code>Observable</code> into a Vert.x <code>ReadStream</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#toReadStream-rx.Observable-\">RxHelper.toReadStream</a></code>  static methods convert\nan <code>rx.Observable</code> to a Vert.x read stream:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;Buffer&gt; observable = getObservable();\nReadStream&lt;Buffer&gt; readStream = RxHelper.toReadStream(observable);\nPump pump = Pump.pump(readStream, response);\npump.start();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_write_stream_support\"><a class=\"anchor\" href=\"#_write_stream_support\"></a>Write stream support</h3>\n<div class=\"paragraph\">\n<p>A <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>, like a <code>rx.Subscriber</code>, consumes items, and, when it can&#8217;t keep-up, collaborates with the producer to avoid an ever-growing backlog.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x provides the <code><a href=\"../../apidocs/io/vertx/rx/java/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> adapter that you can use to send <code>Observable</code> items to any <code><a href=\"../../apidocs/io/vertx/core/streams/WriteStream.html\">WriteStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Sending buffers to an HTTP server response</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nWriteStreamSubscriber&lt;io.vertx.core.buffer.Buffer&gt; subscriber = io.vertx.rx.java.RxHelper.toSubscriber(response);\nobservable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If you are progamming with the <em>Rxified</em> Vert.x API, the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> implementations provide a <code>toSubscriber</code> method.\nThe previous example then becomes even more straightforward:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\nobservable.subscribe(response.toSubscriber());</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nWhen the <code>Observable</code> terminates successfully, the adapter invokes the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html#end-io.vertx.core.Handler-\">end</a></code> method.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Caution</div>\n</td>\n<td class=\"content\">\nThe adapter sets the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> <code>drain</code> and <code>exception</code> handlers, so don&#8217;t use them after subscribing.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/WriteStreamSubscriber.html\">WriteStreamSubscriber</a></code> adapter is able to invoke callbacks when:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>the <code>Observable</code> terminates with an error, or</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> fails (e.g. HTTP connection is closed or filesystem is full), or</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> ends (i.e. all writes done and file is closed), or</p>\n</li>\n<li>\n<p>the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> ends with an error (i.e. all writes done and an error occured when closing the file)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>This allows for a more robust program design, as well as scheduling other tasks after the stream has been handled:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">response.setChunked(<span class=\"hljs-keyword\">true</span>);\n\nWriteStreamSubscriber&lt;Buffer&gt; subscriber = response.toSubscriber();\n\nsubscriber.onError(throwable -&gt; {\n  <span class=\"hljs-keyword\">if</span> (!response.headWritten() &amp;&amp; response.closed()) {\n    response.setStatusCode(<span class=\"hljs-number\">500</span>).end(<span class=\"hljs-string\">&quot;oops&quot;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// log error</span>\n  }\n});\n\nsubscriber.onWriteStreamError(throwable -&gt; {\n  <span class=\"hljs-comment\">// log error</span>\n});\n\nsubscriber.onWriteStreamEnd(() -&gt; {\n  <span class=\"hljs-comment\">// log end of transaction to audit system...</span>\n});\n\nobservable.subscribe(subscriber);</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nIf the <code><a href=\"../../apidocs/io/vertx/rxjava/core/streams/WriteStream.html\">WriteStream</a></code> fails, the adapter unsubscribes from the <code>Observable</code>.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_handler_support\"><a class=\"anchor\" href=\"#_handler_support\"></a>Handler support</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html\">RxHelper</a></code> can create an <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableHandler.html\">ObservableHandler</a></code>: an <code>Observable</code> with a\n<code><a href=\"../../apidocs/io/vertx/rx/java/ObservableHandler.html#toHandler--\">toHandler</a></code> method returning an <code>Handler&lt;T&gt;</code> implementation:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ObservableHandler&lt;Long&gt; observable = RxHelper.observableHandler();\nobservable.subscribe(id -&gt; {\n  <span class=\"hljs-comment\">// Fired</span>\n});\nvertx.setTimer(<span class=\"hljs-number\">1000</span>, observable.toHandler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API does not provide a specific API for handler.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_async_result_support\"><a class=\"anchor\" href=\"#_async_result_support\"></a>Async result support</h3>\n<div class=\"paragraph\">\n<p>You can create an RxJava <code>Subscriber</code> from an existing Vert.x <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> and subscribe\nit to an <code>Observable</code> or a <code>Single</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">observable.subscribe(RxHelper.toSubscriber(handler1));\n\n<span class=\"hljs-comment\">// Subscribe to a Single</span>\nsingle.subscribe(RxHelper.toSubscriber(handler2));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The Vert.x <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> construct occuring as last parameter of an asynchronous method can\nbe mapped to an observable of a single element:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>when the callback is a success, the observer <code>onNext</code> method is called with the item\nand the <code>onComplete</code> method is immediately invoked after</p>\n</li>\n<li>\n<p>when the callback is a failure, the observer <code>onError</code> method is called</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#observableFuture--\">RxHelper.observableFuture</a></code> method creates an <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableFuture.html\">ObservableFuture</a></code>:\nan <code>Observable</code> with a <code><a href=\"../../apidocs/io/vertx/rx/java/ObservableFuture.html#toHandler--\">toHandler</a></code> method returning a <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>\nimplementation:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ObservableFuture&lt;HttpServer&gt; observable = RxHelper.observableFuture();\nobservable.subscribe(\n    server -&gt; {\n      <span class=\"hljs-comment\">// Server is listening</span>\n    },\n    failure -&gt; {\n      <span class=\"hljs-comment\">// Server could not start</span>\n    }\n);\nvertx.createHttpServer(<span class=\"hljs-keyword\">new</span> HttpServerOptions().\n    setPort(<span class=\"hljs-number\">1234</span>).\n    setHost(<span class=\"hljs-string\">&quot;localhost&quot;</span>)\n).listen(observable.toHandler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>ObservableFuture&lt;Server&gt;</code> will get a single <code>HttpServer</code> object, if the <code>listen</code> operation fails,\nthe subscriber will be notified with the failure.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#toHandler-rx.Observer-\">RxHelper.toHandler</a></code> method adapts an existing <code>Observer</code> into an handler:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observer&lt;HttpServer&gt; observer = <span class=\"hljs-keyword\">new</span> Observer&lt;HttpServer&gt;() {\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(HttpServer o)</span> </span>{\n  }\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable e)</span> </span>{\n  }\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCompleted</span><span class=\"hljs-params\">()</span> </span>{\n  }\n};\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler = RxHelper.toFuture(observer);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It also works with just actions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Action1&lt;HttpServer&gt; onNext = httpServer -&gt; {};\nAction1&lt;Throwable&gt; onError = httpServer -&gt; {};\nAction0 onComplete = () -&gt; {};\n\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler1 = RxHelper.toFuture(onNext);\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler2 = RxHelper.toFuture(onNext, onError);\nHandler&lt;AsyncResult&lt;HttpServer&gt;&gt; handler3 = RxHelper.toFuture(onNext, onError, onComplete);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API duplicates each such method with the <code>rx</code> prefix that returns an RxJava <code>Single</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpServer&gt; single = vertx\n  .createHttpServer()\n  .rxListen(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>);\n\n<span class=\"hljs-comment\">// Subscribe to bind the server</span>\nsingle.\n    subscribe(\n        server -&gt; {\n          <span class=\"hljs-comment\">// Server is listening</span>\n        },\n        failure -&gt; {\n          <span class=\"hljs-comment\">// Server could not start</span>\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Such single are <strong>cold</strong> singles, and the corresponding API method is called on subscribe.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nthe <code>rx*</code> methods replace the <code>*Observable</code> of the previous <em>Rxified</em> versions with a semantic\nchange to be more in line with RxJava.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_scheduler_support\"><a class=\"anchor\" href=\"#_scheduler_support\"></a>Scheduler support</h3>\n<div class=\"paragraph\">\n<p>The reactive extension sometimes needs to schedule actions, for instance <code>Observable#timer</code> creates and returns\na timer that emit periodic events. By default, scheduled actions are managed by RxJava, it means that the\ntimer threads are not Vert.x threads and therefore not executing in a Vert.x event loop.</p>\n</div>\n<div class=\"paragraph\">\n<p>When an RxJava method deals with a scheduler, it accepts an overloaded method accepting an extra <code>rx.Scheduler</code>,\nthe <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#scheduler-io.vertx.core.Vertx-\">RxHelper.scheduler</a></code>  method will return a scheduler that can be used\nin such places.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.timer(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For blocking scheduled actions, a scheduler can be created with the <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#blockingScheduler-io.vertx.core.Vertx-\">RxHelper.blockingScheduler</a></code>\nmethod:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = RxHelper.blockingScheduler(vertx);\nObservable&lt;Integer&gt; obs = blockingObservable.observeOn(scheduler);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava can also be reconfigured to use the Vert.x scheduler, thanks to the scheduler hook created with\n<code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#schedulerHook-io.vertx.core.Vertx-\">RxHelper.schedulerHook</a></code>, the returned scheduler hook\nuses a blocking scheduler for IO actions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaSchedulersHook hook = RxHelper.schedulerHook(vertx);\nRxJavaHooks.setOnIOScheduler(f -&gt; hook.getIOScheduler());\nRxJavaHooks.setOnNewThreadScheduler(f -&gt; hook.getNewThreadScheduler());\nRxJavaHooks.setOnComputationScheduler(f -&gt; hook.getComputationScheduler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> Vert.x API provides also similar method on the <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html\">RxHelper</a></code> class:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = io.vertx.rxjava.core.RxHelper.scheduler(vertx);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">RxJavaSchedulersHook hook = io.vertx.rxjava.core.RxHelper.schedulerHook(vertx);\n  RxJavaHooks.setOnIOScheduler(f -&gt; hook.getIOScheduler());\n  RxJavaHooks.setOnNewThreadScheduler(f -&gt; hook.getNewThreadScheduler());\n  RxJavaHooks.setOnComputationScheduler(f -&gt; hook.getComputationScheduler());</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It is also possible to create a scheduler backed by a named worker pool. This can be useful if you want to re-use\nthe specific thread pool for scheduling blocking actions:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Scheduler scheduler = io.vertx.rxjava.core.RxHelper.scheduler(workerExecutor);\nObservable&lt;Long&gt; timer = Observable.interval(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, TimeUnit.MILLISECONDS, scheduler);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_json_unmarshalling\"><a class=\"anchor\" href=\"#_json_unmarshalling\"></a>Json unmarshalling</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#unmarshaller-java.lang.Class-\">RxHelper.unmarshaller</a></code> creates an <code>rx.Observable.Operator</code> that\ntransforms an <code>Observable&lt;Buffer&gt;</code> in json format into an object observable:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = RxHelper.toObservable(file);\n  observable.lift(RxHelper.unmarshaller(MyPojo.class)).subscribe(\n      mypojo -&gt; {\n        <span class=\"hljs-comment\">// Process the object</span>\n      }\n  );\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The same can be done with the <em>Rxified</em> helper:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">fileSystem.open(<span class=\"hljs-string\">&quot;/data.txt&quot;</span>, <span class=\"hljs-keyword\">new</span> OpenOptions(), result -&gt; {\n  AsyncFile file = result.result();\n  Observable&lt;Buffer&gt; observable = file.toObservable();\n  observable.lift(io.vertx.rxjava.core.RxHelper.unmarshaller(MyPojo.class)).subscribe(\n      mypojo -&gt; {\n        <span class=\"hljs-comment\">// Process the object</span>\n      }\n  );\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_deploying_a_verticle\"><a class=\"anchor\" href=\"#_deploying_a_verticle\"></a>Deploying a Verticle</h3>\n<div class=\"paragraph\">\n<p>The Rxified API cannot deploy an existing Verticle instance, the helper <code><a href=\"../../apidocs/io/vertx/rx/java/RxHelper.html#observableFuture--\">RxHelper.observableFuture</a></code> method\nprovides a solution to that.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#deployVerticle-io.vertx.rxjava.core.Vertx-io.vertx.core.Verticle-\">RxHelper.deployVerticle</a></code> does it automatically\nfor you, it deploys a <code>Verticle</code> and returns an <code>Observable&lt;String&gt;</code> of the deployment ID.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;String&gt; deployment = RxHelper.deployVerticle(vertx, verticle);\n\ndeployment.subscribe(id -&gt; {\n  <span class=\"hljs-comment\">// Deployed</span>\n}, err -&gt; {\n  <span class=\"hljs-comment\">// Could not deploy</span>\n});</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_rxified_api\"><a class=\"anchor\" href=\"#_rxified_api\"></a>Rxified API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <em>Rxified</em> API is a code generated version of the Vert.x API, just like the <em>JavaScript</em> or <em>Groovy</em>\nlanguage. The API uses the <code>io.vertx.rxjava</code> prefix, for instance the <code>io.vertx.core.Vertx</code> class is\ntranslated to the <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html\">Vertx</a></code> class.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_embedding_rxfified_vert_x\"><a class=\"anchor\" href=\"#_embedding_rxfified_vert_x\"></a>Embedding Rxfified Vert.x</h3>\n<div class=\"paragraph\">\n<p>Just use the <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html#vertx--\">Vertx.vertx</a></code> methods:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Vertx vertx = io.vertx.rxjava.core.Vertx.vertx();</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_as_a_verticle\"><a class=\"anchor\" href=\"#_as_a_verticle\"></a>As a Verticle</h3>\n<div class=\"paragraph\">\n<p>Extend the <code><a href=\"../../apidocs/io/vertx/rxjava/core/AbstractVerticle.html\">AbstractVerticle</a></code> class, it will wrap it for you:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">vertx</span>.<span class=\"hljs-title\">rxjava</span>.<span class=\"hljs-title\">core</span>.<span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Use Rxified Vertx here</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Deploying an RxJava verticle is still performed by the Java deployer and does not need a specified\ndeployer.</p>\n</div>\n<div class=\"paragraph\">\n<p>Verticles having an asynchronous start can override instead the <code>rxStart</code> method and return a <code>Completable</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyVerticle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">io</span>.<span class=\"hljs-title\">vertx</span>.<span class=\"hljs-title\">rxjava</span>.<span class=\"hljs-title\">core</span>.<span class=\"hljs-title\">AbstractVerticle</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Completable <span class=\"hljs-title\">rxStart</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">return</span> vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">&quot;Hello World&quot;</span>))\n      .rxListen()\n      .toCompletable();\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_api_examples\"><a class=\"anchor\" href=\"#_api_examples\"></a>Api examples</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Let&#8217;s study now a few examples of using Vert.x with RxJava.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_eventbus_message_stream\"><a class=\"anchor\" href=\"#_eventbus_message_stream\"></a>EventBus message stream</h3>\n<div class=\"paragraph\">\n<p>The event bus <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> provides naturally an <code>Observable&lt;Message&lt;T&gt;&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nObservable&lt;Message&lt;String&gt;&gt; observable = consumer.toObservable();\nSubscription sub = observable.subscribe(msg -&gt; {\n  <span class=\"hljs-comment\">// Got message</span>\n});\n\n<span class=\"hljs-comment\">// Unregisters the stream after 10 seconds</span>\nvertx.setTimer(<span class=\"hljs-number\">10000</span>, id -&gt; {\n  sub.unsubscribe();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/MessageConsumer.html\">MessageConsumer</a></code> provides a stream of <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/Message.html\">Message</a></code>.\nThe <code><a href=\"../../apidocs/io/vertx/rxjava/core/eventbus/Message.html#body--\">body</a></code> gives access to a new stream of message bodies if needed:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">EventBus eb = vertx.eventBus();\nMessageConsumer&lt;String&gt; consumer = eb.&lt;String&gt;consumer(<span class=\"hljs-string\">&quot;the-address&quot;</span>);\nObservable&lt;String&gt; observable = consumer.bodyStream().toObservable();</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>RxJava map/reduce composition style can then be used:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;Double&gt; observable = vertx.eventBus().\n    &lt;Double&gt;consumer(<span class=\"hljs-string\">&quot;heat-sensor&quot;</span>).\n    bodyStream().\n    toObservable();\n\nobservable.\n    buffer(<span class=\"hljs-number\">1</span>, TimeUnit.SECONDS).\n    map(samples -&gt; samples.\n        stream().\n        collect(Collectors.averagingDouble(d -&gt; d))).\n    subscribe(heat -&gt; {\n      vertx.eventBus().send(<span class=\"hljs-string\">&quot;news-feed&quot;</span>, <span class=\"hljs-string\">&quot;Current heat is &quot;</span> + heat);\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_timers\"><a class=\"anchor\" href=\"#_timers\"></a>Timers</h3>\n<div class=\"paragraph\">\n<p>Timer task can be created with <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html#timerStream-long-\">timerStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.timerStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback after 1 second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Periodic task can be created with <code><a href=\"../../apidocs/io/vertx/rxjava/core/Vertx.html#periodicStream-long-\">periodicStream</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(\n        id -&gt; {\n          System.out.println(<span class=\"hljs-string\">&quot;Callback every second&quot;</span>);\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The observable can be cancelled with an unsubscription:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">vertx.periodicStream(<span class=\"hljs-number\">1000</span>).\n    toObservable().\n    subscribe(<span class=\"hljs-keyword\">new</span> Subscriber&lt;Long&gt;() {\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNext</span><span class=\"hljs-params\">(Long aLong)</span> </span>{\n        <span class=\"hljs-comment\">// Callback</span>\n        unsubscribe();\n      }\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable e)</span> </span>{}\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCompleted</span><span class=\"hljs-params\">()</span> </span>{}\n    });</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_client_requests\"><a class=\"anchor\" href=\"#_http_client_requests\"></a>Http client requests</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClient.html#rxRequest-io.vertx.core.http.RequestOptions-\">rxRequest</a></code> provides a single of an\n<code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClientRequest.html\">HttpClientRequest</a></code>. The single reports a request failure.</p>\n</div>\n<div class=\"paragraph\">\n<p>Once you have a request, calling <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClientRequest.html#rxSend--\">rxSend</a></code> will\nsend the request and gives a response back.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> HttpClientOptions());\nSingle&lt;HttpClientResponse&gt; request = client\n  .rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\n  .flatMap(HttpClientRequest::rxSend);\nrequest.subscribe(\n    response -&gt; {\n      <span class=\"hljs-comment\">// Process the response</span>\n    },\n    error -&gt; {\n      <span class=\"hljs-comment\">// Could not connect</span>\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The response can be processed as an <code>Observable&lt;Buffer&gt;</code> with the\n<code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClientResponse.html#toObservable--\">toObservable</a></code> method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpClientResponse&gt; request = client\n  .rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\n  .flatMap(HttpClientRequest::rxSend);\nrequest.toObservable().\n    subscribe(\n        response -&gt; {\n          Observable&lt;Buffer&gt; observable = response.toObservable();\n          observable.forEach(\n              buffer -&gt; {\n                <span class=\"hljs-comment\">// Process buffer</span>\n              }\n          );\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The same flow can be achieved with the <code>flatMap</code> operation:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpClientResponse&gt; request = client\n  .rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\n  .flatMap(HttpClientRequest::rxSend);\nrequest.toObservable().\n    flatMap(HttpClientResponse::toObservable).\n    forEach(\n        buffer -&gt; {\n          <span class=\"hljs-comment\">// Process buffer</span>\n        }\n    );</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>We can also unmarshall the <code>Observable&lt;Buffer&gt;</code> into an object using the <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#unmarshaller-java.lang.Class-\">RxHelper.unmarshaller</a></code>\nstatic method. This method creates an <code>Rx.Observable.Operator</code> unmarshalling buffers to an object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Single&lt;HttpClientResponse&gt; request = client\n  .rxRequest(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>)\n  .flatMap(HttpClientRequest::rxSend);\nrequest.toObservable().\n    flatMap(HttpClientResponse::toObservable).\n    lift(io.vertx.rxjava.core.RxHelper.unmarshaller(MyPojo.class)).\n    forEach(\n        pojo -&gt; {\n          <span class=\"hljs-comment\">// Process pojo</span>\n        }\n    );</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_http_server_requests\"><a class=\"anchor\" href=\"#_http_server_requests\"></a>Http server requests</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpServer.html#requestStream--\">requestStream</a></code> provides a callback for each incoming\nrequest:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  <span class=\"hljs-comment\">// Process request</span>\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/core/http/HttpServerRequest.html\">HttpServerRequest</a></code> can then be adapted to an <code>Observable&lt;Buffer&gt;</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  Observable&lt;Buffer&gt; observable = request.toObservable();\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/RxHelper.html#unmarshaller-java.lang.Class-\">RxHelper.unmarshaller</a></code> can be used to parse and map\na json request to an object:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;HttpServerRequest&gt; requestObservable = server.requestStream().toObservable();\nrequestObservable.subscribe(request -&gt; {\n  Observable&lt;MyPojo&gt; observable = request.\n      toObservable().\n      lift(io.vertx.rxjava.core.RxHelper.unmarshaller(MyPojo.class));\n});</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_client\"><a class=\"anchor\" href=\"#_websocket_client\"></a>Websocket client</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpClient.html#rxWebSocket-int-java.lang.String-java.lang.String-\">rxWebSocket</a></code> provides a single callback when the websocket\nconnects, otherwise a failure:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">HttpClient client = vertx.createHttpClient(<span class=\"hljs-keyword\">new</span> HttpClientOptions());\nclient.rxWebSocket(<span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/the_uri&quot;</span>).subscribe(\n    ws -&gt; {\n      <span class=\"hljs-comment\">// Use the websocket</span>\n    },\n    error -&gt; {\n      <span class=\"hljs-comment\">// Could not connect</span>\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/WebSocket.html\">WebSocket</a></code> can then be turned into an <code>Observable&lt;Buffer&gt;</code> easily:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Observable&lt;Buffer&gt; dataObs = socket.toObservable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_websocket_server\"><a class=\"anchor\" href=\"#_websocket_server\"></a>Websocket server</h3>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/rxjava/core/http/HttpServer.html#webSocketStream--\">webSocketStream</a></code> provides a callback for each incoming\nconnection:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">Observable&lt;ServerWebSocket&gt; socketObservable = server.webSocketStream().toObservable();\nsocketObservable.subscribe(\n    socket -&gt; System.out.println(<span class=\"hljs-string\">&quot;Web socket connect&quot;</span>),\n    failure -&gt; System.out.println(<span class=\"hljs-string\">&quot;Should never be called&quot;</span>),\n    () -&gt; {\n      System.out.println(<span class=\"hljs-string\">&quot;Subscription ended or server closed&quot;</span>);\n    }\n);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code><a href=\"../../apidocs/io/vertx/core/http/ServerWebSocket.html\">ServerWebSocket</a></code> can be turned into an <code>Observable&lt;Buffer&gt;</code> easily:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">socketObservable.subscribe(\n    socket -&gt; {\n      Observable&lt;Buffer&gt; dataObs = socket.toObservable();\n      dataObs.subscribe(buffer -&gt; {\n        System.out.println(<span class=\"hljs-string\">&quot;Got message &quot;</span> + buffer.toString(<span class=\"hljs-string\">&quot;UTF-8&quot;</span>));\n      });\n    }\n);</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>","version":"4.1.0"},"__N_SSG":true}