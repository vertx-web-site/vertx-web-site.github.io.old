{"pageProps":{"slug":"3.9.4/vertx-service-proxy/java","title":"Vert.x Service Proxy","fallbackGitHubStars":63,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_using_vert_x_service_proxies\">Using Vert.x service proxies</a></li>\n<li><a href=\"#_introduction_to_service_proxies\">Introduction to service proxies</a></li>\n<li><a href=\"#_async_interface\">Async Interface</a></li>\n<li><a href=\"#_code_generation\">Code generation</a></li>\n<li><a href=\"#_exposing_your_service\">Exposing your service</a></li>\n<li><a href=\"#_proxy_creation\">Proxy creation</a></li>\n<li><a href=\"#_error_handling\">Error Handling</a></li>\n<li><a href=\"#_restrictions_for_service_interface\">Restrictions for service interface</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_return_types\">Return types</a></li>\n<li><a href=\"#_parameter_types\">Parameter types</a></li>\n<li><a href=\"#_overloaded_methods\">Overloaded methods</a></li>\n</ul>\n</li>\n<li><a href=\"#_convention_for_invoking_services_over_the_event_bus_without_proxies\">Convention for invoking services over the event bus (without proxies)</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Service Proxy</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>When you compose a Vert.x application, you may want to isolate a functionality somewhere and make it available to\nthe rest of your application. That&#8217;s the main purpose of service proxies. It lets you expose a <em>service</em> on the\nevent bus, so, any other Vert.x component can consume it, as soon as they know the <em>address</em> on which the service\nis published.</p>\n</div>\n<div class=\"paragraph\">\n<p>A <em>service</em> is described with a Java interface containing methods following the <em>async pattern</em>. Under the hood,\nmessages are sent on the event bus to invoke the service and get the response back. But for ease of use,\nit generates a <em>proxy</em> that you can invoke directly (using the API from the service interface).</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_vert_x_service_proxies\"><a class=\"anchor\" href=\"#_using_vert_x_service_proxies\"></a>Using Vert.x service proxies</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To <strong>use</strong> Vert.x Service Proxies, add the following dependency to the <em>dependencies</em> section of\nyour build descriptor:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compile <span class=\"hljs-string\">&#x27;io.vertx:vertx-service-proxy:3.9.4&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>To <strong>implement</strong> service proxies, also add:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Maven (in your <code>pom.xml</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-codegen<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>provided<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Gradle (in your <code>build.gradle</code> file):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">compileOnly <span class=\"hljs-string\">&#x27;io.vertx:vertx-codegen:3.9.4&#x27;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Be aware that as the service proxy mechanism relies on code generation, so modifications to the <em>service interface</em>\nrequire to re-compile the sources to regenerate the code.</p>\n</div>\n<div class=\"paragraph\">\n<p>To generate the proxies in different languages, you will need to add the <em>language</em> dependency such as\n<code>vertx-lang-groovy</code> for Groovy.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_introduction_to_service_proxies\"><a class=\"anchor\" href=\"#_introduction_to_service_proxies\"></a>Introduction to service proxies</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Let&#8217;s have a look at service proxies and why they can be useful. Let&#8217;s imagine you have a <em>database service</em>\nexposed on the event bus, you should do something like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">JsonObject message = <span class=\"hljs-keyword\">new</span> JsonObject();\nmessage.put(<span class=\"hljs-string\">&quot;collection&quot;</span>, <span class=\"hljs-string\">&quot;mycollection&quot;</span>)\n    .put(<span class=\"hljs-string\">&quot;document&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;tim&quot;</span>));\nDeliveryOptions options = <span class=\"hljs-keyword\">new</span> DeliveryOptions().addHeader(<span class=\"hljs-string\">&quot;action&quot;</span>, <span class=\"hljs-string\">&quot;save&quot;</span>);\nvertx.eventBus().request(<span class=\"hljs-string\">&quot;database-service-address&quot;</span>, message, options, res2 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res2.succeeded()) {\n    <span class=\"hljs-comment\">// done</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// failure</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When creating a service there&#8217;s a certain amount of boilerplate code to listen on the event bus for incoming\nmessages, route them to the appropriate method and return results on the event bus.</p>\n</div>\n<div class=\"paragraph\">\n<p>With Vert.x service proxies, you can avoid writing all that boilerplate code and concentrate on writing your service.</p>\n</div>\n<div class=\"paragraph\">\n<p>You write your service as a Java interface and annotate it with the <code>@ProxyGen</code> annotation, for example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n <span class=\"hljs-comment\">// A couple of factory methods to create an instance and a proxy</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">create</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl(vertx);\n }\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Vertx vertx,\n   String address)</span> </span>{\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceVertxEBProxy(vertx, address);\n }\n\n<span class=\"hljs-comment\">// Actual service operations here...</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String collection, JsonObject document,\n  Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler)</span></span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Given the interface, Vert.x will generate all the boilerplate code required to access your service over the event\nbus, and it will also generate a <strong>client side proxy</strong> for your service, so your clients can use a rich idiomatic\nAPI for your service instead of having to manually craft event bus messages to send. The client side proxy will\nwork irrespective of where your service actually lives on the event bus (potentially on a different machine).</p>\n</div>\n<div class=\"paragraph\">\n<p>That means you can interact with your service like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SomeDatabaseService service = SomeDatabaseService.createProxy(vertx,\n    <span class=\"hljs-string\">&quot;database-service-address&quot;</span>);\n\n<span class=\"hljs-comment\">// Save some data in the database - this time using the proxy</span>\nservice.save(<span class=\"hljs-string\">&quot;mycollection&quot;</span>, <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;tim&quot;</span>), res2 -&gt; {\n  <span class=\"hljs-keyword\">if</span> (res2.succeeded()) {\n    <span class=\"hljs-comment\">// done</span>\n  }\n});</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also combine <code>@ProxyGen</code> with language API code generation (<code>@VertxGen</code>) in order to create service stubs\nin any of the languages supported by Vert.x - this means you can write your service once in Java and interact with it\nthrough an idiomatic other language API irrespective of whether the service lives locally or is somewhere else on\nthe event bus entirely. For this don&#8217;t forget to add the dependency on your language in your build descriptor:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span> <span class=\"hljs-comment\">// Generate service proxies</span>\n<span class=\"hljs-meta\">@VertxGen</span> <span class=\"hljs-comment\">// Generate the clients</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n <span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_async_interface\"><a class=\"anchor\" href=\"#_async_interface\"></a>Async Interface</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To be used by the service-proxy generation, the <em>service interface</em> must comply to a couple of rules. First it\nshould follow the async pattern. To return a result, the method should declare a <code>Handler&lt;AsyncResult&lt;ResultType&gt;&gt;</code> parameter.\n<code>ResultType</code> can be another proxy (and so a proxies can be factories for other proxies).</p>\n</div>\n<div class=\"paragraph\">\n<p>Let&#8217;s see an example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n<span class=\"hljs-comment\">// A couple of factory methods to create an instance and a proxy</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">create</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl(vertx);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Vertx vertx, String address)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceVertxEBProxy(vertx, address);\n}\n\n<span class=\"hljs-comment\">// A method notifying the completion without a result (void)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">save</span><span class=\"hljs-params\">(String collection, JsonObject document,\n  Handler&lt;AsyncResult&lt;Void&gt;&gt; result)</span></span>;\n\n<span class=\"hljs-comment\">// A method providing a result (a json object)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findOne</span><span class=\"hljs-params\">(String collection, JsonObject query,\n  Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; result)</span></span>;\n\n<span class=\"hljs-comment\">// Create a connection</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize,\n  Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler)</span></span>;\n\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>with:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-meta\">@VertxGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">MyDatabaseConnection</span> </span>{\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(JsonObject someData)</span></span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">commit</span><span class=\"hljs-params\">(Handler&lt;AsyncResult&lt;Void&gt;&gt; resultHandler)</span></span>;\n\n<span class=\"hljs-meta\">@ProxyClose</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">close</span><span class=\"hljs-params\">()</span></span>;\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also declare that a particular method unregisters the proxy by annotating it with the <code>@ProxyClose</code>\nannotation. The proxy instance is disposed when this method is called.</p>\n</div>\n<div class=\"paragraph\">\n<p>More constraints on the <em>service interfaces</em> are described below.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_code_generation\"><a class=\"anchor\" href=\"#_code_generation\"></a>Code generation</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Service annotated with <code>@ProxyGen</code> annotation trigger the generation of the service helper classes:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>The service proxy: a compile time generated proxy that uses the <code>EventBus</code> to interact with the service via messages</p>\n</li>\n<li>\n<p>The service handler: a compile time generated <code>EventBus</code> handler that reacts to events sent by the proxy</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Generated proxies and handlers are named after the service class, for example if the service is named <code>MyService</code>\nthe handler is called <code>MyServiceProxyHandler</code> and the proxy is called <code>MyServiceEBProxy</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>In addition Vert.x Core provides a generator creating data object converters to ease data object usage in\nservice proxies. Such converter provides a basis for the <code>JsonObject</code> constructor and the <code>toJson()</code> method\nthat are necessary for using data objects in service proxies.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <em>codegen</em> annotation processor generates these classes at compilation time. It is a feature of the Java\ncompiler so <em>no extra step</em> is required, it is just a matter of configuring correctly your build:</p>\n</div>\n<div class=\"paragraph\">\n<p>Just add the <code>io.vertx:vertx-codegen:processor</code> and <code>io.vertx:vertx-service-proxy</code>\ndependencies to your build.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here a configuration example for Maven:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-codegen<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>processor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.vertx<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>vertx-service-proxy<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.9.4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This feature can also be used in Gradle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>compile \"io.vertx:vertx-codegen:3.9.4:processor\"\ncompile \"io.vertx:vertx-service-proxy:3.9.4\"</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>IDE provides usually support for annotation processors.</p>\n</div>\n<div class=\"paragraph\">\n<p>The codegen <code>processor</code> classifier adds to the jar the automatic configuration of the service proxy annotation processor\nvia the <code>META-INF/services</code> plugin mechanism.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you want you can use it too with the regular jar but you need then to declare the annotation processor\nexplicitly, for instance in Maven:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">annotationProcessors</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">annotationProcessor</span>&gt;</span>io.vertx.codegen.CodeGenProcessor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">annotationProcessor</span>&gt;</span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">annotationProcessors</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_exposing_your_service\"><a class=\"anchor\" href=\"#_exposing_your_service\"></a>Exposing your service</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Once you have your <em>service interface</em>, compile the source to generate the stub and proxies. Then, you need some\ncode to \"register\" your service on the event bus:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">SomeDatabaseService service = <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl();\n<span class=\"hljs-comment\">// Register the handler</span>\n<span class=\"hljs-keyword\">new</span> ServiceBinder(vertx)\n  .setAddress(<span class=\"hljs-string\">&quot;database-service-address&quot;</span>)\n  .register(SomeDatabaseService.class, service);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This can be done in a verticle, or anywhere in your code.</p>\n</div>\n<div class=\"paragraph\">\n<p>Once registered, the service becomes accessible. If you are running your application on a cluster, the service is\navailable from any host.</p>\n</div>\n<div class=\"paragraph\">\n<p>To withdraw your service, use the <code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceBinder.html#unregister-io.vertx.core.eventbus.MessageConsumer-\">unregister</a></code>\nmethod:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceBinder binder = <span class=\"hljs-keyword\">new</span> ServiceBinder(vertx);\n\n<span class=\"hljs-comment\">// Create an instance of your service implementation</span>\nSomeDatabaseService service = <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceImpl();\n<span class=\"hljs-comment\">// Register the handler</span>\nMessageConsumer&lt;JsonObject&gt; consumer = binder\n  .setAddress(<span class=\"hljs-string\">&quot;database-service-address&quot;</span>)\n  .register(SomeDatabaseService.class, service);\n\n<span class=\"hljs-comment\">// ....</span>\n\n<span class=\"hljs-comment\">// Unregister your service.</span>\nbinder.unregister(consumer);</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_proxy_creation\"><a class=\"anchor\" href=\"#_proxy_creation\"></a>Proxy creation</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Now that the service is exposed, you probably want to consume it. For this, you need to create a proxy. The proxy\ncan be created using the <code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceProxyBuilder.html\">ServiceProxyBuilder</a></code> class:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ServiceProxyBuilder builder = <span class=\"hljs-keyword\">new</span> ServiceProxyBuilder(vertx).setAddress(<span class=\"hljs-string\">&quot;database-service-address&quot;</span>);\n\nSomeDatabaseService service = builder.build(SomeDatabaseService.class);\n<span class=\"hljs-comment\">// or with delivery options:</span>\nSomeDatabaseService service2 = builder.setOptions(options).build(SomeDatabaseService.class);</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The second method takes an instance of <code><a href=\"../../apidocs/io/vertx/core/eventbus/DeliveryOptions.html\">DeliveryOptions</a></code> where you can configure the\nmessage delivery (such as the timeout).</p>\n</div>\n<div class=\"paragraph\">\n<p>Alternatively, you can use the generated proxy class. The proxy class name is the <em>service interface</em> class name\nfollowed by <code>VertxEBProxy</code>. For instance, if your <em>service interface</em> is named <code>SomeDatabaseService</code>, the proxy\nclass is named <code>SomeDatabaseServiceVertxEBProxy</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Generally, <em>service interface</em> contains a <code>createProxy</code> static method to create the proxy. But this is not required:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ProxyGen</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n\n<span class=\"hljs-comment\">// Method to create the proxy.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> SomeDatabaseService <span class=\"hljs-title\">createProxy</span><span class=\"hljs-params\">(Vertx vertx, String address)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDatabaseServiceVertxEBProxy(vertx, address);\n}\n\n<span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_error_handling\"><a class=\"anchor\" href=\"#_error_handling\"></a>Error Handling</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Service methods may return errors to the client by passing a failed <code>Future</code> containing a <code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceException.html\">ServiceException</a></code>\ninstance to the method&#8217;s <code>Handler</code>. A <code>ServiceException</code> contains an <code>int</code> failure code, a message, and an optional\n<code>JsonObject</code> containing any extra information deemed important to return to the caller. For convenience, the\n<code><a href=\"../../apidocs/io/vertx/serviceproxy/ServiceException.html#fail-int-java.lang.String-\">ServiceException.fail</a></code> factory method can be used to create an instance of\n<code>ServiceException</code> already wrapped in a failed <code>Future</code>. For example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeDatabaseServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> BAD_SHOE_SIZE = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> CONNECTION_FAILED = <span class=\"hljs-number\">43</span>;\n\n <span class=\"hljs-comment\">// Create a connection</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize, Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler)</span> </span>{\n   <span class=\"hljs-keyword\">if</span> (!shoeSize.equals(<span class=\"hljs-string\">&quot;9&quot;</span>)) {\n     resultHandler.handle(ServiceException.fail(BAD_SHOE_SIZE, <span class=\"hljs-string\">&quot;The shoe size must be 9!&quot;</span>,\n       <span class=\"hljs-keyword\">new</span> JsonObject().put(<span class=\"hljs-string\">&quot;shoeSize&quot;</span>, shoeSize));\n    } <span class=\"hljs-keyword\">else</span> {\n       doDbConnection(result -&gt; {\n         <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n           resultHandler.handle(Future.succeededFuture(result.result()));\n         } <span class=\"hljs-keyword\">else</span> {\n           resultHandler.handle(ServiceException.fail(CONNECTION_FAILED, result.cause().getMessage()));\n         }\n       });\n    }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The client side can then check if the <code>Throwable</code> it receives from a failed <code>AsyncResult</code> is a <code>ServiceException</code>,\nand if so, check the specific error code inside. It can use this information to differentiate business logic\nerrors from system errors (like the service not being registered with the Event Bus), and to determine exactly\nwhich business logic error occurred.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(String shoeSize, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; handler)</span> </span>{\n SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);\n service.createConnection(<span class=\"hljs-string\">&quot;8&quot;</span>, result -&gt; {\n   <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n     <span class=\"hljs-comment\">// Do success stuff.</span>\n   } <span class=\"hljs-keyword\">else</span> {\n     <span class=\"hljs-keyword\">if</span> (result.cause() <span class=\"hljs-keyword\">instanceof</span> ServiceException) {\n       ServiceException exc = (ServiceException) result.cause();\n       <span class=\"hljs-keyword\">if</span> (exc.failureCode() == SomeDatabaseServiceImpl.BAD_SHOE_SIZE) {\n         handler.handle(Future.failedFuture(\n           <span class=\"hljs-keyword\">new</span> InvalidInputError(<span class=\"hljs-string\">&quot;You provided a bad shoe size: &quot;</span> +\n             exc.getDebugInfo().getString(<span class=\"hljs-string\">&quot;shoeSize&quot;</span>))\n         ));\n       } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (exc.failureCode() == SomeDatabaseServiceImpl.CONNECTION) {\n         handler.handle(Future.failedFuture(\n           <span class=\"hljs-keyword\">new</span> ConnectionError(<span class=\"hljs-string\">&quot;Failed to connect to the DB&quot;</span>)));\n       }\n     } <span class=\"hljs-keyword\">else</span> {\n       <span class=\"hljs-comment\">// Must be a system error (e.g. No service registered for the proxy)</span>\n       handler.handle(Future.failedFuture(\n         <span class=\"hljs-keyword\">new</span> SystemError(<span class=\"hljs-string\">&quot;An unexpected error occurred: + &quot;</span> result.cause().getMessage())\n       ));\n     }\n   }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If desired, service implementations may also return a sub-class of <code>ServiceException</code>, as long as a\ndefault <code>MessageCodec</code> is registered for it . For example, given the following <code>ServiceException</code> sub-class:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShoeSizeException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ServiceException</span> </span>{\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> BAD_SHOE_SIZE_ERROR = <span class=\"hljs-number\">42</span>;\n\n <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> String shoeSize;\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ShoeSizeException</span><span class=\"hljs-params\">(String shoeSize)</span> </span>{\n   <span class=\"hljs-keyword\">super</span>(BAD_SHOE_SIZE_ERROR, <span class=\"hljs-string\">&quot;In invalid shoe size was received: &quot;</span> + shoeSize);\n   <span class=\"hljs-keyword\">this</span>.shoeSize = shoeSize;\n }\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getShoeSize</span><span class=\"hljs-params\">()</span> </span>{\n   <span class=\"hljs-keyword\">return</span> extra;\n }\n\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">AsyncResult&lt;T&gt; <span class=\"hljs-title\">fail</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> failureCode, String message, String shoeSize)</span> </span>{\n   <span class=\"hljs-keyword\">return</span> Future.failedFuture(<span class=\"hljs-keyword\">new</span> MyServiceException(failureCode, message, shoeSize));\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>As long as a default <code>MessageCodec</code> is registered, the Service implementation can return the custom\nexception directly to the caller:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeDatabaseServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SomeDatabaseService</span> </span>{\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SomeDataBaseServiceImpl</span><span class=\"hljs-params\">(Vertx vertx)</span> </span>{\n   <span class=\"hljs-comment\">// Register on the service side. If using a local event bus, this is all</span>\n   <span class=\"hljs-comment\">// that&#x27;s required, since the proxy side will share the same Vertx instance.</span>\n SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);\n   vertx.eventBus().registerDefaultCodec(ShoeSizeException.class,\n     <span class=\"hljs-keyword\">new</span> ShoeSizeExceptionMessageCodec());\n }\n\n <span class=\"hljs-comment\">// Create a connection</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">createConnection</span><span class=\"hljs-params\">(String shoeSize, Handler&lt;AsyncResult&lt;MyDatabaseConnection&gt;&gt; resultHandler)</span> </span>{\n   <span class=\"hljs-keyword\">if</span> (!shoeSize.equals(<span class=\"hljs-string\">&quot;9&quot;</span>)) {\n     resultHandler.handle(ShoeSizeException.fail(shoeSize));\n   } <span class=\"hljs-keyword\">else</span> {\n     <span class=\"hljs-comment\">// Create the connection here</span>\n     resultHandler.Handle(Future.succeededFuture(myDbConnection));\n   }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Finally, the client can now check for the custom exception:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(String shoeSize, Handler&lt;AsyncResult&lt;JsonObject&gt;&gt; handler)</span> </span>{\n <span class=\"hljs-comment\">// If this code is running on a different node in the cluster, the</span>\n <span class=\"hljs-comment\">// ShoeSizeExceptionMessageCodec will need to be registered with the</span>\n <span class=\"hljs-comment\">// Vertx instance on this node, too.</span>\n SomeDatabaseService service = SomeDatabaseService.createProxy(vertx, SERVICE_ADDRESS);\n service.createConnection(<span class=\"hljs-string\">&quot;8&quot;</span>, result -&gt; {\n   <span class=\"hljs-keyword\">if</span> (result.succeeded()) {\n     <span class=\"hljs-comment\">// Do success stuff.</span>\n   } <span class=\"hljs-keyword\">else</span> {\n     <span class=\"hljs-keyword\">if</span> (result.cause() <span class=\"hljs-keyword\">instanceof</span> ShoeSizeException) {\n       ShoeSizeException exc = (ShoeSizeException) result.cause();\n       handler.handle(Future.failedFuture(\n         <span class=\"hljs-keyword\">new</span> InvalidInputError(<span class=\"hljs-string\">&quot;You provided a bad shoe size: &quot;</span> + exc.getShoeSize())));\n     } <span class=\"hljs-keyword\">else</span> {\n       <span class=\"hljs-comment\">// Must be a system error (e.g. No service registered for the proxy)</span>\n       handler.handle(Future.failedFuture(\n         <span class=\"hljs-keyword\">new</span> SystemError(<span class=\"hljs-string\">&quot;An unexpected error occurred: + &quot;</span> result.cause().getMessage())\n       ));\n     }\n   }\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Note that if you&#8217;re clustering <code>Vertx</code> instances, you&#8217;ll need to register the custom Exception&#8217;s <code>MessageCodec</code>\nwith each <code>Vertx</code> instance in the cluster.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_restrictions_for_service_interface\"><a class=\"anchor\" href=\"#_restrictions_for_service_interface\"></a>Restrictions for service interface</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>There are restrictions on the types and return values that can be used in a service method so that these are easy to\nmarshall over event bus messages and so they can be used asynchronously. They are:</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_return_types\"><a class=\"anchor\" href=\"#_return_types\"></a>Return types</h3>\n<div class=\"paragraph\">\n<p>Must be one of:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>void</code></p>\n</li>\n<li>\n<p><code>@Fluent</code> and return reference to the service (<code>this</code>):</p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@Fluent</span>\n<span class=\"hljs-function\">SomeDatabaseService <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">()</span></span>;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This is because methods must not block and it&#8217;s not possible to return a result immediately without blocking if\nthe service is remote.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_parameter_types\"><a class=\"anchor\" href=\"#_parameter_types\"></a>Parameter types</h3>\n<div class=\"paragraph\">\n<p>Let <code>JSON</code> = <code>JsonObject | JsonArray</code>\nLet <code>PRIMITIVE</code> = Any primitive type or boxed primitive type</p>\n</div>\n<div class=\"paragraph\">\n<p>Parameters can be any of:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>JSON</code></p>\n</li>\n<li>\n<p><code>PRIMITIVE</code></p>\n</li>\n<li>\n<p><code>List&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>List&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p><code>Map&lt;String, JSON&gt;</code></p>\n</li>\n<li>\n<p><code>Map&lt;String, PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p>Any <em>Enum</em> type</p>\n</li>\n<li>\n<p>Any class annotated with <code>@DataObject</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>If an asynchronous result is required a last parameter of type <code>Handler&lt;AsyncResult&lt;R&gt;&gt;</code> can be provided.</p>\n</div>\n<div class=\"paragraph\">\n<p><code>R</code> can be any of:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>JSON</code></p>\n</li>\n<li>\n<p><code>PRIMITIVE</code></p>\n</li>\n<li>\n<p><code>List&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>List&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;JSON&gt;</code></p>\n</li>\n<li>\n<p><code>Set&lt;PRIMITIVE&gt;</code></p>\n</li>\n<li>\n<p>Any <em>Enum</em> type</p>\n</li>\n<li>\n<p>Any class annotated with <code>@DataObject</code></p>\n</li>\n<li>\n<p>Another proxy</p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_overloaded_methods\"><a class=\"anchor\" href=\"#_overloaded_methods\"></a>Overloaded methods</h3>\n<div class=\"paragraph\">\n<p>There must be no overloaded service methods. (<em>i.e.</em> more than one with the same name, regardless the signature).</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_convention_for_invoking_services_over_the_event_bus_without_proxies\"><a class=\"anchor\" href=\"#_convention_for_invoking_services_over_the_event_bus_without_proxies\"></a>Convention for invoking services over the event bus (without proxies)</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Service Proxies assume that event bus messages follow a certain format so they can be used to invoke services.</p>\n</div>\n<div class=\"paragraph\">\n<p>Of course, you don&#8217;t <strong>have to</strong> use client proxies to access remote service if you don&#8217;t want to. It&#8217;s perfectly acceptable\nto interact with them by just sending messages over the event bus.</p>\n</div>\n<div class=\"paragraph\">\n<p>In order for services to be interacted with a consistent way the following message formats <strong>must be used</strong> for any\nVert.x services.</p>\n</div>\n<div class=\"paragraph\">\n<p>The format is very simple:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>There should be a header called <code>action</code> which gives the name of the action to perform.</p>\n</li>\n<li>\n<p>The body of the message should be a <code>JsonObject</code>, there should be one field in the object for each argument needed by the action.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>For example to invoke an action called <code>save</code> which expects a String collection and a JsonObject document:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>Headers:\n   \"action\": \"save\"\nBody:\n   {\n       \"collection\", \"mycollection\",\n       \"document\", {\n           \"name\": \"tim\"\n       }\n   }</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The above convention should be used whether or not service proxies are used to create services, as it allows services\nto be interacted with consistently.</p>\n</div>\n<div class=\"paragraph\">\n<p>In the case where service proxies are used the \"action\" value should map to the name of an action method in the\nservice interface and each <code>[key, value]</code> in the body should map to a <code>[arg_name, arg_value]</code> in the action method.</p>\n</div>\n<div class=\"paragraph\">\n<p>For return values the service should use the <code>message.reply(&#8230;&#8203;)</code> method to send back a return value - this can be of\nany type supported by the event bus. To signal a failure the method <code>message.fail(&#8230;&#8203;)</code> should be used.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you are using service proxies the generated code will handle this for you automatically.</p>\n</div>\n</div>\n</div>","version":"3.9.4"},"__N_SSG":true}