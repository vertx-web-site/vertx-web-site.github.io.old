{"pageProps":{"slug":"4.0.2/vertx-junit5/java","title":"Vert.x JUnit 5 integration","fallbackGitHubStars":36,"toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_use_it_in_your_build\">Use it in your build</a></li>\n<li><a href=\"#_why_testing_asynchronous_code_is_different\">Why testing asynchronous code is different</a></li>\n<li><a href=\"#_a_test_context_for_asynchronous_executions\">A test context for asynchronous executions</a></li>\n<li><a href=\"#_use_any_assertion_library\">Use any assertion library</a></li>\n<li><a href=\"#_checkpoint_when_there_are_multiple_success_conditions\">Checkpoint when there are multiple success conditions</a></li>\n<li><a href=\"#_integration_with_junit_5\">Integration with JUnit 5</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_test_methods\">Test methods</a></li>\n<li><a href=\"#_lifecycle_methods\">Lifecycle methods</a></li>\n</ul>\n</li>\n<li><a href=\"#_support_for_additional_parameter_types\">Support for additional parameter types</a></li>\n<li><a href=\"#_parameter_ordering\">Parameter ordering</a></li>\n<li><a href=\"#_parameterized_tests_with_methodsource\">Parameterized tests with <code>@MethodSource</code></a></li>\n</ul>\n</div>","contents":"<h1>Vert.x JUnit 5 integration</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This module offers integration and support for writing Vert.x tests with JUnit 5.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_use_it_in_your_build\"><a class=\"anchor\" href=\"#_use_it_in_your_build\"></a>Use it in your build</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>groupId</code>: <code>io.vertx</code></p>\n</li>\n<li>\n<p><code>artifactId</code>: <code>vertx-junit5</code></p>\n</li>\n<li>\n<p><code>version</code>: (current Vert.x release or SNAPSHOT)</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_why_testing_asynchronous_code_is_different\"><a class=\"anchor\" href=\"#_why_testing_asynchronous_code_is_different\"></a>Why testing asynchronous code is different</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Testing asynchronous operations requires more tools than what a test harness like JUnit provides.\nLet us consider a typical Vert.x creation of a HTTP server, and put it into a JUnit test:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ATest</span> {\n  <span class=\"hljs-type\">Vertx</span> <span class=\"hljs-variable\">vertx</span> <span class=\"hljs-operator\">=</span> Vertx.vertx();\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">start_server</span><span class=\"hljs-params\">()</span> {\n    vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end(<span class=\"hljs-string\">&quot;Ok&quot;</span>))\n      .listen(<span class=\"hljs-number\">16969</span>, ar -&gt; {\n        <span class=\"hljs-comment\">// (we can check here if the server started or not)</span>\n      });\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>There are issues here since <code>listen</code> does not block as it tries to start a HTTP server asynchronously.\nWe cannot simply assume that the server has properly started upon a <code>listen</code> invocation return.\nAlso:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>the callback passed to <code>listen</code> will be executed from a Vert.x event loop thread, which is different from the thread that runs the JUnit test, and</p>\n</li>\n<li>\n<p>right after calling <code>listen</code>, the test exits and is being considered to be passed, while the HTTP server may not even have finished starting, and</p>\n</li>\n<li>\n<p>since the <code>listen</code> callback executes on a different thread than the one executing the test, then any exception such as one thrown by a failed assertion cannot be capture by the JUnit runner.</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_a_test_context_for_asynchronous_executions\"><a class=\"anchor\" href=\"#_a_test_context_for_asynchronous_executions\"></a>A test context for asynchronous executions</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The first contribution of this module is a <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> object that:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>allows waiting for operations in other threads to notify of completion, and</p>\n</li>\n<li>\n<p>supports assertion failures to be received to mark a test as failed.</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>Here is a very basic usage:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BTest</span> {\n  <span class=\"hljs-type\">Vertx</span> <span class=\"hljs-variable\">vertx</span> <span class=\"hljs-operator\">=</span> Vertx.vertx();\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">start_http_server</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Throwable {\n    <span class=\"hljs-type\">VertxTestContext</span> <span class=\"hljs-variable\">testContext</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">VertxTestContext</span>();\n\n    vertx.createHttpServer()\n      .requestHandler(req -&gt; req.response().end())\n      .listen(<span class=\"hljs-number\">16969</span>)\n      .onComplete(testContext.succeedingThenComplete()); <b class=\"conum\">(1)</b>\n\n    assertThat(testContext.awaitCompletion(<span class=\"hljs-number\">5</span>, TimeUnit.SECONDS)).isTrue(); <b class=\"conum\">(2)</b>\n    <span class=\"hljs-keyword\">if</span> (testContext.failed()) {  <b class=\"conum\">(3)</b>\n      <span class=\"hljs-keyword\">throw</span> testContext.causeOfFailure();\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#succeedingThenComplete--\">succeedingThenComplete</a></code> returns an asynchronous result handler that is expected to succeed and then make the test context pass.</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#awaitCompletion-long-java.util.concurrent.TimeUnit-\">awaitCompletion</a></code> has the semantics of a <code>java.util.concurrent.CountDownLatch</code>, and returns <code>false</code> if the waiting delay expired before the test passed.</p>\n</li>\n<li>\n<p>If the context captures a (potentially asynchronous) error, then after completion we must throw the failure exception to make the test fail.</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_use_any_assertion_library\"><a class=\"anchor\" href=\"#_use_any_assertion_library\"></a>Use any assertion library</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This module does not make any assumption on the assertion library that you should be using.\nYou can use plain JUnit assertions, <a href=\"http://joel-costigliola.github.io/assertj/\">AssertJ</a>, etc.</p>\n</div>\n<div class=\"paragraph\">\n<p>To make assertions in asynchronous code and make sure that <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> is notified of potential failures, you need to wrap them with a call to <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#verify-io.vertx.junit5.VertxTestContext.ExecutionBlock-\">verify</a></code>, <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#succeeding-io.vertx.core.Handler-\">succeeding</a></code>, or <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failing-io.vertx.core.Handler-\">failing</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient();\n\nclient.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n  .compose(req -&gt; req.send().compose(HttpClientResponse::body))\n  .onComplete(testContext.succeeding(buffer -&gt; testContext.verify(() -&gt; {\n    assertThat(buffer.toString()).isEqualTo(<span class=\"hljs-string\">&quot;Plop&quot;</span>);\n    testContext.completeNow();\n  })));</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The useful methods in <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> are the following:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#completeNow--\">completeNow</a></code> and <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failNow-java.lang.Throwable-\">failNow</a></code> to notify of a success or failure</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#succeedingThenComplete--\">succeedingThenComplete</a></code> to provide <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> handlers that expect a success and then completes the test context</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failingThenComplete--\">failingThenComplete</a></code> to provide <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> handlers that expect a failure and then completes the test context</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#succeeding--\">succeeding</a></code> to provide <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> handlers that expect a success and pass the result to another callback, any exception thrown from the callback is considered as a test failure</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#failing--\">failing</a></code> to provide <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code> handlers that expect a failure and pass the exception to another callback, any exception thrown from the callback is considered as a test failure</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#verify-io.vertx.junit5.VertxTestContext.ExecutionBlock-\">verify</a></code> to perform assertions, any exception thrown from the code block is considered as a test failure.</p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nUnlike <code>succeedingThenComplete</code> and <code>failingThenComplete</code>, calling <code>succeeding</code> and <code>failing</code> methods can only make a test fail (e.g., <code>succeeding</code> gets a failed asynchronous result).\nTo make a test pass you still need to call <code>completeNow</code>, or use checkpoints as explained below.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_checkpoint_when_there_are_multiple_success_conditions\"><a class=\"anchor\" href=\"#_checkpoint_when_there_are_multiple_success_conditions\"></a>Checkpoint when there are multiple success conditions</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Many tests can be marked as passed by simply calling <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#completeNow--\">completeNow</a></code> at some point of the execution.\nThat being said there are also many cases where the success of a test depends on different asynchronous parts to be validated.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can use checkpoints to flag some execution points to be passed.\nA <code><a href=\"../../apidocs/io/vertx/junit5/Checkpoint.html\">Checkpoint</a></code> can require a single flagging, or multiple flags.\nWhen all checkpoints have been flagged, then the corresponding <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> makes the test pass.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here is an example with checkpoints on the HTTP server being started, 10 HTTP requests having being responded, and 10 HTTP client requests having been made:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-type\">Checkpoint</span> <span class=\"hljs-variable\">serverStarted</span> <span class=\"hljs-operator\">=</span> testContext.checkpoint();\n<span class=\"hljs-type\">Checkpoint</span> <span class=\"hljs-variable\">requestsServed</span> <span class=\"hljs-operator\">=</span> testContext.checkpoint(<span class=\"hljs-number\">10</span>);\n<span class=\"hljs-type\">Checkpoint</span> <span class=\"hljs-variable\">responsesReceived</span> <span class=\"hljs-operator\">=</span> testContext.checkpoint(<span class=\"hljs-number\">10</span>);\n\nvertx.createHttpServer()\n  .requestHandler(req -&gt; {\n    req.response().end(<span class=\"hljs-string\">&quot;Ok&quot;</span>);\n    requestsServed.flag();\n  })\n  .listen(<span class=\"hljs-number\">8888</span>)\n  .onComplete(testContext.succeeding(httpServer -&gt; serverStarted.flag()));\n\n<span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient();\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n  client.request(HttpMethod.GET, <span class=\"hljs-number\">8888</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n    .compose(req -&gt; req.send().compose(HttpClientResponse::body))\n    .onComplete(testContext.succeeding(buffer -&gt; testContext.verify(() -&gt; {\n      assertThat(buffer.toString()).isEqualTo(<span class=\"hljs-string\">&quot;Ok&quot;</span>);\n      responsesReceived.flag();\n    })));\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\nCheckpoints should be created only from the test case main thread, not from Vert.x asynchronous event callbacks.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_integration_with_junit_5\"><a class=\"anchor\" href=\"#_integration_with_junit_5\"></a>Integration with JUnit 5</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>JUnit 5 provides a different model compared to the previous versions.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_test_methods\"><a class=\"anchor\" href=\"#_test_methods\"></a>Test methods</h3>\n<div class=\"paragraph\">\n<p>The Vert.x integration is primarily done using the <code><a href=\"../../apidocs/io/vertx/junit5/VertxExtension.html\">VertxExtension</a></code> class, and using test parameter injection of <code>Vertx</code> and <code>VertxTestContext</code> instances:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeTest</span> {\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">some_test</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-comment\">// (...)</span>\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nThe <code>Vertx</code> instance is not clustered and has the default configuration. If you need something else then just don&#8217;t use injection on that parameter and prepare a <code>Vertx</code> object by yourself.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>The test is automatically wrapped around the <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> instance lifecycle, so you don&#8217;t need to insert <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html#awaitCompletion-long-java.util.concurrent.TimeUnit-\">awaitCompletion</a></code> calls yourself:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeTest</span> {\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">http_server_check_response</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    vertx.deployVerticle(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpServerVerticle</span>(), testContext.succeeding(id -&gt; {\n      <span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient();\n      client.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n        .compose(req -&gt; req.send().compose(HttpClientResponse::body))\n        .onComplete(testContext.succeeding(buffer -&gt; testContext.verify(() -&gt; {\n          assertThat(buffer.toString()).isEqualTo(<span class=\"hljs-string\">&quot;Plop&quot;</span>);\n          testContext.completeNow();\n        })));\n    }));\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can use it with standard JUnit annotations such as <code>@RepeatedTest</code> or lifecycle callbacks annotations:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeTest</span> {\n\n  <span class=\"hljs-comment\">// Deploy the verticle and execute the test methods when the verticle</span>\n  <span class=\"hljs-comment\">// is successfully deployed</span>\n  <span class=\"hljs-meta\">@BeforeEach</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">deploy_verticle</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    vertx.deployVerticle(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HttpServerVerticle</span>(), testContext.succeedingThenComplete());\n  }\n\n  <span class=\"hljs-comment\">// Repeat this test 3 times</span>\n  <span class=\"hljs-meta\">@RepeatedTest(3)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">http_server_check_response</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-type\">HttpClient</span> <span class=\"hljs-variable\">client</span> <span class=\"hljs-operator\">=</span> vertx.createHttpClient();\n    client.request(HttpMethod.GET, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)\n      .compose(req -&gt; req.send().compose(HttpClientResponse::body))\n      .onComplete(testContext.succeeding(buffer -&gt; testContext.verify(() -&gt; {\n        assertThat(buffer.toString()).isEqualTo(<span class=\"hljs-string\">&quot;Plop&quot;</span>);\n        testContext.completeNow();\n      })));\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It is also possible to customize the default <code><a href=\"../../apidocs/io/vertx/junit5/VertxTestContext.html\">VertxTestContext</a></code> timeout using the <code><a href=\"../../apidocs/io/vertx/junit5/Timeout.html\">@Timeout</a></code> annotation either on test classes or methods:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeTest</span> {\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@Timeout(value = 10, timeUnit = TimeUnit.SECONDS)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">some_test</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext context)</span> {\n    <span class=\"hljs-comment\">// (...)</span>\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_lifecycle_methods\"><a class=\"anchor\" href=\"#_lifecycle_methods\"></a>Lifecycle methods</h3>\n<div class=\"paragraph\">\n<p>JUnit 5 provides several user-defined lifecycle methods annotated with <code>@BeforeAll</code>, <code>@BeforeEach</code>, <code>@AfterEach</code> and <code>@AfterAll</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>These methods can request the injection of <code>Vertx</code> instances.\nBy doing so, they are likely to perform asynchronous operations with the <code>Vertx</code> instance, so they can request the injection of a <code>VertxTestContext</code> instance to ensure that the JUnit runner waits for them to complete, and report possible errors.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here is an example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LifecycleExampleTest</span> {\n\n  <span class=\"hljs-meta\">@BeforeEach</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;Deploy a verticle&quot;)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">prepare</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    vertx.deployVerticle(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SomeVerticle</span>(), testContext.succeedingThenComplete());\n  }\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;A first test&quot;)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">foo</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-comment\">// (...)</span>\n    testContext.completeNow();\n  }\n\n  <span class=\"hljs-meta\">@Test</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;A second test&quot;)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bar</span><span class=\"hljs-params\">(Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-comment\">// (...)</span>\n    testContext.completeNow();\n  }\n\n  <span class=\"hljs-meta\">@AfterEach</span>\n  <span class=\"hljs-meta\">@DisplayName(&quot;Check that the verticle is still there&quot;)</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">lastChecks</span><span class=\"hljs-params\">(Vertx vertx)</span> {\n    assertThat(vertx.deploymentIDs())\n      .isNotEmpty()\n      .hasSize(<span class=\"hljs-number\">1</span>);\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_scope_of_vertxtestcontext_objects\"><a class=\"anchor\" href=\"#_scope_of_vertxtestcontext_objects\"></a>Scope of <code>VertxTestContext</code> objects</h4>\n<div class=\"paragraph\">\n<p>Since these objects help waiting for asynchronous operations to complete, a new instance is created for any <code>@Test</code>, <code>@BeforeAll</code>, <code>@BeforeEach</code>, <code>@AfterEach</code> and <code>@AfterAll</code> method.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_scope_of_vertx_objects\"><a class=\"anchor\" href=\"#_scope_of_vertx_objects\"></a>Scope of <code>Vertx</code> objects</h4>\n<div class=\"paragraph\">\n<p>The scope of a <code>Vertx</code> object depends on which lifecycle method in the <a href=\"http://junit.org/junit5/docs/current/user-guide/#extensions-execution-order\">JUnit relative execution order</a> first required a new instance to be created.\nGenerally-speaking, we respect the JUnit extension scoping rules, but here are the specifications.</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>If a parent test context already had a <code>Vertx</code> instance, it is being reused in children extension test contexts.</p>\n</li>\n<li>\n<p>Injecting in a <code>@BeforeAll</code> method creates a new instance that is being shared for injection in all subsequent test and lifecycle methods.</p>\n</li>\n<li>\n<p>Injecting in a <code>@BeforeEach</code> with no parent context or previous <code>@BeforeAll</code> injection creates a new instance shared with the corresponding test and <code>AfterEach</code> method(s).</p>\n</li>\n<li>\n<p>When no instance exists before running a test method, an instance is created for that test (and only for that test).</p>\n</li>\n</ol>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_closing_and_removal_of_vertx_objects\"><a class=\"anchor\" href=\"#_closing_and_removal_of_vertx_objects\"></a>Closing and removal of <code>Vertx</code> objects</h4>\n<div class=\"paragraph\">\n<p>Injected <code>Vertx</code> objects are being automatically closed and removed from their corresponding scopes.</p>\n</div>\n<div class=\"paragraph\">\n<p>For instance if a <code>Vertx</code> object is created for the scope of a test method, it is being closed after the test completes.\nSimilarly, when it is being created by a <code>@BeforeEach</code> method, it is being closed after possible <code>@AfterEach</code> methods have completed.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_warning_on_multiple_methods_for_the_same_lifecycle_events\"><a class=\"anchor\" href=\"#_warning_on_multiple_methods_for_the_same_lifecycle_events\"></a>Warning on multiple methods for the same lifecycle events</h4>\n<div class=\"paragraph\">\n<p>JUnit 5 allows multiple methods to exist for the same lifecycle events.</p>\n</div>\n<div class=\"paragraph\">\n<p>As an example, it is possible to define 3 <code>@BeforeEach</code> methods on the same test.\nBecause of asynchronous operations it is possible that the effects of these methods happen concurrently rather than sequentially, which may lead to inconsistent states.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is a problem of JUnit 5 rather than this module. In case of doubt you may always wonder why a single method can&#8217;t be better than many.</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_support_for_additional_parameter_types\"><a class=\"anchor\" href=\"#_support_for_additional_parameter_types\"></a>Support for additional parameter types</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Vert.x JUnit 5 extension is extensible: you can add more types through the\n<code><a href=\"../../apidocs/io/vertx/junit5/VertxExtensionParameterProvider.html\">VertxExtensionParameterProvider</a></code> service provider interface.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you use RxJava 2, you can inject a <code>io.vertx.reactivex.core.Vertx</code> (rather than <code>io.vertx.core.Vertx</code>) just adding the dependency <code>io.vertx:vertx-junit5-rx-java2</code>.\nThe same applies for RxJava 1.x with the dependency <code>io.vertx:vertx-junit5-rx-java2</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>On Reactiverse you can find a growing collection of extensions for <code>vertx-junit5</code> that integrates with Vert.x stack in the <code>reactiverse-junit5-extensions</code> project:\n<a href=\"https://github.com/reactiverse/reactiverse-junit5-extensions\" class=\"bare\">https://github.com/reactiverse/reactiverse-junit5-extensions</a>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_parameter_ordering\"><a class=\"anchor\" href=\"#_parameter_ordering\"></a>Parameter ordering</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>It may be the case that a parameter type has to be placed before another parameter.\nFor instance the Web Client support in the <code>vertx-junit5-extensions</code> project requires that the <code>Vertx</code> argument is before the <code>WebClient</code> argument.\nThis is because the <code>Vertx</code> instance needs to exist to create the <code>WebClient</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>It is expected that parameter providers throw meaningful exceptions to let users know of possible ordering constraints.</p>\n</div>\n<div class=\"paragraph\">\n<p>In any case it is a good idea to have the <code>Vertx</code> parameter first, and the next parameters in the order of what you&#8217;d need to create them manually.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_parameterized_tests_with_methodsource\"><a class=\"anchor\" href=\"#_parameterized_tests_with_methodsource\"></a>Parameterized tests with <code>@MethodSource</code></h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You can use parameterized tests with <code>@MethodSource</code> with vertx-junit5. Therefore you need to declare the method source parameters before the vertx test parameters in\nthe method definition.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-meta\">@ExtendWith(VertxExtension.class)</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeTest</span> {\n\n  <span class=\"hljs-keyword\">static</span> Stream&lt;Arguments&gt; <span class=\"hljs-title function_\">testData</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> Stream.of(\n      Arguments.of(<span class=\"hljs-string\">&quot;complex object1&quot;</span>, <span class=\"hljs-number\">4</span>),\n      Arguments.of(<span class=\"hljs-string\">&quot;complex object2&quot;</span>, <span class=\"hljs-number\">0</span>)\n    );\n  }\n\n  <span class=\"hljs-meta\">@ParameterizedTest</span>\n  <span class=\"hljs-meta\">@MethodSource(&quot;testData&quot;)</span>\n   <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">test2</span><span class=\"hljs-params\">(String obj, <span class=\"hljs-type\">int</span> count, Vertx vertx, VertxTestContext testContext)</span> {\n    <span class=\"hljs-comment\">// your test code</span>\n    testContext.completeNow();\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The same holds for the other <code>ArgumentSources</code>. See the section <code>Formal Parameter List</code> in the API doc of\n<a href=\"https://junit.org/junit5/docs/current/api/org.junit.jupiter.params/org/junit/jupiter/params/ParameterizedTest.html\">ParameterizedTest</a></p>\n</div>\n</div>\n</div>","version":"4.0.2"},"__N_SSG":true}